"use strict";

function asyncGeneratorStep(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n) {
        return void e(n);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}

function _asyncToGenerator(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise((function(r, o) {
            var a = n.apply(t, e);
            function _next(n) {
                asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
            }
            function _throw(n) {
                asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
            }
            _next(void 0);
        }));
    };
}

function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter((function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        }))), t.push.apply(t, o);
    }
    return t;
}

function _objectSpread(e) {
    for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach((function(r) {
            _defineProperty(e, r, t[r]);
        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach((function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        }));
    }
    return e;
}

function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}

function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}

function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}

var lng = require("@lightningjs/core");

class Logger {
    constructor() {
        this._logCallback = undefined;
        this._prefix = "LightningUI";
        this._debug = false;
    }
    get debug() {
        return this._debug;
    }
    set debug(value) {
        this._debug = Boolean(value);
    }
    get logCallback() {
        return this._logCallback;
    }
    set logCallback(value) {
        if ("function" !== typeof value) {
            this.warn("logCallback value must be a function, instead received ".concat(typeof value));
            return;
        }
        this._logCallback = value;
    }
    log() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }
        if (this._logCallback) {
            this._logCallback({
                level: "log",
                payload: args
            });
        }
        if (this.debug) {
            console.log(this._prefix, ...args);
        }
    }
    info() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
        }
        if (this._logCallback) {
            this._logCallback({
                level: "info",
                payload: args
            });
        }
        if (this.debug) {
            console.info(this._prefix, ...args);
        }
    }
    warn() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
        }
        if (this._logCallback) {
            this._logCallback({
                level: "warn",
                payload: args
            });
        }
        if (this.debug) {
            console.warn(this._prefix, ...args);
        }
    }
    error() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
        }
        if (this._logCallback) {
            this._logCallback({
                level: "error",
                payload: args
            });
        }
        if (this.debug) {
            console.error(this._prefix, ...args);
        }
    }
}

var loggerInstance = new Logger;

function debounce(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    if (null == wait) wait = 100;
    function later() {
        var last = Date.now() - timestamp;
        if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last);
        } else {
            timeout = null;
            if (!immediate) {
                result = func.apply(context, args);
                context = args = null;
            }
        }
    }
    var debounced = function debounced() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
            result = func.apply(context, args);
            context = args = null;
        }
        return result;
    };
    debounced.clear = function() {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
    };
    debounced.flush = function() {
        if (timeout) {
            result = func.apply(context, args);
            context = args = null;
            clearTimeout(timeout);
            timeout = null;
        }
    };
    return debounced;
}

function getEuclideanDistance(xA, yA, xB, yB) {
    var xDiff = xA - xB;
    var yDiff = yA - yB;
    return Math.sqrt(Math.pow(xDiff, 2) + Math.sqrt(Math.pow(yDiff, 2)));
}

function getShortestDistance(coordinate, element) {
    var [xA, yA] = coordinate;
    var [xB, yB] = element.core ? element.core.getAbsoluteCoords(0, 0) : [ 0, 0 ];
    var distanceToStart = getEuclideanDistance(xA, yA, xB, yB);
    var distanceToMiddle = getEuclideanDistance(xA, yA, xB + element.w / 2, yB + element.h / 2);
    var distanceToEnd = getEuclideanDistance(xA, yA, xB + element.w, yB + element.h);
    return Math.min(distanceToStart, distanceToMiddle, distanceToEnd);
}

function isComponentOnScreen(component) {
    var offsets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!component) return false;
    var {w: w, h: h, core: {renderContext: {px: px, py: py}, _scissor: scissor = []} = {}} = component;
    var stageH = component.stage.h / component.stage.getRenderPrecision();
    var stageW = component.stage.w / component.stage.getRenderPrecision();
    var finalX = px;
    var finalY = py;
    var relativeOffsetX = px - component.x;
    var relativeOffsetY = py - component.y;
    var offsetX = offsets.offsetX - relativeOffsetX || 0;
    var offsetY = offsets.offsetY - relativeOffsetY || 0;
    if (component.transition("x")) {
        finalX = px - component.x + component.transition("x").targetValue;
    }
    if (component.transition("y")) {
        finalY = py - component.y + component.transition("y").targetValue;
    }
    finalX += offsetX;
    finalY += offsetY;
    var wVis = finalX >= 0 && finalX + w <= stageW;
    var hVis = finalY >= 0 && finalY + h <= stageH;
    if (!wVis || !hVis) return false;
    if (scissor && scissor.length) {
        var [leftBounds = null, topBounds = null, clipWidth = null, clipHeight = null] = scissor;
        var withinLeftClippingBounds = Math.round(finalX + w) >= Math.round(leftBounds);
        var withinRightClippingBounds = Math.round(finalX) <= Math.round(leftBounds + clipWidth);
        var withinTopClippingBounds = Math.round(finalY + h) >= Math.round(topBounds);
        var withinBottomClippingBounds = Math.round(finalY + h) <= Math.round(topBounds + clipHeight);
        return withinLeftClippingBounds && withinRightClippingBounds && withinTopClippingBounds && withinBottomClippingBounds;
    }
    return true;
}

function getWidthByUpCount(theme) {
    var upCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var screenW = theme.layout.screenW;
    var columnCount = theme.layout.columnCount;
    var marginX = theme.layout.marginX;
    var gutterX = theme.layout.gutterX;
    if (upCount < 1 || upCount > columnCount) {
        console.error("Column expects a number between 1 & ".concat(columnCount, ". Received ").concat(upCount));
        return;
    }
    var columnWidth = screenW - marginX * 2;
    var columnGapTotal = (upCount - 1) * gutterX;
    var totalColumnsWidth = columnWidth - columnGapTotal;
    return totalColumnsWidth / upCount;
}

function getWidthByColumnSpan(theme, columnSpan) {
    var columnCount = theme.layout.columnCount;
    var gutterX = theme.layout.gutterX;
    return getWidthByUpCount(theme, columnCount) * columnSpan + gutterX * (columnSpan - 1);
}

function getDimensions(theme) {
    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var {w: w, h: h, ratioX: ratioX, ratioY: ratioY, upCount: upCount} = obj;
    var fallbackW = fallback.w || 0;
    var fallbackH = fallback.h || 0;
    var dimensions = {};
    if (w && h) {
        dimensions = {
            w: w,
            h: h
        };
    } else if (h && ratioX && ratioY) {
        dimensions = {
            w: Math.round(h * ratioX / ratioY),
            h: h
        };
    } else if (ratioX && ratioY && upCount) {
        dimensions = getItemRatioDimensions(theme, ratioX, ratioY, upCount);
    } else if (h && upCount) {
        dimensions = {
            w: Math.round(getWidthByUpCount(theme, upCount)),
            h: h
        };
    } else if (h) {
        dimensions = {
            w: fallbackW,
            h: h
        };
    } else if (w) {
        dimensions = {
            w: w,
            h: fallbackH
        };
    } else {
        dimensions = {
            w: fallbackW,
            h: fallbackH
        };
    }
    dimensions = _objectSpread(_objectSpread({}, dimensions), {}, {
        ratioX: ratioX,
        ratioY: ratioY,
        upCount: upCount
    });
    return dimensions;
}

function getItemRatioDimensions(theme, ratioX, ratioY, upCount) {
    var w, h;
    if (ratioX && ratioY && upCount) {
        w = Math.round(getWidthByUpCount(theme, upCount));
        h = Math.round(w / ratioX * ratioY);
    } else {
        w = 0;
        h = 0;
    }
    return {
        w: w,
        h: h
    };
}

function getAspectRatioW(h) {
    var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "16:9";
    var seperator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ":";
    var [ratioW, ratioH] = ratio.split(seperator);
    return h * (ratioW / ratioH);
}

function getAspectRatioH(w) {
    var ratio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "16:9";
    var seperator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ":";
    var [ratioW, ratioH] = ratio.split(seperator);
    return w / (ratioW / ratioH);
}

function getHexColor(hex) {
    var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    if (!hex) {
        return 0;
    }
    if (typeof hex === "number") {
        hex = hex.toString(16).slice(2);
    }
    hex = hex.replace("#", "");
    var hexAlpha = Math.round(alpha * 255).toString(16);
    var str = "0x".concat(hexAlpha).concat(hex);
    return Number(str);
}

function getValidColor(color) {
    if (typeof color === "string" || typeof color === "number") {
        if (/^0x[0-9a-fA-F]{8}/g.test(color)) {
            return Number(color);
        } else if (/^#[0-9a-fA-F]{6}/g.test(color)) {
            return getHexColor(color.substr(1, 6));
        } else if (typeof color === "string" && /^[0-9]{8,10}/g.test(color)) {
            return parseInt(color);
        } else if (typeof color === "number" && /^[0-9]{8,10}/g.test(color.toString())) {
            return color;
        } else if (typeof color === "string" && color.indexOf("rgba") > -1) {
            return rgba2argb(color);
        } else if (typeof color === "string" && color.indexOf("rgb") > -1) {
            var rgba = [ ...color.replace(/rgb\(|\)/g, "").split(","), "255" ];
            return lng.StageUtils.getArgbNumber(rgba);
        }
    }
    return null;
}

function simplifyFraction(_ref) {
    var [numerator, denominator] = _ref;
    for (var i = numerator; i > 0; i--) {
        if (!(numerator % i) && !(denominator % i)) {
            return [ numerator / i, denominator / i ];
        }
    }
}

function reduceFraction(string) {
    return simplifyFraction(string.split("/").map((n => +n))).join("/");
}

var getValFromObjPath = (object, path) => {
    if (typeof path === "string") path = path.split(".").filter((key => key.length));
    return path.reduce(((dive, key) => dive && dive[key]), object);
};

function rgba2argb(rgbaStr) {
    var rgba = rgbaStr.replace(/rgba\(|\)/g, "").split(",");
    rgba[3] = rgba[3] * 255;
    return lng.StageUtils.getArgbNumber(rgba);
}

function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

var RoundRect = {
    getWidth(w) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var {padding: padding, paddingLeft: paddingLeft, paddingRight: paddingRight, strokeWidth: strokeWidth} = _objectSpread({
            padding: 0,
            paddingLeft: 0,
            paddingRight: 0,
            strokeWidth: 0
        }, options);
        if (!w) return 0;
        return w - (paddingLeft || padding) - (paddingRight || padding) - strokeWidth;
    },
    getHeight(h) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var {padding: padding, paddingBottom: paddingBottom, paddingTop: paddingTop, strokeWidth: strokeWidth} = _objectSpread({
            padding: 0,
            paddingBottom: 0,
            paddingTop: 0,
            strokeWidth: 0
        }, options);
        if (!h) return 0;
        return h - (paddingBottom || padding) - (paddingTop || padding) - strokeWidth;
    }
};

function clone(target, object) {
    var _clone = Object.create(Object.getPrototypeOf(target));
    Object.defineProperties(_clone, Object.getOwnPropertyDescriptors(target));
    if (!object || target === object) return _clone;
    for (var key in object) {
        var value = object[key];
        if (target.hasOwnProperty(key)) {
            _clone[key] = getMergeValue(key, target, object);
        } else {
            _clone[key] = value;
        }
    }
    return _clone;
}

function getMergeValue(key, target, object) {
    var targetVal = target[key];
    var objectVal = object[key];
    var targetValType = typeof targetVal;
    var objectValType = typeof objectVal;
    if (targetValType !== objectValType || objectValType === "function" || Array.isArray(objectVal)) {
        return objectVal;
    }
    if (objectVal && objectValType === "object") {
        return clone(targetVal, objectVal);
    }
    return objectVal;
}

function measureTextWidth() {
    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var canvas = document.createElement("canvas");
    var ctx = canvas.getContext("2d");
    var {fontStyle: fontStyle, fontWeight: fontWeight, fontSize: fontSize, fontFamily: fontFamily = text.fontFace || "sans-serif"} = text;
    var fontCss = [ fontStyle, fontWeight, fontSize ? "".concat(fontSize, "px") : "0", "'".concat(fontFamily, "'") ].filter(Boolean).join(" ");
    ctx.font = fontCss;
    var textMetrics = ctx.measureText(text.text || "");
    return Math.round(textMetrics.width);
}

function getFirstNumber() {
    for (var _len5 = arguments.length, numbers = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        numbers[_key5] = arguments[_key5];
    }
    return numbers.find(Number.isFinite);
}

function getDimension(prop, component) {
    if (!component) return 0;
    var transition = component.transition(prop);
    if (transition.isRunning()) return transition.targetValue;
    var renderProp = prop;
    if (prop === "w") {
        renderProp = "renderWidth";
    } else if (prop === "h") {
        renderProp = "renderHeight";
    }
    return component[renderProp] || component[prop];
}

var getX = component => getDimension("x", component);

var getY = component => getDimension("y", component);

var getW = component => getDimension("w", component);

var getH = component => getDimension("h", component);

function flatten(arr) {
    return arr.reduce(((flat, toFlatten) => flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten)), []);
}

function objectPropertyOf(object, path) {
    return path.reduce(((obj, key) => obj && obj[key] !== "undefined" ? obj[key] : undefined), object);
}

function stringifyCompare(objA, objB) {
    return JSON.stringify(objA) === JSON.stringify(objB);
}

function delayForAnimation(callback) {
    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;
    setTimeout(callback, delay);
}

function downloadFile(content, fileName, contentType) {
    var validContentTypes = [ "plain", "json" ];
    if (!validContentTypes.includes(contentType)) {
        contentType = "plain";
    }
    var dataStr = "data:text/".concat(contentType, ";charset=utf-8,") + encodeURIComponent(JSON.stringify(content));
    var dlAnchorElem = document.createElement("a");
    dlAnchorElem.setAttribute("href", dataStr);
    dlAnchorElem.setAttribute("download", fileName);
    dlAnchorElem.click();
}

var degreesToRadians = deg => deg * (Math.PI / 180);

var MARKUP_STRING_PATTERN = /({ICON.*?}|{BADGE:.*?}|{NEWLINE}|{TEXT:.*?})/g;

function isMarkupString() {
    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    if (typeof str !== "string") {
        return false;
    }
    return MARKUP_STRING_PATTERN.test(str);
}

function parseInlineContent() {
    var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    var content = [];
    if (str && typeof str === "string" || str.text) {
        var string = typeof str === "string" ? str : str.text;
        var iconRegEx = /^{ICON:(.*?)?\|(.*?)?}$/g;
        var badgeRegEx = /^{BADGE:(.*?)}$/g;
        var newlineRegEx = /^{NEWLINE}$/g;
        var textRegEx = /^{TEXT:(.*?)?\|(.*?)?}$/g;
        var splitStr = string.split(MARKUP_STRING_PATTERN);
        if (splitStr && splitStr.length) {
            splitStr.forEach((item => {
                var formattedItem = item;
                var badge = badgeRegEx.exec(item);
                var icon = iconRegEx.exec(item);
                var newline = newlineRegEx.exec(item);
                var text = textRegEx.exec(item);
                if (badge && badge[1]) {
                    formattedItem = {
                        badge: badge[1]
                    };
                } else if (icon && icon[1]) {
                    formattedItem = {
                        title: icon[1],
                        icon: icon[2] || icon[1]
                    };
                } else if (newline) {
                    formattedItem = {
                        newline: true
                    };
                } else if (text && text[1]) {
                    formattedItem = {
                        text: text[1],
                        style: text[2]
                    };
                }
                content.push(formattedItem);
            }));
        }
    }
    return content;
}

function max() {
    if (!arguments) {
        return;
    }
    var args = Array.from(arguments).filter((arg => !isNaN(arg) && arg != null));
    if (!args.length) {
        return;
    }
    return Math.max(...args);
}

function createConditionalZContext(component, zOffset) {
    if (!component.zIndex && typeof zOffset !== "undefined" && zOffset !== 0) {
        component.forceZIndexContext = true;
        component.zIndex = 0;
    }
}

function watchForUpdates(_ref2) {
    var _element$__core;
    var {element: element, watchProps: watchProps = [], sideEffect: sideEffect = () => {}} = _ref2;
    if (!(element !== null && element !== void 0 && element.isElement)) {
        loggerInstance.error("watchForUpdates: Expected a Lightning Element passed to element parameter, received ".concat(typeof element));
    }
    var initialOnAfterUpdate = (_element$__core = element.__core) === null || _element$__core === void 0 ? void 0 : _element$__core._onAfterUpdate;
    element.onAfterUpdate = function(element) {
        var hasChanged = false;
        watchProps.forEach((prop => {
            if (element.transition(prop) && element.transition(prop).isRunning()) {
                return;
            }
            var prevValueKey = "__watchPrev".concat(prop);
            var nextValue = element[prop];
            if (nextValue !== element[prevValueKey]) {
                element[prevValueKey] = nextValue;
                hasChanged = true;
            }
        }));
        if (hasChanged) {
            sideEffect();
        }
        if (initialOnAfterUpdate) {
            initialOnAfterUpdate(element);
        }
    }.bind(this);
    return element;
}

function convertTextAlignToFlexJustify(align) {
    switch (align) {
      case "left":
        return "flex-start";

      case "center":
        return "center";

      case "right":
        return "flex-end";

      default:
        console.warn('Expected "textAlign" values are "left," "center," and "right," but instead, '.concat(align, ' was received and will fall back to "left."'));
        return "flex-start";
    }
}

function getMaxRoundRadius(radius, width, height) {
    var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var maxRadius = r => Math.max(0, Math.min(r, Math.min(width, height) / 2) + offset);
    return Array.isArray(radius) ? radius.map((r => Number(maxRadius(r)) || 0)) : Number(maxRadius(radius)) || 0;
}

var utils = {
    isMarkupString: isMarkupString,
    capitalizeFirstLetter: capitalizeFirstLetter,
    degreesToRadians: degreesToRadians,
    downloadFile: downloadFile,
    delayForAnimation: delayForAnimation,
    stringifyCompare: stringifyCompare,
    objectPropertyOf: objectPropertyOf,
    flatten: flatten,
    getDimension: getDimension,
    getFirstNumber: getFirstNumber,
    measureTextWidth: measureTextWidth,
    clone: clone,
    getMergeValue: getMergeValue,
    RoundRect: RoundRect,
    rgba2argb: rgba2argb,
    getValFromObjPath: getValFromObjPath,
    reduceFraction: reduceFraction,
    getValidColor: getValidColor,
    getHexColor: getHexColor,
    getAspectRatioH: getAspectRatioH,
    getAspectRatioW: getAspectRatioW,
    getWidthByUpCount: getWidthByUpCount,
    getDimensions: getDimensions,
    getWidthByColumnSpan: getWidthByColumnSpan,
    createConditionalZContext: createConditionalZContext,
    watchForUpdates: watchForUpdates,
    convertTextAlignToFlexJustify: convertTextAlignToFlexJustify,
    getMaxRoundRadius: getMaxRoundRadius
};

var utils$1 = utils;

class Metrics {
    constructor() {
        this._keyMetricsCallback = undefined;
    }
    get keyMetricsCallback() {
        return this._keyMetricsCallback;
    }
    set keyMetricsCallback(value) {
        if (-1 < [ "undefined", "function" ].indexOf(typeof value)) {
            this._keyMetricsCallback = value;
            return;
        }
        loggerInstance.warn("context keyMetricsCallback expected a function. Received ".concat(typeof value));
    }
}

var metricsInstance = new Metrics;

var eventEmitterInstance = new lng.EventEmitter;

var events = eventEmitterInstance;

var baseTheme = {
    name: "Base Lightning TV",
    alpha: {
        primary: 1,
        secondary: .7,
        tertiary: .1,
        inactive: .5,
        full: 1,
        none: 0,
        alpha1: .1,
        alpha2: .3,
        alpha3: .5,
        alpha4: .7,
        alpha5: .9
    },
    animation: {
        duration: {
            none: 0,
            xfast: .1,
            fast: .25,
            normal: .5,
            slow: .75,
            xslow: .9
        },
        delay: {
            none: 0,
            xfast: .01,
            fast: .025,
            normal: .05,
            slow: .075,
            xslow: .09
        },
        expressive: {
            timingFunction: "cubic-bezier(0, 0, 1, 1)",
            delay: 0,
            duration: .25
        },
        expressiveEntrance: {
            timingFunction: "cubic-bezier(0, 0, 1, 1)",
            delay: 0,
            duration: .25
        },
        expressiveExit: {
            timingFunction: "cubic-bezier(0, 0, 1, 1)",
            delay: 0,
            duration: .25
        },
        standard: {
            timingFunction: "cubic-bezier(0, 0, 1, 1)",
            delay: 0,
            duration: .25
        },
        standardEntrance: {
            timingFunction: "cubic-bezier(0, 0, 1, 1)",
            delay: 0,
            duration: .25
        },
        standardExit: {
            timingFunction: "cubic-bezier(0, 0, 1, 1)",
            delay: 0,
            duration: .25
        },
        utility: {
            timingFunction: "cubic-bezier(0, 0, 1, 1)",
            delay: 0,
            duration: .25
        },
        utilityEntrance: {
            timingFunction: "cubic-bezier(0, 0, 1, 1)",
            delay: 0,
            duration: .25
        },
        utilityExit: {
            timingFunction: "cubic-bezier(0, 0, 1, 1)",
            delay: 0,
            duration: .25
        }
    },
    asset: {
        arrowLeft: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAGKADAAQAAAABAAAAGAAAAADiNXWtAAAAi0lEQVRIDWNgGAWjIfD//38JID5Fk5AAGqwKxPeA+D/VLQCaaQLEr0CGgwBVLQCa5wbEn0EGwwDVLAAaGA3Ev2AGw2iqWAA0rBiI/8EMRaYptgBoWDeygehsci1gIlcjWfqArqZdEMFcBLSEdpGMZAntkimSJbTLaEiW0K6oQLKEdoUdzJJRemiHAAD4n+yzPWCs7QAAAABJRU5ErkJggg==",
        arrowRight: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAGKADAAQAAAABAAAAGAAAAADiNXWtAAAAg0lEQVRIDWNgGAWjIYArBP7//38KiCVwyVMsDjQcBO4BsSrFhmEzAGw8hHgFpEywqaFIDMkCEPMzELtRZCC6ZjQLQNxfQByNro5sPhYLQEL/gLiYbEORNeKwACbcDVPLBGMMOhrmVDSapkFE00imaTKlaUajaVFB28Ju0CXrUQfhDAEAEgHss6NhpLQAAAAASUVORK5CYII=",
        backspaceOutline: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAYAAADnRuK4AAAAAXNSR0IArs4c6QAACmpJREFUeF7tnVmoZUcVhv/feY4gBEVEH/KgCCZxCK2itNo4xQQH+kUN0TjEiDGKKBqnaExwBjUaR6KY+NQgiQkOMSYhYEScIopGJOqDE2hHjfP0y4p1Oqdv33v2qr32Prv2Paug6Ye7Vu2qv75TtWvtGohMqUBAAQZ80zUVQAKUEIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypfPsAJJ0NYC92XRHKPB3AAfLv18BuBLAFSR/NKZWswJI0vkA3jCmILsw75sAvIfkR8eo22wAknQSgMvGEGFD8vwxgFeQvGrI+s4CIEnHAPgugHsMWfkNzevDAM4i+Z8h6t88QJLuXOB5yBAVzjxuVeBaAM8ieXNUjzkAdAmA50Yrmv5HKPATACeQ/GNEm6YBkvRyANblZhpHAXsfekpkOGsWIEmPAHA9gDuOo13mWhS4gOSZfdVoEiBJ9wFwA4D7961Y+lUpsK/v7KxVgL4K4ElOCS4l+Uyn7a41k3Q0gMcC2ANgH4CHV1T2OyStx69OzQEk6TwAZztr8lMAx5P8s9N+Y8wk2cTjfQDu66z080h+zml7yKwpgCSdCOByZyX+BuBRJH/otN84M0kWN/s0gOc4Kv8Nko922B1m0gxAkh4I4AcVwcL9JA/UVnjT7CXdHYD9yEzfVUkAjib5uxqNmgCoBAu/CeBhzsJ/kORZTtuNN5Nk70bXAZ0Hy59G8qIawVoB6LMAnu8suE3tH0/y3077NAMg6esAuoaoC0la7M2dJgdI0ssAXOgs8W8BHEvS/s9UoYCkdwN4bYfL5STto7U7TQpQZbDQehzreawHylSpgKSTAVza4XYDyeNqsp4MoB7BwteQfH9N5dL2NgWK3l0vyAdJWhDXnSYBSNLtANh3GO/KwgMk97trlYbbKiDJPpzea5U8JKuYqDIeql0kvQPAG5352ZLMR5L8q9M+zXZQYFcAJOnJAL7sbGWLMFuk2SLOmYIKzB6gEiz8HoB7O7U4meQXnLZp1qGApD8BuOcsh7AewcL3kuyadg4OjSSbhRxH0j4BjJok2Ufga0j+YdQHlcznDlBNsPAa+xpP8r/rEHbxjAKPbRuyHvKFY0Ik6QUALOprPfIT1gHRbAGSdDoA77aSX5Zg4e8nhGfx6FEgWoJn8Zy1QCTplq5vjc3NwnoEC/eQ/HYD8IwC0TbwrA2i2QHUI1h4JskLGoJnUIhWwLMWiGYFkCSLMX2t5WDhlneeLm5Dw5kDntEhkmRhEVvesWNqZgiTdC6AN3W1Svn72oOFkuxF+WcVIQUrai+IKuA5BBHJ453auc1mA1AJFn7Jsf7EKj9ZsLBHw1ZDtI5neAmaBUBzCxaO2cBj5u2FZtlO0l8A3K3ZIaxHsPB8kt5vYn00c/mM0dBj5OmqzAqjOQDUfLBwJ32HbPAh84pCM5seSNJLAHzcWeFJgoVdZRui4YfIo6ucff8uyVY03LW5IawyWPgvW5u77mChV/QIABFfb/kidk0CVKbDth3Huw35dJLeniqiV2/fniDYx1f7vlWTeoUFah6wZQhrqwcqwUKbrtsaH0+6mOQpHsOpbXpCVFPstcJjBZNkmzHv0swQJultAN7iVO375TyafzjtJzcbEaK1w9McQJXBQlvvYmtsfjE5FZUFGAGiSeBpCqDKYKFtmX0qya9Utl0z5gNCNBk8BSA7CtiODNwxjf4trEew8BySNtTNOg0A0aTwtARQTbDQeh3rfawXmn0KQDQ5PC0B9EkAL3LSkAD9X6hWALIJzJ3mNoSdS9I7U3NyuX6zQO+zKOzkEEmaHqDSFdpZM97tOfkSfRvvk0LUDEAFIgseetf85DS+AYgk/bPr1NvRZ2HLg4ektwI4xzmgZCBxYohaBMjWPeenDOcvaIvZ2oez5gAqQ5mtLbb3oa4z+Bb6nTHW1UP92vFIr54vzJ8BcGplGdYKkSRbCXGHSWdh2z1ckp1taGccroxyFt9cznG4iGuDqFmASk9kZxxakNGTckHZBBA1DVCB6BMAXuwhyA4VmGL/+05l6zlsbdt7DJmXU0uXmSQ7JvD2zQ1hiwJJsotRvlVxXO87SU5+heUYDT5Gni5KVhg1D1DphWqCjOYy6RlAYzb0mHn3gWkWABWIaoKMubHwSBpGebGWZNdc2vmUO6a1BhJXFUSSff/yLuOYamvzzwEcVfFr7tWwPXqi6uN2PXWYG0C1Qca1n8RaDlewl3kPRL3gWXo/XBwo1dXWdk/a3jEOnJoVQGUoqw0yvpLkh7oUHvLvTohC8FRANBo8pT3sxLeVJ/M2M4QtiVYTZJzkNPoOiAaBxwHRqPDMFqBS8Jog4yT3YewA0aDwrIBodHhmDVApvG0mtO3PnjTJjTxbIBoFnm0gWgs8pQ06lxY3N4QtCWZBRgPDezdnHvPr+alV2EiaL0DlF2Dbn20bdB40XtHwQ5nOHqAC0SyCjEM1Wkv57AqACkRvBvB2p7hrDzI6yzU7s90EUPNBxtnR4SjwrgGo9EK1Qca8cM4ByU4mkuz++F93ZHELyZX3iW31n+S+sKWZWfNBxkCbNeUq6ekArugo1I0kH1xT8EkBKj1R80HGGkFbtZVkZ3bb2d2r0tUkn1hTh8kBKhB9DMBLnQWfJMjoLFuTZpJsO/ONAB7UUcBLSHqvX781q1YAqg0yfoDkq5psrQYLJeldAF7nKFr1x+wmACq9kAUZLazvvTV4P8kDDlE22kTSQ4uuK9dCF5HuR/I3NYI1A1CBaB+AK50VsAMj7TJeixNl2kYBSccCsB/ZMQ6Brif5GIfdYSZNAVQg8rzsLSphl/Hapby2LDZTUaBcq/56ALb1fOVxLkuinULy4loRmwOoQGQX7T7DWZnPk3y203bXmkl6AIA91isDOBGADV3e1HsJbasA1QYZvUKl3fYKPI2knXFQnZoEqPRCNUHG6oqnwyEFLiJ5Wl89mgWoQFQTZOyrwSb7WUztcSRtu0+v1DRABaKPADijV+3SaZUCNgE5geTNEZnmAFBtkDGix6b4Xld2BNvJcaHUPEClF6oNMoZE2eXOtm3q1ZFha1mfWQBUINoL4Kqurbm7vPEj1bOAqx3udW0kk62+swGoQHQ2gPOGFGAD8roJgF0t+qkx6jorgApElwE4aQwxZp6n3YNxsPyzA7yst/4iSdvEMFqaHUCjKZEZ91IgAeolWzotFEiAkoWQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnT+H0jPT81J3xWWAAAAAElFTkSuQmCC",
        check: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAOCAYAAAAi2ky3AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACtSURBVHgBvdPdDcIgEAfwoy8Nb45QN3AGF2s36Ahu4gpuIDoBfSgfpdoTlCbEWEMh6T8hFzjyg5AAkBHOcQe5UWqspRx435sDpMYj6IYQwwVSEiJ2MKVUBWuzLSLl2HL+uxmNCGFO8yaL7RHxve6qRZoAuS4hxac8735elWVx7jrtMKL1o0Gcat9jhExHSukN/kUIFZ7MpDRtzE1isDRkAUtDvrA8ZI597FUf8gWH9P0b4gko9wAAAABJRU5ErkJggg=="
    },
    color: {
        white: [ "#ffffff", 1 ],
        black: [ "#000000", 1 ],
        grey: [ "#929096", 1 ],
        red: [ "#e74c3c", 1 ],
        orange: [ "#dc7633", 1 ],
        yellow: [ "#f7dc6f", 1 ],
        green: [ "#2Ecc71", 1 ],
        blue: [ "#93a9fd", 1 ],
        purple: [ "#663399", 1 ],
        palette: {
            "grey-05": [ "#f8f7fa", 1 ],
            "grey-40": [ "#929096", 1 ],
            "grey-70": [ "#48474b", 1 ],
            "grey-90": [ "#181819", 1 ],
            "blue-20": [ "#becffe", 1 ],
            "blue-40": [ "#93a9fd", 1 ],
            "blue-90": [ "#000033", 1 ]
        },
        material: [ "#181819", 1 ],
        materialBrand: [ "#000033", 1 ],
        overlay: [ "#181819", .7 ],
        textNeutral: [ "#f8f7fa", 1 ],
        textNeutralSecondary: [ "#f8f7fa", .7 ],
        textNeutralTertiary: [ "#f8f7fa", .1 ],
        textNeutralDisabled: [ "#f8f7fa", .5 ],
        textInverse: [ "#181819", 1 ],
        textInverseSecondary: [ "#181819", .7 ],
        textInverseTertiary: [ "#181819", .1 ],
        textInverseDisabled: [ "#181819", .5 ],
        textBrand: [ "#93a9fd", 1 ],
        textBrandSecondary: [ "#93a9fd", .7 ],
        textBrandTertiary: [ "#93a9fd", .1 ],
        textBrandDisabled: [ "#93a9fd", .5 ],
        textPositive: [ "#2Ecc71", 1 ],
        textNegative: [ "#e74c3c", 1 ],
        textInfo: [ "#93a9fd", 1 ],
        textCaution: [ "#dc7633", 1 ],
        fillTransparent: [ "#ffffff", 0 ],
        fillNeutral: [ "#f8f7fa", 1 ],
        fillNeutralSecondary: [ "#f8f7fa", .7 ],
        fillNeutralTertiary: [ "#f8f7fa", .1 ],
        fillNeutralDisabled: [ "#f8f7fa", .5 ],
        fillInverse: [ "#181819", 1 ],
        fillInverseSecondary: [ "#181819", .7 ],
        fillInverseTertiary: [ "#181819", .1 ],
        fillInverseDisabled: [ "#181819", .5 ],
        fillBrand: [ "#93a9fd", 1 ],
        fillBrandSecondary: [ "#93a9fd", .7 ],
        fillBrandTertiary: [ "#93a9fd", .1 ],
        fillBrandDisabled: [ "#93a9fd", .5 ],
        fillPositive: [ "#2Ecc71", 1 ],
        fillNegative: [ "#e74c3c", 1 ],
        fillInfo: [ "#93a9fd", 1 ],
        fillCaution: [ "#dc7633", 1 ],
        strokeNeutral: [ "#f8f7fa", 1 ],
        strokeNeutralSecondary: [ "#f8f7fa", .7 ],
        strokeNeutralTertiary: [ "#f8f7fa", .1 ],
        strokeNeutralDisabled: [ "#f8f7fa", .5 ],
        strokeInverse: [ "#181819", 1 ],
        strokeInverseSecondary: [ "#181819", .7 ],
        strokeInverseTertiary: [ "#181819", .1 ],
        strokeInverseDisabled: [ "#181819", .5 ],
        strokeBrand: [ "#93a9fd", 1 ],
        strokeBrandSecondary: [ "#93a9fd", .7 ],
        strokeBrandTertiary: [ "#93a9fd", .1 ],
        strokeBrandDisabled: [ "#93a9fd", .5 ],
        strokePositive: [ "#2Ecc71", 1 ],
        strokeNegative: [ "#e74c3c", 1 ],
        strokeInfo: [ "#93a9fd", 1 ],
        strokeCaution: [ "#dc7633", 1 ],
        interactiveNeutral: [ "#ffffff", .1 ],
        interactiveNeutralFocus: [ "#ffffff", 1 ],
        interactiveNeutralFocusSoft: [ "#ffffff", .1 ],
        interactiveInverse: [ "#48474b", undefined ],
        interactiveInverseFocus: [ "#48474b", 1 ],
        interactiveInverseFocusSoft: [ "#48474b", .1 ],
        interactiveBrand: [ "#becffe", .1 ],
        interactiveBrandFocus: [ "#becffe", 1 ],
        interactiveBrandFocusSoft: [ "#becffe", .1 ],
        shadowNeutral: [ "#000000", .7 ],
        shadowNeutralFocus: [ "#000000", .7 ],
        shadowNeutralFocusSoft: [ "#000000", .7 ],
        shadowNeutralText: [ "#000000", 1 ],
        shadowInverse: [ "#000000", .7 ],
        shadowInverseFocus: [ "#000000", .7 ],
        shadowInverseFocusSoft: [ "#000000", .7 ],
        shadowInverseText: [ "#000000", 1 ],
        shadowBrand: [ "#000000", .7 ],
        shadowBrandFocus: [ "#000000", .7 ],
        shadowBrandFocusSoft: [ "#000000", .7 ],
        shadowBrandText: [ "#000000", 1 ]
    },
    componentConfig: {
        Keyboard: {
            style: {
                keyProps: {
                    delete: {
                        title: null,
                        icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAYAAADnRuK4AAAAAXNSR0IArs4c6QAACmpJREFUeF7tnVmoZUcVhv/feY4gBEVEH/KgCCZxCK2itNo4xQQH+kUN0TjEiDGKKBqnaExwBjUaR6KY+NQgiQkOMSYhYEScIopGJOqDE2hHjfP0y4p1Oqdv33v2qr32Prv2Paug6Ye7Vu2qv75TtWvtGohMqUBAAQZ80zUVQAKUEIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypfPsAJJ0NYC92XRHKPB3AAfLv18BuBLAFSR/NKZWswJI0vkA3jCmILsw75sAvIfkR8eo22wAknQSgMvGEGFD8vwxgFeQvGrI+s4CIEnHAPgugHsMWfkNzevDAM4i+Z8h6t88QJLuXOB5yBAVzjxuVeBaAM8ieXNUjzkAdAmA50Yrmv5HKPATACeQ/GNEm6YBkvRyANblZhpHAXsfekpkOGsWIEmPAHA9gDuOo13mWhS4gOSZfdVoEiBJ9wFwA4D7961Y+lUpsK/v7KxVgL4K4ElOCS4l+Uyn7a41k3Q0gMcC2ANgH4CHV1T2OyStx69OzQEk6TwAZztr8lMAx5P8s9N+Y8wk2cTjfQDu66z080h+zml7yKwpgCSdCOByZyX+BuBRJH/otN84M0kWN/s0gOc4Kv8Nko922B1m0gxAkh4I4AcVwcL9JA/UVnjT7CXdHYD9yEzfVUkAjib5uxqNmgCoBAu/CeBhzsJ/kORZTtuNN5Nk70bXAZ0Hy59G8qIawVoB6LMAnu8suE3tH0/y3077NAMg6esAuoaoC0la7M2dJgdI0ssAXOgs8W8BHEvS/s9UoYCkdwN4bYfL5STto7U7TQpQZbDQehzreawHylSpgKSTAVza4XYDyeNqsp4MoB7BwteQfH9N5dL2NgWK3l0vyAdJWhDXnSYBSNLtANh3GO/KwgMk97trlYbbKiDJPpzea5U8JKuYqDIeql0kvQPAG5352ZLMR5L8q9M+zXZQYFcAJOnJAL7sbGWLMFuk2SLOmYIKzB6gEiz8HoB7O7U4meQXnLZp1qGApD8BuOcsh7AewcL3kuyadg4OjSSbhRxH0j4BjJok2Ufga0j+YdQHlcznDlBNsPAa+xpP8r/rEHbxjAKPbRuyHvKFY0Ik6QUALOprPfIT1gHRbAGSdDoA77aSX5Zg4e8nhGfx6FEgWoJn8Zy1QCTplq5vjc3NwnoEC/eQ/HYD8IwC0TbwrA2i2QHUI1h4JskLGoJnUIhWwLMWiGYFkCSLMX2t5WDhlneeLm5Dw5kDntEhkmRhEVvesWNqZgiTdC6AN3W1Svn72oOFkuxF+WcVIQUrai+IKuA5BBHJ453auc1mA1AJFn7Jsf7EKj9ZsLBHw1ZDtI5neAmaBUBzCxaO2cBj5u2FZtlO0l8A3K3ZIaxHsPB8kt5vYn00c/mM0dBj5OmqzAqjOQDUfLBwJ32HbPAh84pCM5seSNJLAHzcWeFJgoVdZRui4YfIo6ucff8uyVY03LW5IawyWPgvW5u77mChV/QIABFfb/kidk0CVKbDth3Huw35dJLeniqiV2/fniDYx1f7vlWTeoUFah6wZQhrqwcqwUKbrtsaH0+6mOQpHsOpbXpCVFPstcJjBZNkmzHv0swQJultAN7iVO375TyafzjtJzcbEaK1w9McQJXBQlvvYmtsfjE5FZUFGAGiSeBpCqDKYKFtmX0qya9Utl0z5gNCNBk8BSA7CtiODNwxjf4trEew8BySNtTNOg0A0aTwtARQTbDQeh3rfawXmn0KQDQ5PC0B9EkAL3LSkAD9X6hWALIJzJ3mNoSdS9I7U3NyuX6zQO+zKOzkEEmaHqDSFdpZM97tOfkSfRvvk0LUDEAFIgseetf85DS+AYgk/bPr1NvRZ2HLg4ektwI4xzmgZCBxYohaBMjWPeenDOcvaIvZ2oez5gAqQ5mtLbb3oa4z+Bb6nTHW1UP92vFIr54vzJ8BcGplGdYKkSRbCXGHSWdh2z1ckp1taGccroxyFt9cznG4iGuDqFmASk9kZxxakNGTckHZBBA1DVCB6BMAXuwhyA4VmGL/+05l6zlsbdt7DJmXU0uXmSQ7JvD2zQ1hiwJJsotRvlVxXO87SU5+heUYDT5Gni5KVhg1D1DphWqCjOYy6RlAYzb0mHn3gWkWABWIaoKMubHwSBpGebGWZNdc2vmUO6a1BhJXFUSSff/yLuOYamvzzwEcVfFr7tWwPXqi6uN2PXWYG0C1Qca1n8RaDlewl3kPRL3gWXo/XBwo1dXWdk/a3jEOnJoVQGUoqw0yvpLkh7oUHvLvTohC8FRANBo8pT3sxLeVJ/M2M4QtiVYTZJzkNPoOiAaBxwHRqPDMFqBS8Jog4yT3YewA0aDwrIBodHhmDVApvG0mtO3PnjTJjTxbIBoFnm0gWgs8pQ06lxY3N4QtCWZBRgPDezdnHvPr+alV2EiaL0DlF2Dbn20bdB40XtHwQ5nOHqAC0SyCjEM1Wkv57AqACkRvBvB2p7hrDzI6yzU7s90EUPNBxtnR4SjwrgGo9EK1Qca8cM4ByU4mkuz++F93ZHELyZX3iW31n+S+sKWZWfNBxkCbNeUq6ekArugo1I0kH1xT8EkBKj1R80HGGkFbtZVkZ3bb2d2r0tUkn1hTh8kBKhB9DMBLnQWfJMjoLFuTZpJsO/ONAB7UUcBLSHqvX781q1YAqg0yfoDkq5psrQYLJeldAF7nKFr1x+wmACq9kAUZLazvvTV4P8kDDlE22kTSQ4uuK9dCF5HuR/I3NYI1A1CBaB+AK50VsAMj7TJeixNl2kYBSccCsB/ZMQ6Brif5GIfdYSZNAVQg8rzsLSphl/Hapby2LDZTUaBcq/56ALb1fOVxLkuinULy4loRmwOoQGQX7T7DWZnPk3y203bXmkl6AIA91isDOBGADV3e1HsJbasA1QYZvUKl3fYKPI2knXFQnZoEqPRCNUHG6oqnwyEFLiJ5Wl89mgWoQFQTZOyrwSb7WUztcSRtu0+v1DRABaKPADijV+3SaZUCNgE5geTNEZnmAFBtkDGix6b4Xld2BNvJcaHUPEClF6oNMoZE2eXOtm3q1ZFha1mfWQBUINoL4Kqurbm7vPEj1bOAqx3udW0kk62+swGoQHQ2gPOGFGAD8roJgF0t+qkx6jorgApElwE4aQwxZp6n3YNxsPyzA7yst/4iSdvEMFqaHUCjKZEZ91IgAeolWzotFEiAkoWQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnT+H0jPT81J3xWWAAAAAElFTkSuQmCC"
                    }
                }
            }
        }
    },
    font: [],
    layout: {
        columnCount: 10,
        focusScale: 1.2,
        gutterX: 20,
        gutterY: 20,
        marginX: 150,
        marginY: 150,
        safe: 50,
        screenW: 1920,
        screenH: 1080
    },
    radius: {
        none: 0,
        xs: 2,
        sm: 4,
        md: 8,
        lg: 16,
        xl: 24
    },
    spacer: {
        none: 0,
        xxs: 2,
        xs: 4,
        sm: 8,
        md: 10,
        lg: 20,
        xl: 30,
        xxl: 40,
        xxxl: 50
    },
    stroke: {
        none: 0,
        sm: 2,
        md: 4,
        lg: 6,
        xl: 8
    },
    typography: {
        display1: {
            fontFamily: "Arial",
            fontSize: 75,
            lineHeight: 85,
            fontStyle: "500",
            verticalAlign: "middle",
            textBaseline: "bottom"
        },
        display2: {
            fontFamily: "Arial",
            fontSize: 50,
            lineHeight: 60,
            fontStyle: "500",
            verticalAlign: "middle",
            textBaseline: "bottom"
        },
        headline1: {
            fontFamily: "Arial",
            fontSize: 35,
            fontStyle: "500",
            lineHeight: 48,
            verticalAlign: "middle",
            textBaseline: "bottom"
        },
        headline2: {
            fontFamily: "Arial",
            fontSize: 30,
            fontStyle: "500",
            lineHeight: 40,
            verticalAlign: "middle",
            textBaseline: "bottom"
        },
        headline3: {
            fontFamily: "Arial",
            fontSize: 25,
            fontStyle: "500",
            lineHeight: 36,
            verticalAlign: "middle",
            textBaseline: "bottom"
        },
        body1: {
            fontFamily: "Arial",
            fontSize: 25,
            fontStyle: "300",
            lineHeight: 40,
            verticalAlign: "middle",
            textBaseline: "bottom"
        },
        body2: {
            fontFamily: "Arial",
            fontSize: 22,
            fontStyle: "300",
            lineHeight: 32,
            verticalAlign: "middle",
            textBaseline: "bottom"
        },
        body3: {
            fontFamily: "Arial",
            fontSize: 20,
            fontStyle: "300",
            lineHeight: 32,
            verticalAlign: "middle",
            textBaseline: "bottom"
        },
        button1: {
            fontFamily: "Arial",
            fontSize: 25,
            fontStyle: "500",
            lineHeight: 32,
            verticalAlign: "middle",
            textBaseline: "bottom"
        },
        button2: {
            fontFamily: "Arial",
            fontSize: 20,
            fontStyle: "500",
            lineHeight: 32,
            verticalAlign: "middle",
            textBaseline: "bottom"
        },
        callout1: {
            fontFamily: "Arial",
            fontSize: 20,
            fontStyle: "500",
            lineHeight: 32,
            verticalAlign: "middle",
            textBaseline: "bottom"
        },
        caption1: {
            fontFamily: "Arial",
            fontSize: 15,
            fontStyle: "500",
            lineHeight: 24,
            verticalAlign: "middle",
            textBaseline: "bottom"
        },
        tag1: {
            fontFamily: "Arial",
            fontSize: 20,
            fontStyle: "500",
            lineHeight: 24,
            verticalAlign: "middle",
            textBaseline: "bottom"
        },
        footnote1: {
            fontFamily: "Arial",
            fontSize: 22,
            fontStyle: "300",
            lineHeight: 30,
            verticalAlign: "middle",
            textBaseline: "bottom"
        }
    }
};

var customFontFaces = [];

var fontLoader = fonts => {
    var promises = [];
    var _loop = function _loop() {
        var {family: family, src: src, descriptors: descriptors} = fonts[i];
        var fontSrc = src && Array.isArray(src) && src.length ? src.map((url => url.substr(0, 5) === "local" ? url : "url(".concat(url, ")"))).join(",") : "url(" + src + ")";
        var fontFace = new FontFace(family, fontSrc, descriptors || {});
        loggerInstance.info("Loading font", family);
        document.fonts.add(fontFace);
        promises.push(new Promise((resolve => {
            fontFace.load().then((() => {
                customFontFaces.push(fontFace);
                resolve(family);
            })).catch((err => {
                resolve(new Error("".concat(family, ": ").concat(err.message)));
            }));
        })));
    };
    for (var i = 0; i < fonts.length; i++) {
        _loop();
    }
    return Promise.all(promises).then((fontsLoaded => {
        var loaded = fontsLoaded.filter((font => !(font instanceof Error))).join(", ");
        if (loaded) {
            loggerInstance.log("Fonts loaded: ".concat(loaded));
        }
        var failed = fontsLoaded.filter((font => font instanceof Error)).map((item => item.message)).join(", ");
        if (failed) {
            loggerInstance.error("Unable to load fonts: ".concat(failed));
        }
    }));
};

var cleanupFonts = function() {
    var _ref3 = _asyncToGenerator((function*(fonts) {
        if (document.fonts && "delete" in document.fonts) {
            if (!customFontFaces.length) return;
            customFontFaces = customFontFaces.filter((fontFace => {
                if (!fonts.find((font => font.family === fontFace.family))) {
                    loggerInstance.info("Removing font", fontFace.family);
                    document.fonts.delete(fontFace);
                    return false;
                } else {
                    return fontFace;
                }
            }));
        } else {
            loggerInstance.info("Unable to remove manually-added fonts");
        }
    }));
    return function cleanupFonts(_x) {
        return _ref3.apply(this, arguments);
    };
}();

var THEME_KEY_REPLACER = {
    fontFamily: "fontFace"
};

var merge = {
    all: objArray => {
        var result = {};
        for (var i = 0; i < objArray.length; i++) {
            result = clone(result, objArray[i]);
        }
        return result;
    }
};

var base64Cache = [];

var isSubTheme = themeName => "subTheme" === themeName.slice(0, 8);

function getMimeTypeFromDataUri(dataUri) {
    var matches = dataUri.match(/^data:(.*?);base64,/);
    if (matches && matches.length === 2) {
        return matches[1];
    }
    return null;
}

function checkBase64EncodedImage(str) {
    var regex = /^data:image\/(jpeg|jpg|png|gif);base64,/;
    var isImage = regex.test(str);
    var mimeType = isImage ? getMimeTypeFromDataUri(str.match(regex)[0]) : null;
    return {
        isImage: isImage,
        mimeType: mimeType
    };
}

function base64ToBlobURL(base64String, mimeType) {
    var byteCharacters = atob(base64String.substring(base64String.indexOf(",") + 1));
    var byteArrays = [];
    try {
        for (var offset = 0; offset < byteCharacters.length; offset += 512) {
            var slice = byteCharacters.slice(offset, offset + 512);
            var byteNumbers = new Array(slice.length);
            for (var i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }
            var byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }
        var blob = new Blob(byteArrays, {
            type: mimeType
        });
        var blobURL = URL.createObjectURL(blob);
        return blobURL;
    } catch (error) {
        loggerInstance.info("Unable to convert base64 image to URL");
        return null;
    }
}

class ThemeManager {
    constructor() {
        this._cache = new Map;
        if (typeof window === "undefined") return;
        if (!window.LUI) {
            window.LUI = {};
        }
        if (!window.LUI.themeManagerInstances) {
            window.LUI.themeManagerInstances = [ {
                themeManager: this,
                events: events
            } ];
        } else {
            window.LUI.themeManagerInstances.push({
                themeManager: this,
                events: events
            });
        }
    }
    _setCache(key, payload) {
        if (typeof window === "undefined") return;
        window.LUI.themeManagerInstances.forEach((_ref4 => {
            var {themeManager: themeManager} = _ref4;
            if (themeManager) themeManager._cache.set(key, payload);
        }));
    }
    _deleteCache(key) {
        if (typeof window === "undefined") return;
        window.LUI.themeManagerInstances.forEach((_ref5 => {
            var {themeManager: themeManager} = _ref5;
            if (themeManager) themeManager._cache.delete(key);
        }));
    }
    _emit(key, payload) {
        if (typeof window === "undefined") return;
        window.LUI.themeManagerInstances.forEach((_ref6 => {
            var {events: events} = _ref6;
            events.emit(key, payload);
        }));
    }
    getTheme() {
        if (this._cache.has("theme")) {
            return this._cache.get("theme");
        }
        var theme = this._processTheme.call(this);
        this._setCache("theme", theme);
        return theme;
    }
    setTheme(themeConfig) {
        var _this = this;
        return _asyncToGenerator((function*() {
            var value;
            if (Array.isArray(themeConfig)) {
                value = merge.all(themeConfig);
            } else {
                value = themeConfig;
            }
            if ("object" !== typeof value || null === value) {
                loggerInstance.warn("context theme expected an object. Received ".concat(typeof value));
                return;
            }
            _this._clearCache();
            var theme = _this._processTheme.call(_this, [ value ], value.extensions);
            _this._setCache("theme", theme);
            yield cleanupFonts(theme.font);
            if (theme.font && theme.font.length) {
                yield _this._loadFonts(theme.font);
            }
            _this._refreshSubThemes();
            _this._emit("themeExtensionsUpdate");
            _this._emit("themeUpdate");
            return theme;
        }))();
    }
    getSubTheme(subThemeName) {
        if (this._cache.has("subTheme".concat(subThemeName))) {
            return this._cache.get("subTheme".concat(subThemeName)).result;
        }
        return;
    }
    setSubTheme(subThemeName, value) {
        var _arguments = arguments, _this2 = this;
        return _asyncToGenerator((function*() {
            var triggerUpdate = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : true;
            if (!subThemeName) {
                loggerInstance.warn("Sub theme name not specified");
                return;
            }
            if ("string" !== typeof subThemeName) {
                loggerInstance.warn("Sub theme name must be a string. Received an ".concat(typeof subThemeName));
                return;
            }
            if ("object" !== typeof value || !Object.keys(value).length) {
                loggerInstance.warn("Could not set subTheme ".concat(subThemeName, ", value should be an object with properties. Received an ").concat(typeof value));
                return;
            }
            var globalTheme = _this2.getTheme();
            var subTheme = _this2._processTheme.call(_this2, [ globalTheme, value ]);
            if (subTheme.font && subTheme.font.length) {
                yield _this2._loadFonts(subTheme.font);
            }
            _this2._setCache("subTheme".concat(subThemeName), {
                original: value,
                result: subTheme
            });
            if (triggerUpdate) _this2._emit("themeUpdate".concat(subThemeName));
            return subTheme;
        }))();
    }
    _refreshSubThemes() {
        [ ...this._cache.keys() ].forEach((key => {
            if ("string" === typeof key && isSubTheme(key)) {
                var _cache = this._cache.get(key);
                if (_cache.original) this.updateSubTheme(key.replace(/^subTheme/, ""), _cache.original);
            }
        }));
    }
    _loadFonts(fontArray) {
        return _asyncToGenerator((function*() {
            try {
                yield fontLoader(fontArray);
            } catch (err) {
                loggerInstance.error("Unable to load font: ".concat(err));
            }
        }))();
    }
    updateTheme(themeConfig) {
        var _this3 = this;
        return _asyncToGenerator((function*() {
            var value;
            if (Array.isArray(themeConfig)) {
                value = merge.all(themeConfig);
            } else {
                value = themeConfig;
            }
            var currentTheme = {};
            if (_this3._cache.has("theme")) {
                currentTheme = _this3._cache.get("theme");
            }
            _this3._clearCache();
            var theme = _this3._processTheme.call(_this3, [ currentTheme, value ], value.extensions || currentTheme.extensions);
            _this3._setCache("theme", theme);
            if (theme.font && theme.font.length) {
                yield _this3._loadFonts(theme.font);
            }
            _this3._refreshSubThemes();
            if (value.extensions) _this3._emit("themeExtensionsUpdate");
            _this3._emit("themeUpdate");
            return theme;
        }))();
    }
    _clearCache() {
        base64Cache.filter((image => {
            if (window.URL && typeof window.URL.revokeObjectURL === "function") URL.revokeObjectURL(image);
            return false;
        }));
        this._cache.forEach(((value, key) => {
            if ("string" !== typeof key || !isSubTheme(key)) {
                this._deleteCache(key);
            }
        }));
        this._cache.forEach(((value, key) => {
            if ("string" === typeof key && isSubTheme(key)) {
                this.setSubTheme(key.replace("subTheme", ""), value.original, false);
            }
        }));
    }
    updateSubTheme(subThemeName, value) {
        var _arguments2 = arguments, _this4 = this;
        return _asyncToGenerator((function*() {
            var triggerUpdate = _arguments2.length > 2 && _arguments2[2] !== undefined ? _arguments2[2] : true;
            if (!subThemeName) {
                loggerInstance.warn("Sub theme name not specified");
                return;
            }
            if ("object" !== typeof value || !Object.keys(value).length) {
                loggerInstance.warn("Could not update subTheme ".concat(subThemeName, " due to invalid value"));
                return;
            }
            var globalTheme = _this4.getTheme();
            var currentTheme = {};
            if (_this4._cache.has("subTheme".concat(subThemeName))) {
                currentTheme = _this4._cache.get("subTheme".concat(subThemeName)).original;
            }
            var subTheme = _this4._processTheme.call(_this4, [ globalTheme, currentTheme, value ]);
            if (subTheme.font && subTheme.font.length) {
                yield _this4._loadFonts(subTheme.font);
            }
            _this4._setCache("subTheme".concat(subThemeName), {
                original: clone(currentTheme, value),
                result: subTheme
            });
            if (triggerUpdate) _this4._emit("themeUpdate".concat(subThemeName));
            return subTheme;
        }))();
    }
    removeSubTheme(subThemeName) {
        if (this._cache.has("subTheme".concat(subThemeName))) {
            this._deleteCache("subTheme".concat(subThemeName));
        }
        this._emit("themeUpdate".concat(subThemeName));
    }
    _getComponentUUID(id) {
        return "componentStyle".concat(id);
    }
    _processTheme() {
        var themeArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var extensions = arguments.length > 1 ? arguments[1] : undefined;
        if (!Array.isArray(themeArray)) {
            throw new Error("context processTheme expected an array. Received ".concat(typeof themeArray));
        }
        var theme = merge.all([ baseTheme, ...themeArray ]);
        var themeFunctions = {};
        var themeString = JSON.stringify(theme, ((key, originalValue) => {
            var value = originalValue;
            if (value && typeof value === "object") {
                var replacement = originalValue;
                for (var k in value) {
                    if (Object.hasOwnProperty.call(value, k) && THEME_KEY_REPLACER[k]) {
                        replacement[k && THEME_KEY_REPLACER[k]] = value[k];
                        delete replacement[k];
                    }
                }
                value = replacement;
            }
            var {isImage: isImage, mimeType: mimeType} = checkBase64EncodedImage(value);
            if (window.URL && typeof window.URL.createObjectURL === "function" && isImage) {
                try {
                    var blobURL = base64ToBlobURL(value, mimeType);
                    base64Cache.push(blobURL);
                    return blobURL;
                } catch (error) {
                    return value;
                }
            }
            if (Array.isArray(value) && 2 === value.length && !value[0].targetComponent && value[0].length && typeof value[0] === "string" && value[0].substr(0, 1) === "#" && typeof value[1] === "number") {
                return getHexColor(value[0], value[1]);
            } else if ("extensions" === key || "function" === typeof value || "object" === typeof value && value !== null && "Object" !== value.constructor.name && !Array.isArray(value)) {
                themeFunctions[key] = value;
                return;
            } else if ("string" === typeof value && value.includes("theme.")) {
                var themeValue = getValFromObjPath({
                    theme: theme
                }, value);
                if (themeValue) {
                    return themeValue;
                } else {
                    return value;
                }
            } else {
                var validColor = getValidColor(value);
                if (validColor) {
                    return validColor;
                }
                return value;
            }
        }));
        return _objectSpread(_objectSpread(_objectSpread({}, JSON.parse(themeString)), themeFunctions), {}, {
            extensions: extensions
        });
    }
}

var themeManagerInstance = new ThemeManager;

class Context {
    get theme() {
        return themeManagerInstance.getTheme();
    }
    set theme(value) {
        loggerInstance.warn("Context.theme must be set using context.setTheme or context.updateTheme");
    }
    get keyMetricsCallback() {
        return metricsInstance.keyMetricsCallback;
    }
    set keyMetricsCallback(value) {
        loggerInstance.warn("Context.keyMetricsCallback must be set using context.setKeyMetricsCallback");
    }
    get debug() {
        return loggerInstance.debug;
    }
    set debug(value) {
        loggerInstance.debug = value;
    }
    on() {
        return events.on(...arguments);
    }
    off() {
        return events.off(...arguments);
    }
    emit() {
        return events.emit(...arguments);
    }
    log() {
        loggerInstance.log(...arguments);
    }
    info() {
        loggerInstance.info(...arguments);
    }
    warn() {
        loggerInstance.warn(...arguments);
    }
    error() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
        }
        loggerInstance.error(args);
    }
    setTheme(value) {
        return themeManagerInstance.setTheme(value);
    }
    updateTheme(value) {
        return themeManagerInstance.updateTheme(value);
    }
    getSubTheme(subThemeName) {
        return themeManagerInstance.getSubTheme(subThemeName);
    }
    setSubThemes(subThemesObj) {
        if ("object" !== typeof subThemesObj) {
            loggerInstance.warn("subThemes must be an object");
            return;
        }
        for (var subTheme in subThemesObj) {
            themeManagerInstance.setSubTheme(subTheme, subThemesObj[subTheme]);
        }
    }
    setSubTheme(subThemeName, value) {
        return themeManagerInstance.setSubTheme(subThemeName, value);
    }
    updateSubTheme(subThemeName, value) {
        return themeManagerInstance.updateSubTheme(subThemeName, value);
    }
    removeSubTheme(subThemeName) {
        themeManagerInstance.removeSubTheme(subThemeName);
    }
    setLogCallback(value) {
        loggerInstance.logCallback = value;
    }
    setKeyMetricsCallback(value) {
        metricsInstance.keyMetricsCallback = value;
    }
    config() {
        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var configKeys = Object.keys(config);
        for (var i = 0; i < configKeys.length; i++) {
            var setMethod = this["set" + capitalizeFirstLetter(configKeys[i])];
            if (setMethod) {
                setMethod(config[configKeys[i]]);
            }
        }
        return this;
    }
}

var contextInstance = new Context;

class GlobalUpdateManager {
    constructor() {
        this._updateThemeSet = new Set;
        this._requestUpdateSet = new Set;
        this._timeout = null;
        this._runUpdatesTimeoutHandler = this._runUpdatesTimeoutHandler.bind(this);
    }
    _runUpdatesTimeoutHandler() {
        this._timeout = null;
        this._updateThemeSet.forEach((component => {
            try {
                component._updateThemeComponent();
            } catch (e) {
                contextInstance.error("Error updating component themes", e);
            }
        }));
        this._updateThemeSet.clear();
        this._requestUpdateSet.forEach((component => {
            try {
                component.requestUpdate();
            } catch (e) {
                contextInstance.error("Error updating component", e);
            }
        }));
        this._requestUpdateSet.clear();
    }
    flush() {
        if (!this._timeout) return;
        clearTimeout(this._timeout);
        this._runUpdatesTimeoutHandler();
    }
    addUpdateTheme(component) {
        this._updateThemeSet.add(component);
        if (!this._timeout) {
            this._timeout = setTimeout(this._runUpdatesTimeoutHandler, 0);
        }
    }
    deleteUpdateTheme(component) {
        this._updateThemeSet.delete(component);
    }
    addRequestUpdate(component) {
        this._requestUpdateSet.add(component);
        if (!this._timeout) {
            this._timeout = setTimeout(this._runUpdatesTimeoutHandler, 0);
        }
    }
    deleteRequestUpdate(component) {
        this._requestUpdateSet.delete(component);
    }
    hasQueuedRequestFor(component) {
        return this._requestUpdateSet.has(component);
    }
}

var updateManager = new GlobalUpdateManager;

function capital(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function mergeProps(componentConfigProp, prop) {
    var _result;
    var result = prop;
    if (typeof componentConfigProp === "object" && Object.keys(componentConfigProp).length && typeof prop === "object") {
        result = clone(componentConfigProp, prop);
    }
    return (_result = result) !== null && _result !== void 0 ? _result : componentConfigProp;
}

function getPropertyDescriptor$1(name, key) {
    return {
        get() {
            var _this$__componentConf3;
            var customGetter = this["_get".concat(capital(name))];
            if (customGetter && typeof customGetter === "function") {
                var _this$__componentConf, _this$__componentConf2;
                var value = customGetter.call(this, this[key]);
                this[key] = value || ((_this$__componentConf = this.__componentConfigProps) === null || _this$__componentConf === void 0 ? void 0 : _this$__componentConf[name]);
                return mergeProps((_this$__componentConf2 = this.__componentConfigProps) === null || _this$__componentConf2 === void 0 ? void 0 : _this$__componentConf2[name], value);
            }
            return mergeProps((_this$__componentConf3 = this.__componentConfigProps) === null || _this$__componentConf3 === void 0 ? void 0 : _this$__componentConf3[name], this[key]);
        },
        set(value) {
            var oldValue = this[key];
            if (value !== oldValue) {
                var changeHandler = this["_set".concat(capital(name))];
                if (changeHandler && typeof changeHandler === "function") {
                    value = changeHandler.call(this, value);
                }
                var newValue = key === "style" ? clone(this[key], value) : value;
                if (typeof this[key] === "object" && this[key] !== null && this[key].style) {
                    var style = clone(this[key].style, value.style || {});
                    newValue.style = style;
                }
                this[key] = newValue;
                this.queueRequestUpdate();
            }
        },
        configurable: true,
        enumerable: true
    };
}

function getAliasPropertyDescriptor(prev, curr) {
    var deprecationWarning = 'The property "'.concat(prev, '" is deprecated and will be removed in a future release. Please use "').concat(curr, '" instead.');
    return {
        get() {
            console.warn(deprecationWarning);
            return this[curr];
        },
        set(value) {
            console.warn(deprecationWarning);
            this[curr] = value;
        }
    };
}

function withUpdates(Base) {
    return class extends Base {
        static get name() {
            return Base.name;
        }
        _construct() {
            var prototype = Object.getPrototypeOf(this);
            if (!prototype._withUpdatesInitialized) {
                var props = this.constructor.properties || [];
                props.forEach((name => {
                    var key = "_" + name;
                    var descriptor = getPropertyDescriptor$1(name, key);
                    if (descriptor !== undefined) {
                        Object.defineProperty(prototype, name, descriptor);
                    }
                }));
                var aliasProps = this.constructor.aliasProperties || [];
                aliasProps.forEach((alias => {
                    if (alias && typeof alias.prev === "string" && typeof alias.curr === "string") {
                        var descriptor = getAliasPropertyDescriptor(alias.prev, alias.curr);
                        if (descriptor !== undefined) {
                            Object.defineProperty(prototype, alias.prev, descriptor);
                        }
                    }
                }));
                prototype._withUpdatesInitialized = true;
            }
            this._whenEnabled = new Promise((resolve => {
                this._whenEnabledResolver = resolve;
            }));
            super._construct && super._construct();
        }
        queueRequestUpdate() {
            if (!this._isAttached()) return;
            updateManager.addRequestUpdate(this);
        }
        _firstEnable() {
            this._readyForUpdates = true;
            this._whenEnabledResolver();
            updateManager.deleteRequestUpdate(this);
            this.requestUpdate();
            super._firstEnable && super._firstEnable();
        }
        requestEarlyUpdate() {
            this._readyForUpdates = true;
            if (updateManager.hasQueuedRequestFor(this)) {
                updateManager.deleteRequestUpdate(this);
                this._readyForUpdates = true;
                this.requestUpdate();
                return true;
            }
            return false;
        }
        _detach() {
            super._detach();
            updateManager.deleteRequestUpdate(this);
        }
        requestUpdate() {
            var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
            if (this._readyForUpdates || force) {
                var result = this._update();
                if (typeof result === "object" && result !== null && result.catch) {
                    result.catch((e => {
                        contextInstance.error("asyncronous _update() error in '".concat(this.constructor.__componentName, "'"), this, e);
                    }));
                }
            }
        }
        logPropTable() {
            console.table(this._propTable);
        }
        get _propTable() {
            return this.constructor.properties.reduce(((acc, prop) => {
                acc[prop] = this[prop];
                return acc;
            }), {});
        }
    };
}

function getPropertyDescriptor(path) {
    return {
        get() {
            return this.tag(path);
        },
        configurable: true,
        enumerable: true
    };
}

function withTags(Base) {
    return class extends Base {
        static get name() {
            return Base.name;
        }
        _construct() {
            var prototype = Object.getPrototypeOf(this);
            if (!prototype._withTagsInitialized) {
                var tags = this.constructor.tags || [];
                tags.forEach((tag => {
                    if (typeof tag === "object") {
                        var {name: name, path: path} = tag;
                    } else {
                        var name = tag;
                        var path = tag;
                    }
                    var key = "_" + name;
                    var descriptor = getPropertyDescriptor(path);
                    Object.defineProperty(prototype, key, descriptor);
                }));
                prototype._withTagsInitialized = true;
            }
            super._construct && super._construct();
        }
    };
}

function withHandleKey(Base) {
    return class extends Base {
        static get name() {
            return Base.name;
        }
        _handleKey(keyEvent) {
            return this._processEvent(keyEvent);
        }
        _handleKeyRelease(keyEvent) {
            return this._processEvent(keyEvent, "Release");
        }
        _processEvent(keyEvent) {
            var suffix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
            var keyMap = this.stage.application.__keymap || {};
            var key = keyMap[keyEvent.keyCode];
            if (!key) {
                key = keyEvent.key;
            }
            if (key && typeof this["on".concat(key).concat(suffix)] === "function") {
                this._invokeKeyPayloadCallback(key + suffix);
                return this["on".concat(key).concat(suffix)].call(this, this, keyEvent);
            }
            return false;
        }
        _invokeKeyPayloadCallback(key) {
            if (this.metricsPayload && typeof contextInstance.keyMetricsCallback === "function") {
                contextInstance.keyMetricsCallback(key, this.metricsPayload);
            }
        }
    };
}

function withLayout(Base) {
    return class extends Base {
        _construct() {
            super._construct && super._construct();
            this._previousDimensionData = null;
        }
        get itemLayout() {
            return this._itemLayout;
        }
        set itemLayout(v) {
            var componentName = this.constructor._componentName || this.constructor.name;
            var itemLayout;
            if (v) {
                itemLayout = JSON.parse(JSON.stringify(v, ((k, v) => {
                    if (k !== "circle" && v < 0) {
                        contextInstance.error("itemLayout for ".concat(componentName, " received an invalid value of ").concat(v, " for ").concat(k));
                        return;
                    } else if (k === "circle") {
                        return Boolean(v);
                    }
                    return v;
                })));
            }
            if (!stringifyCompare(this._itemLayout, itemLayout)) {
                if (itemLayout && !itemLayout.upCount) {
                    this._originalW = this.w;
                    this._originalH = this.h;
                    this._itemLayout = _objectSpread({
                        w: this._originalW,
                        h: this._originalH
                    }, itemLayout);
                } else {
                    this._itemLayout = itemLayout;
                }
                this._updateItemLayout();
            }
        }
        _allowUpdate() {
            var {w: w = "", h: h = "", circle: circle = "", ratioX: ratioX = "", ratioY: ratioY = "", upCount: upCount = ""} = this._itemLayout || {};
            var layoutString = Object.values(contextInstance.theme.layout).join("") + "".concat(w).concat(h).concat(circle ? 1 : 0).concat(ratioX).concat(ratioY).concat(upCount);
            if (layoutString !== this._previousDimensionData) {
                this._previousDimensionData = layoutString;
                return true;
            }
            return false;
        }
        _updateItemLayout() {
            if (!this._allowUpdate()) return;
            var {w: w, h: h} = getDimensions(this.theme, this._itemLayout);
            if (h || w) {
                var width = contextInstance.theme.layout.screenW;
                var height = contextInstance.theme.layout.screenH;
                var calculatedWidth = w || h * (width / height);
                var calculatedHeight = h || w * (height / width);
                this.w = this._itemLayout && this._itemLayout.circle ? calculatedHeight : calculatedWidth;
                this.h = calculatedHeight;
                if (this._itemLayout && this._itemLayout.circle && this.style.radius) {
                    this._circleSet = true;
                    this._originalRadius = this.style.radius;
                    this.style = _objectSpread(_objectSpread({}, this.style), {}, {
                        radius: calculatedHeight / 2
                    });
                } else if (this._circleSet) {
                    this.style = _objectSpread(_objectSpread({}, this.style), {}, {
                        radius: this._originalRadius
                    });
                    this._originalRadius = undefined;
                    this._circleSet = false;
                }
                this.queueRequestUpdate && this.queueRequestUpdate();
                this.fireAncestors("$itemChanged");
            }
        }
    };
}

var getCharacterValue = (char, index) => char.charCodeAt(0) * (index + 1);

var sortObject = obj => {
    var sortedObj = {};
    Object.keys(obj).sort().forEach((key => {
        if (typeof obj[key] === "object" && obj[key] !== null && !Array.isArray(obj[key])) {
            sortedObj[key] = sortObject(obj[key]);
        } else {
            sortedObj[key] = obj[key];
        }
    }));
    return sortedObj;
};

var getCharacterSum = obj => {
    var sortedObj = sortObject(obj);
    var str = JSON.stringify(sortedObj).replace(/[{}:",\s]/g, "");
    var sum = 0;
    for (var i = 0; i < str.length; i++) {
        sum += getCharacterValue(str[i], i);
    }
    return sum;
};

var getHash = obj => {
    var str = JSON.stringify(obj);
    return str.length + "-" + getCharacterSum(obj);
};

function executeWithContextRecursive(objOrFunction, theme) {
    if (typeof objOrFunction === "function") {
        var result = objOrFunction(theme);
        return executeWithContextRecursive(result, theme);
    } else if (Array.isArray(objOrFunction)) {
        return objOrFunction.map((item => executeWithContextRecursive(item, theme)));
    } else if (typeof objOrFunction === "object" && objOrFunction !== null) {
        var _result2 = {};
        for (var key in objOrFunction) {
            if (objOrFunction.hasOwnProperty(key)) {
                _result2[key] = executeWithContextRecursive(objOrFunction[key], theme);
            }
        }
        return _result2;
    } else {
        return objOrFunction;
    }
}

function isPlainObject(value) {
    return typeof value === "object" && value !== null && !Array.isArray(value) && !(value instanceof Date) && !(value instanceof RegExp) && !(value instanceof Function) && !(value instanceof Error);
}

var getSubTheme = obj => {
    while (obj && (!obj.subTheme || typeof obj.subTheme !== "string")) {
        obj = obj.p;
    }
    return obj ? obj.subTheme : undefined;
};

var getComponentConfig = obj => {
    var _obj$theme;
    if (!isPlainObject(obj)) return {};
    return (obj === null || obj === void 0 || (_obj$theme = obj.theme) === null || _obj$theme === void 0 || (_obj$theme = _obj$theme.componentConfig) === null || _obj$theme === void 0 ? void 0 : _obj$theme[obj.constructor.__componentName]) || {};
};

function removeEmptyObjects(obj) {
    for (var key in obj) {
        if (obj.hasOwnProperty(key) && isPlainObject(obj[key])) {
            removeEmptyObjects(obj[key]);
            if (Object.keys(obj[key]).length === 0) {
                delete obj[key];
            }
        }
    }
    return obj;
}

function createSharedReferences() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var seenObjects = new Map;
    function hash(object) {
        return JSON.stringify(object, Object.keys(object).sort());
    }
    function process(currentObj) {
        for (var key in currentObj) {
            if (currentObj.hasOwnProperty(key)) {
                var value = currentObj[key];
                if (typeof value === "object" && value !== null) {
                    var valueHash = hash(value);
                    if (seenObjects.has(valueHash)) {
                        currentObj[key] = seenObjects.get(valueHash);
                    } else {
                        seenObjects.set(valueHash, value);
                        process(value);
                    }
                }
            }
        }
    }
    process(obj);
    return obj;
}

function getUniqueProperties() {
    var defaultProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    if (!Array.isArray(defaultProps)) {
        throw new TypeError("Expected defaultProps to be an array of strings.");
    }
    return [ ...new Set(defaultProps) ];
}

function generatePayload(base, defaultStyle, toneItem, modeItem, tone, mode) {
    var _tone$toneItem, _mode$modeItem;
    var payload = clone(defaultStyle, base);
    payload = clone(payload, tone === null || tone === void 0 ? void 0 : tone[toneItem]);
    payload = clone(payload, mode === null || mode === void 0 ? void 0 : mode[modeItem]);
    payload = clone(payload, (tone === null || tone === void 0 || (_tone$toneItem = tone[toneItem]) === null || _tone$toneItem === void 0 || (_tone$toneItem = _tone$toneItem.mode) === null || _tone$toneItem === void 0 ? void 0 : _tone$toneItem[modeItem]) || {});
    payload = clone(payload, (mode === null || mode === void 0 || (_mode$modeItem = mode[modeItem]) === null || _mode$modeItem === void 0 || (_mode$modeItem = _mode$modeItem.tone) === null || _mode$modeItem === void 0 ? void 0 : _mode$modeItem[toneItem]) || {});
    return payload;
}

function findNestedKeys(obj, keyToFind) {
    var nestedKeys = [];
    function searchNestedKeys(obj) {
        if (typeof obj === "object" && obj !== null) {
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    nestedKeys.push(key);
                }
            }
        }
    }
    function searchForKey(obj) {
        if (typeof obj === "object" && obj !== null) {
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    if (key === keyToFind) {
                        searchNestedKeys(obj[key]);
                        break;
                    }
                    searchForKey(obj[key]);
                }
            }
        }
    }
    searchForKey(obj);
    return nestedKeys;
}

var generateSolution = function generateSolution(_ref7) {
    var {base: base = {}, tone: tone = {}, mode: mode = {}, defaultStyle: defaultStyle = {}} = _ref7;
    var modeKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var toneKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var solution = {};
    var uniqueModes = getUniqueProperties([ "focused", "disabled", ...modeKeys, "unfocused" ]);
    var uniqueTones = getUniqueProperties([ "neutral", "inverse", "brand", ...toneKeys ]);
    for (var modeItem of uniqueModes) {
        for (var toneItem of uniqueTones) {
            var payload = generatePayload(base, defaultStyle, toneItem, modeItem, tone, mode);
            solution["".concat(modeItem, "_").concat(toneItem)] = payload;
        }
    }
    return solution;
};

var DEFAULT_KEYS = [ "unfocused_neutral", "unfocused_inverse", "unfocused_brand", "focused_neutral", "focused_inverse", "focused_brand", "disabled_neutral", "disabled_inverse", "disabled_brand" ];

function enforceContract(inputObj) {
    var result = {};
    for (var key of [ ...DEFAULT_KEYS, ...Object.keys(inputObj) ]) {
        if (!inputObj.hasOwnProperty(key)) {
            var fallbackKey = DEFAULT_KEYS.find((fallback => inputObj.hasOwnProperty(fallback)));
            if (fallbackKey) {
                var fallback = inputObj[fallbackKey];
                result[key] = typeof fallback !== "object" ? {} : fallback;
            } else {
                result[key] = {};
            }
        } else {
            if (typeof inputObj[key] !== "object") {
                result[key] = {};
            } else {
                result[key] = inputObj[key];
            }
        }
    }
    return result;
}

var generateComponentStyleSource = function generateComponentStyleSource() {
    var {theme: theme = {}, styleChain: styleChain = [], inlineStyle: inlineStyle = {}, alias: alias = []} = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (typeof theme !== "object") {
        throw new Error("Expected theme to be an object");
    }
    if (!Array.isArray(styleChain)) {
        throw new Error("Expected styleChain to be an array");
    }
    if (typeof inlineStyle !== "object") {
        throw new Error("Expected inlineStyle to be an object");
    }
    if (!Array.isArray(alias)) {
        throw new Error("Expected alias to be an array");
    }
    var componentDefault = styleChain.map((_ref8 => {
        var {style: style} = _ref8;
        if (typeof style === "object" && !style.base && !style.mode && !style.tone && !style.default) {
            return {
                base: style
            };
        } else {
            var {base: _base = {}, mode: _mode = {}, tone: _tone = {}} = style;
            var componentConfigDefaultStyle;
            if (style) {
                var defaultStyle = JSON.parse(JSON.stringify(style));
                delete defaultStyle.base;
                delete defaultStyle.tone;
                delete defaultStyle.mode;
                componentConfigDefaultStyle = defaultStyle;
            }
            return {
                defaultStyle: componentConfigDefaultStyle || {},
                base: _base,
                mode: _mode,
                tone: _tone
            };
        }
    }));
    var localDefaultStyle;
    if (inlineStyle) {
        var defaultStyle = JSON.parse(JSON.stringify(inlineStyle));
        delete defaultStyle.base;
        delete defaultStyle.tone;
        delete defaultStyle.mode;
        localDefaultStyle = defaultStyle;
    }
    var local = {
        defaultStyle: localDefaultStyle || {},
        base: (inlineStyle === null || inlineStyle === void 0 ? void 0 : inlineStyle.base) || {},
        mode: (inlineStyle === null || inlineStyle === void 0 ? void 0 : inlineStyle.mode) || {},
        tone: (inlineStyle === null || inlineStyle === void 0 ? void 0 : inlineStyle.tone) || {}
    };
    var merged = [ ...componentDefault, local ];
    var parsedStyles = merged.map((style => executeWithContextRecursive(style, theme)));
    var modeKeys = findNestedKeys(parsedStyles, "mode");
    var toneKeys = findNestedKeys(parsedStyles, "tone");
    var solution = parsedStyles.reduce(((acc, style) => clone(acc, generateSolution(style, modeKeys, toneKeys))), {});
    var final = formatStyleObj(removeEmptyObjects(colorParser({
        theme: theme
    }, solution)) || {}, alias);
    var cleanObj = createSharedReferences(final);
    return enforceContract(cleanObj);
};

var colorParser = (targetObject, styleObj) => {
    if (typeof targetObject !== "object" || targetObject === null) {
        throw new TypeError("targetObject must be an object.");
    }
    if (typeof styleObj !== "object" || styleObj === null) {
        throw new TypeError("styleObj must be an object.");
    }
    var processedStyle = JSON.stringify(styleObj, ((_, value) => {
        if (-1 < [ "tone", "mode" ].indexOf(_)) return value;
        if (typeof value === "string" && value.startsWith("theme.")) {
            return getValFromObjPath(targetObject, value);
        }
        function isValidColor(num) {
            return num >= 0 && num <= 4294967295;
        }
        if (Array.isArray(value) && value.length === 2 && (typeof value[0] === "string" && value[0].startsWith("#") || typeof value[0] === "number" && isValidColor(value[0])) && typeof value[1] === "number") {
            return getHexColor(value[0], value[1]) || value;
        }
        return value;
    }));
    return JSON.parse(processedStyle || {});
};

var generateStyle = function generateStyle(component) {
    var componentStyleSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!isPlainObject(component)) return {};
    var {mode: mode = "unfocused", tone: tone = "neutral"} = component;
    return componentStyleSource["".concat(mode, "_").concat(tone)] || componentStyleSource["unfocused_neutral"] || {};
};

function generateNameFromPrototypeChain(obj) {
    var _proto$constructor;
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    if (!obj) return name;
    var proto = Object.getPrototypeOf(obj);
    if (!proto || !proto.constructor) return name;
    var componentName = "".concat(name ? name + "." : "").concat((proto === null || proto === void 0 || (_proto$constructor = proto.constructor) === null || _proto$constructor === void 0 ? void 0 : _proto$constructor.__componentName) || "").replace(/\.*$/, "").trim();
    var result = generateNameFromPrototypeChain(proto, componentName);
    return result;
}

var styleChainCache = {};

var clearStyleChainCache = () => {
    for (var key in styleChainCache) {
        if (styleChainCache.hasOwnProperty(key)) {
            delete styleChainCache[key];
        }
    }
};

var getStyleChainMemoized = componentObj => {
    var cacheKey = generateNameFromPrototypeChain(componentObj);
    if (styleChainCache[cacheKey]) {
        return styleChainCache[cacheKey];
    }
    var styleChain = getStyleChain(componentObj);
    styleChainCache[cacheKey] = styleChain;
    return styleChain;
};

var getStyleChain = componentObj => {
    var styleMap = new Map;
    var proto;
    do {
        var _proto;
        proto = !proto ? componentObj : Object.getPrototypeOf(proto);
        if (((_proto = proto) === null || _proto === void 0 ? void 0 : _proto.constructor) === Object) break;
        if (proto && typeof proto === "object" && proto.hasOwnProperty("constructor")) {
            var {style: componentConfigStyle} = getComponentConfig(proto);
            if (Object.keys(componentConfigStyle || {}).length) {
                if (!styleMap.has(componentConfigStyle)) {
                    styleMap.set(componentConfigStyle, {
                        style: componentConfigStyle
                    });
                }
            }
            var themeStyle = proto.constructor.hasOwnProperty("__themeStyle") && proto.constructor.__themeStyle;
            if (Object.keys(themeStyle || {}).length) {
                if (!styleMap.has(themeStyle)) {
                    styleMap.set(themeStyle, {
                        style: _objectSpread({}, themeStyle)
                    });
                }
            } else if (typeof themeStyle === "function") {
                if (!styleMap.has(themeStyle)) {
                    styleMap.set(themeStyle, {
                        style: themeStyle
                    });
                }
            }
            var mixinStyle = proto.constructor.hasOwnProperty("__mixinStyle") && proto.constructor.__mixinStyle;
            if (Object.keys(mixinStyle || {}).length) {
                if (!styleMap.has(mixinStyle)) {
                    styleMap.set(mixinStyle, {
                        style: mixinStyle
                    });
                }
            }
        }
    } while (proto);
    var uniqueStyles = Array.from(styleMap.values());
    return uniqueStyles.map((style => style)).reverse();
};

var formatStyleObj = function formatStyleObj(originalObj) {
    var aliasStyles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    if (typeof originalObj !== "object" || originalObj === null) {
        throw new Error("The originalObj parameter must be an object.");
    }
    var formatters = new Set;
    formatters.add([ replaceAliasValues, [ aliasStyles ] ]);
    var formattersArray = Array.from(formatters);
    return formattersArray.reduce(((obj, _ref9) => {
        var [func, args] = _ref9;
        return func(obj, ...args);
    }), originalObj);
};

var replaceAliasValues = function replaceAliasValues(value) {
    var aliasStyles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    if (typeof value !== "object" || value === null) {
        throw new Error("Value must be an object");
    }
    if (!Array.isArray(aliasStyles)) {
        throw new Error("Alias styles must be an array");
    }
    var str = JSON.stringify(value);
    var aliasProps = [ {
        prev: "height",
        curr: "h",
        skipWarn: true
    }, {
        prev: "width",
        curr: "w",
        skipWarn: true
    }, ...aliasStyles || [] ];
    aliasProps.forEach((alias => {
        if (alias && typeof alias.prev === "string" && typeof alias.curr === "string") {
            !alias.skipWarn && str.search('"'.concat(alias.prev, '":')) >= 0 && loggerInstance.warn('The style property "'.concat(alias.prev, '" is deprecated and will be removed in a future release. Please use "').concat(alias.curr, '" instead.'));
            str = str.replace(new RegExp('"'.concat(alias.prev, '":'), "gi"), '"'.concat(alias.curr, '":'));
        }
    }));
    return JSON.parse(str);
};

var themeStyleCache = new Map;

contextInstance.on("themeUpdate", (() => {
    themeStyleCache.clear();
}));

var cache = themeStyleCache;

class StyleManager extends lng.EventEmitter {
    constructor() {
        var {component: component = {}} = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        super(...arguments);
        this.init(component);
    }
    init(component) {
        this.isActive = true;
        this.component = component;
        this.setupListeners();
        this._style = {};
        this.update();
    }
    setupListeners() {
        this._boundThemeUpdate = this._onThemeUpdate.bind(this);
        this._hasSubTheme = Boolean(this.component._targetSubTheme);
        if (!this.component._targetSubTheme) {
            contextInstance.on("themeUpdate", this._boundThemeUpdate);
        } else {
            contextInstance.on("themeUpdate".concat(this.component._targetSubTheme), this._boundThemeUpdate);
        }
    }
    clearListeners() {
        if (!this._boundThemeUpdate) return;
        if (!this.component._targetSubTheme) {
            contextInstance.off("themeUpdate", this._boundThemeUpdate);
        } else {
            contextInstance.off("themeUpdate".concat(this.component._targetSubTheme), this._boundThemeUpdate);
        }
    }
    destroy() {
        this.isActive = false;
        this._cleanupCache();
        this.clearListeners();
        this._styleCache = null;
        this._boundThemeUpdate = null;
        this.component = null;
    }
    _onThemeUpdate() {
        clearStyleChainCache();
        this.clearSourceCache();
        this.clearStyleCache();
        this.update();
    }
    clearStyleChainCache() {
        clearStyleChainCache();
    }
    clearSourceCache() {
        if (!this.component) return;
        var sourceKey = this._generateCacheKey("styleSource");
        this._removeCache(sourceKey);
    }
    clearStyleCache() {
        if (!this.component) return;
        var {tone: tone, mode: mode} = this.component;
        var styleKey = this._generateCacheKey("style_".concat(mode, "_").concat(tone));
        cache.delete(styleKey);
    }
    _generateCacheKey(name) {
        var cacheKey = [ name, this.component._targetSubTheme, this.component.constructor.__componentName, this._customStyleHash ].filter(Boolean).join("_");
        return cacheKey;
    }
    _addCache(name, payload) {
        var key = this._generateCacheKey(name);
        var existing = cache.get(key);
        cache.set(key, {
            ids: [ ...new Set([ ...(existing === null || existing === void 0 ? void 0 : existing.ids) || [], this.component.__id ]) ],
            payload: payload
        });
    }
    _cleanupCache() {
        if (!this.component) return;
        cache.forEach(((_ref10, name) => {
            var {ids: ids, payload: payload} = _ref10;
            var removeIndex = ids && ids.length && ids.indexOf(this.component.__id);
            if (removeIndex > -1 && ids.length > 1) {
                cache.set(name, {
                    ids: ids.slice(0, removeIndex).concat(ids.slice(removeIndex + 1)),
                    payload: payload
                });
            } else if (removeIndex > -1) {
                cache.delete(name);
            }
        }));
    }
    _removeCache(name) {
        cache.delete(name);
    }
    _getCache(name) {
        var key = this._generateCacheKey(name);
        return cache.get(key);
    }
    update() {
        if (!this.component) return;
        var {mode: mode, tone: tone} = this.component;
        try {
            var _this$_getCache, _this$_getCache2;
            var styleSource = (_this$_getCache = this._getCache("styleSource")) === null || _this$_getCache === void 0 ? void 0 : _this$_getCache.payload;
            if (!styleSource) {
                styleSource = generateComponentStyleSource({
                    alias: this.component.constructor.aliasStyles,
                    inlineStyle: this.component._componentLevelStyle,
                    styleChain: getStyleChainMemoized(this.component),
                    theme: this.component.theme
                });
                this._addCache("styleSource", styleSource);
            }
            var style = (_this$_getCache2 = this._getCache("style_".concat(mode, "_").concat(tone))) === null || _this$_getCache2 === void 0 ? void 0 : _this$_getCache2.payload;
            if (!style) {
                style = generateStyle(this.component, styleSource);
                this._addCache("style_".concat(mode, "_").concat(tone), style);
            }
            this._style = style;
            this.emit("styleUpdate", this.style);
        } catch (error) {
            contextInstance.error("styleManager: ", error.message);
        }
    }
    set style(v) {
        contextInstance.warn("styleManager: Cannot mutate style directly");
    }
    get style() {
        return this._style;
    }
    set props(v) {
        contextInstance.warn("styleManager: Cannot mutate props directly");
    }
    get props() {
        return Object.keys(this.component._componentConfig).reduce(((acc, key) => {
            if (![ "base", "tone", "mode", "style", "styleConfig" ].includes(key)) {
                acc[key] = this.component._componentConfig[key];
            }
            return acc;
        }), {});
    }
    get _customStyleHash() {
        var hasCustomStyle = Boolean(Object.keys(this.component.constructor.__mixinStyle || {}).length) || Boolean(Object.keys(this.component._componentLevelStyle || {}).length);
        if (hasCustomStyle) {
            return getHash(clone(this.component.constructor.__mixinStyle || {}, this.component._componentLevelStyle || {}));
        }
        return undefined;
    }
}

function mergeObjectsWithSecondDominant(firstObj, secondObj) {
    if (firstObj !== null && typeof firstObj === "object") {
        if (Array.isArray(firstObj)) {
            return firstObj.map(((item, index) => mergeObjectsWithSecondDominant(item, Array.isArray(secondObj) ? secondObj[index] : undefined)));
        } else {
            var result = {};
            var allKeys = new Set([ ...Object.keys(firstObj), ...Object.keys(secondObj) ]);
            allKeys.forEach((key => {
                if (typeof firstObj[key] === "object" && firstObj[key] !== null) {
                    result[key] = mergeObjectsWithSecondDominant(firstObj[key], secondObj[key] || {});
                } else if (typeof secondObj[key] === "object" && secondObj[key] !== null) {
                    result[key] = mergeObjectsWithSecondDominant(firstObj[key] || {}, secondObj[key]);
                } else {
                    result[key] = secondObj.hasOwnProperty(key) ? secondObj[key] : undefined;
                }
            }));
            return result;
        }
    } else {
        return firstObj;
    }
}

function withThemeStyles(Base) {
    var mixinStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return class extends Base {
        _construct() {
            if (this._withThemeStylesSetupComplete) {
                super._construct();
                return;
            }
            this._hSetByUser = false;
            this._wSetByUser = false;
            this._styleManager = new StyleManager({
                component: this
            });
            this._style = this._styleManager.style;
            this._updatePropDefaults();
            this._styleManager.on("styleUpdate", (() => {
                this._style = this._styleManager.style;
                this._updatePropDefaults();
                this.queueThemeUpdate();
            }));
            this._withThemeStylesSetupComplete = true;
            super._construct();
        }
        _setup() {
            super._setup && super._setup();
            this._targetSubTheme = getSubTheme(this);
            if (this._targetSubTheme) {
                this._styleManager.clearListeners();
                this._styleManager.setupListeners();
                this._styleManager.clearStyleChainCache();
                this._styleManager.clearStyleCache();
                this._styleManager.clearSourceCache();
                this._styleManager.update();
            }
        }
        _updatePropDefaults() {
            if (!Object.keys(this._styleManager.props).length || JSON.stringify(this._styleManager.props) === JSON.stringify(this._prevComponentConfigProps)) {
                return;
            }
            var payload = this._prevComponentConfigProps ? mergeObjectsWithSecondDominant(this._prevComponentConfigProps || {}, this._styleManager.props || {}) : this._styleManager.props || {};
            this._prevComponentConfigProps = this._styleManager.props && JSON.parse(JSON.stringify(this._styleManager.props));
            this.__componentConfigProps = payload;
        }
        _attach() {
            super._attach();
            if (!this._styleManager.isActive) {
                this._styleManager.init(this);
            }
        }
        _detach() {
            super._detach();
            this._styleManager.destroy();
        }
        _unfocus() {
            if (this._isFocusedMode) this.mode = "unfocused";
            super._unfocus();
        }
        _focus() {
            if (!this._isDisabledMode) this.mode = "focused";
            super._focus();
        }
        _checkDimensionUpdates() {
            var dimensionUpdateRequired = false;
            if (!this._wSetByUser && this.style.w && this._w !== this.style.w) {
                this._w = this.style.w;
                dimensionUpdateRequired = true;
            }
            if (!this._hSetByUser && this.style.h && this._h !== this.style.h) {
                this._h = this.style.h;
                dimensionUpdateRequired = true;
            }
            if (dimensionUpdateRequired) {
                this._updateDimensions();
            }
        }
        _updateThemeComponent() {
            if (!this.style) return;
            if (!this._isAttached()) return;
            this._checkDimensionUpdates();
            this.queueRequestUpdate ? this.queueRequestUpdate() : this._update && this._update();
            this._updateItemLayout && this._updateItemLayout();
        }
        queueThemeUpdate() {
            updateManager.addUpdateTheme(this);
        }
        static get name() {
            return Base.name;
        }
        static get __componentName() {
            if (!super.__componentName) {
                throw new Error("A valid static __componentName property is required for theming to work properly. Please add this to the ".concat(this.constructor.name, " class."));
            }
            return super.__componentName;
        }
        static get __mixinStyle() {
            return mixinStyle;
        }
        get theme() {
            var subTheme = this._targetSubTheme && contextInstance.getSubTheme(this._targetSubTheme);
            return subTheme || contextInstance.theme;
        }
        set style(v) {
            if (Object.prototype.toString.call(v) !== "[object Object]") {
                contextInstance.error("style must be an object");
                return;
            }
            this._componentLevelStyle = v;
            this._styleManager.clearStyleCache();
            this._styleManager.update();
        }
        get style() {
            return this._style;
        }
        get _componentStyle() {
            contextInstance.info("_componentStyle will soon be deprecated. Please use Component.style");
            return this._style;
        }
        set styleConfig(v) {
            contextInstance.info("style config is deprecated. Please use style = { base: {}, tone: {}, mode: {} }");
            this._styleConfig = v;
            this._styleManager.update();
        }
        get styleConfig() {
            return this._styleConfig;
        }
        get _componentConfig() {
            return getComponentConfig(this);
        }
        get mode() {
            var _this$_componentConfi;
            return this._mode || ((_this$_componentConfi = this._componentConfig) === null || _this$_componentConfi === void 0 ? void 0 : _this$_componentConfi.mode) || "unfocused";
        }
        set mode(v) {
            if (typeof v !== "string" || this._mode === v) return;
            this._mode = v;
            var event = this["on".concat(capitalizeFirstLetter(v))];
            if (event && typeof event === "function") event.call(this);
            this._styleManager.update();
        }
        get tone() {
            return this._tone || this._componentConfig.tone || "neutral";
        }
        set tone(v) {
            if (typeof v !== "string" || this._tone === v) return;
            this._tone = v;
            this._styleManager.update();
        }
        get w() {
            var _this$style;
            return this._wSetByUser && this._w || ((_this$style = this.style) === null || _this$style === void 0 ? void 0 : _this$style.w) || 0;
        }
        set w(v) {
            if (this._w === v) return;
            super.w = v;
            this._wSetByUser = true;
            this._updateThemeComponent();
        }
        get h() {
            var _this$style2;
            return this._hSetByUser && this._h || ((_this$style2 = this.style) === null || _this$style2 === void 0 ? void 0 : _this$style2.h) || this._h || 0;
        }
        set h(v) {
            if (this._h === v) return;
            super.h = v;
            this._hSetByUser = true;
            this._updateThemeComponent();
        }
    };
}

var SUFFIX = "__original";

function withExtensions(Base) {
    if (Base.prototype.constructor._withExtensionsApplied) {
        return Base;
    }
    return class extends Base {
        static get name() {
            return Base.name;
        }
        static get __componentName() {
            if (!super.__componentName) {
                throw new Error("A valid static __componentName property is required for theming to work properly. Please add this to the ".concat(this.constructor.name, " class."));
            }
            return super.__componentName;
        }
        static get _withExtensionsApplied() {
            return true;
        }
        get _prototypeChain() {
            if (this.__prototypeChain) return this.__prototypeChain;
            var prototypeChain = new Set;
            var proto = this;
            do {
                proto = Object.getPrototypeOf(proto);
                if (null !== proto && typeof proto === "object") {
                    try {
                        if (proto.constructor.__componentName) prototypeChain.add(proto.constructor.__componentName);
                    } catch (error) {}
                }
            } while (proto);
            this.__prototypeChain = prototypeChain;
            return prototypeChain;
        }
        get _extensions() {
            var extensions = contextInstance && contextInstance.theme && contextInstance.theme.extensions;
            if (!extensions || !Array.isArray(extensions) || Array.isArray(extensions) && !extensions.length) return [];
            return extensions.filter((_ref11 => {
                var {targetComponent: targetComponent, extension: extension} = _ref11;
                return (typeof targetComponent === "string" || Array.isArray(targetComponent)) && typeof extension === "function";
            })).slice().reverse() || [];
        }
        get _componentExtensions() {
            return this._extensions.filter((_ref12 => {
                var {targetComponent: targetComponent} = _ref12;
                if (typeof targetComponent === "string") {
                    return targetComponent === this.constructor.__componentName || this._prototypeChain.has(targetComponent);
                } else if (Array.isArray(targetComponent)) {
                    return targetComponent.find((pattern => {
                        if (pattern.startsWith("/") && pattern.endsWith("/")) {
                            var ComponentRegExp = new RegExp(pattern.slice(1, -1));
                            return Array.from(this._prototypeChain).some((name => ComponentRegExp.test(name)));
                        } else {
                            return this._prototypeChain.has(pattern);
                        }
                    }));
                }
                return false;
            })).reduce(((acc, _ref13) => {
                var {extension: extension} = _ref13;
                acc.push(extension);
                return acc;
            }), []);
        }
        get _extensionApplied() {
            return this._currentComponentExtensionLength === this._appliedExtensionLength;
        }
        _construct() {
            this._appliedExtensionLength = 0;
            this._extendedList = {};
            this._extensionInstance = {};
            this._setupExtensionBound = this._setupExtension.bind(this);
            contextInstance.on("themeUpdate", this._setupExtensionBound);
            this._currentComponentExtensionLength = this._calculateComponentExtensionLength();
            this._createExtension();
            super._construct();
        }
        _detach() {
            super._detach();
            contextInstance.off("themeUpdate", this._setupExtensionBound);
        }
        _setupExtension() {
            this._currentComponentExtensionLength = this._calculateComponentExtensionLength();
            this._createExtension.call(this);
        }
        _resetComponent() {
            this._extensionInstance._extensionCleanup && this._extensionInstance._extensionCleanup.call(this);
            (Object.keys(this._extendedList) || []).forEach((prop => {
                delete this[prop];
                delete this[prop + SUFFIX];
            }));
            this._extensionInstance = {};
            this._extendedList = {};
        }
        _calculateComponentExtensionLength() {
            var extensionLength = this._componentExtensions.reduce(((acc, extensionMixin) => {
                acc += extensionMixin.toString().length;
                return acc;
            }), 0);
            return extensionLength;
        }
        _createExtension() {
            if (this._extensionApplied) return;
            this._resetComponent();
            var ExtendedClass = this._createExtensionClass();
            var instance = new ExtendedClass;
            this._extendedList = this._createExtensionAliases(instance);
            this._extensionInstance = instance;
            this._setComponentAliases(this._extendedList);
        }
        _createExtensionClass() {
            function ExtensionBase() {}
            var ExtendedClass = this._componentExtensions.reduce(((acc, extension) => extension(acc)), ExtensionBase);
            this._appliedExtensionLength = this._calculateComponentExtensionLength();
            return ExtendedClass;
        }
        _createExtensionAliases(obj) {
            var baseProto = obj;
            for (var i = 0; i < this._componentExtensions.length + 1; i++) {
                baseProto = Object.getPrototypeOf(baseProto);
            }
            var extended = {};
            var extensionOverrides = this._componentExtensions.reduce(((acc, extension) => {
                var extensionClass = new extension(class FakeClass {});
                var instance = new extensionClass;
                var originalComponentDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf(instance));
                Object.keys(originalComponentDescriptors).forEach((prop => {
                    if ([ "constructor" ].includes(prop)) return;
                    if (originalComponentDescriptors[prop].get || originalComponentDescriptors[prop].set) {
                        extended[prop] = {
                            type: "accessor"
                        };
                        acc[prop] = {
                            get: function get() {
                                return this[prop + SUFFIX];
                            },
                            set: function set(v) {
                                this[prop + SUFFIX] = v;
                            }
                        };
                        return;
                    }
                    extended[prop] = {
                        type: "method"
                    };
                    acc[prop] = {
                        value: function value() {
                            this[prop + SUFFIX] && this[prop + SUFFIX]();
                        }
                    };
                }));
                return acc;
            }), {});
            Object.defineProperties(baseProto, extensionOverrides);
            Object.setPrototypeOf(baseProto, this);
            return extended;
        }
        _setComponentAliases(aliasObj) {
            Object.keys(aliasObj).forEach((prop => {
                this[prop + SUFFIX] = this[prop];
                if (aliasObj[prop].type === "method") {
                    this[prop] = this._extensionInstance[prop];
                } else if (aliasObj[prop].type === "accessor") {
                    Object.defineProperty(this, prop, {
                        configurable: true,
                        get() {
                            return this._extensionInstance[prop];
                        },
                        set(v) {
                            this._extensionInstance[prop] = v;
                        }
                    });
                }
            }));
        }
    };
}

class Base extends lng.Component {
    static get __componentName() {
        return "Base";
    }
    _construct() {
        this.constructor.__componentName;
        this.skipPlinko = false;
        this.centerInParent = false;
        if (!this.loaded) this.loaded = Promise.resolve();
    }
    _init() {
        this.queueRequestUpdate();
    }
    _resetLoadedPromise() {
        this.loaded = new Promise(((resolve, reject) => {
            this._resolveLoadedPromise = resolve;
            this._rejectLoadedPromise = reject;
        }));
    }
    _update() {}
    _focus() {
        this._updateShouldSmooth();
        this.queueRequestUpdate();
    }
    _unfocus() {
        this.queueRequestUpdate();
    }
    _updateShouldSmooth() {
        if (this.shouldSmooth === undefined) this.shouldSmooth = true;
    }
    applySmooth(ref, patch, smooth) {
        if (this.shouldSmooth) {
            ref.smooth = smooth || patch;
        } else {
            ref.patch(patch);
        }
    }
    get announce() {
        return this._announce;
    }
    set announce(announce) {
        this._announce = announce;
    }
    get announceContext() {
        return this._announceContext;
    }
    set announceContext(announce) {
        this._announceContext = announce;
    }
    get shouldSmooth() {
        return this._shouldSmooth;
    }
    set shouldSmooth(shouldSmooth) {
        this._shouldSmooth = shouldSmooth;
    }
    get _isDisabledMode() {
        return this.mode === "disabled";
    }
    get _isUnfocusedMode() {
        return this.mode === "unfocused";
    }
    get _isFocusedMode() {
        return this.mode === "focused";
    }
    isFullyOnScreen(offsets) {
        return isComponentOnScreen(this, offsets);
    }
    getFocusScale() {
        return contextInstance.theme.layout.focusScale;
    }
    getUnfocusScale() {
        return 1;
    }
}

function withMixins(baseComponent) {
    return withExtensions(withLayout(withThemeStyles(withUpdates(withTags(withHandleKey(baseComponent))))));
}

var Base$1 = withMixins(Base);

var base$R = theme => ({
    gradientTop: theme.color.fillTransparent,
    radius: theme.radius.none
});

var tone$p = theme => ({
    neutral: {
        gradientColor: theme.color.material
    },
    inverse: {
        gradientColor: theme.color.fillNeutral
    },
    brand: {
        gradientColor: theme.color.fillBrand
    }
});

var styles$S = Object.freeze({
    __proto__: null,
    base: base$R,
    tone: tone$p
});

class Gradient extends Base$1 {
    static get __componentName() {
        return "Gradient";
    }
    static get __themeStyle() {
        return styles$S;
    }
    _update() {
        this.patch({
            rect: true,
            rtt: true,
            colorTop: this.style.gradientTop,
            colorBottom: this.style.gradientColor,
            texture: lng.Tools.getRoundRect(this.w, this.h, getMaxRoundRadius(this.style.radius, this.w, this.h))
        });
    }
}

var base$Q = theme => ({
    animationBlurEntrance: theme.animation.utilityEntrance,
    animationBlurExit: theme.animation.utilityExit,
    animationComponentEntrance: theme.animation.utilityEntrance,
    animationGradientEntrance: theme.animation.utilityEntrance,
    animationGradientExit: theme.animation.utilityExit,
    animationImageScaleEntrance: theme.animation.standardEntrance,
    animationImageScaleExit: theme.animation.standardEntrance,
    blur: 4,
    centerImageRadius: theme.radius.md,
    fallbackSrc: undefined,
    fillColor: theme.color.overlay,
    gradientColor: theme.color.material,
    imageScale: 1,
    imageScalePivotX: .5,
    imageScalePivotY: .5,
    padding: theme.spacer.md,
    radius: 0,
    zIndexSet: {
        image: 1,
        blur: 2,
        centerImage: 3,
        fill: 4,
        gradient: 5,
        foreground: 6
    }
});

var styles$R = Object.freeze({
    __proto__: null,
    base: base$Q
});

function checkFileType(str) {
    if (str.startsWith("<svg")) {
        return "SVG";
    } else if (str.startsWith("blob:")) {
        return "Blob";
    } else if (/\.(jpeg|jpg|gif|png|svg)$/i.test(str)) {
        return "Image";
    } else {
        return "Unknown";
    }
}

function createSvg(cb, stage, url, w, h) {
    var canvas = stage.platform.getDrawingCanvas();
    var ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    var img = new Image;
    img.onload = () => {
        canvas.width = w;
        canvas.height = h;
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        cb(null, {
            source: canvas,
            w: w,
            h: h
        });
    };
    img.onerror = err => {
        cb(err);
    };
    if (!lng.Utils.isPS4) {
        img.crossOrigin = "Anonymous";
    }
    img.src = url;
}

function imageLoader(_ref14, cb) {
    var {src: src} = _ref14;
    var image = new Image;
    if (!(src.substr(0, 5) == "data:") && !lng.Utils.isPS4) {
        image.crossOrigin = "Anonymous";
    }
    image.onerror = function() {
        if (image.src) {
            return cb("Image load error");
        }
    };
    image.onload = function() {
        cb(null, {
            source: image,
            renderInfo: {
                src: src,
                compressed: false
            },
            hasAlpha: true
        });
    };
    image.src = src;
    return function() {
        image.onerror = null;
        image.onload = null;
        image.removeAttribute("src");
    };
}

class CustomImageTexture extends lng.Texture {
    constructor(stage) {
        super(stage);
        this._src = undefined;
        this._hasAlpha = false;
    }
    get src() {
        return this._src;
    }
    set src(v) {
        if (this._src !== v) {
            this._src = v;
            this._changed();
        }
    }
    get hasAlpha() {
        return this._hasAlpha;
    }
    set hasAlpha(v) {
        if (this._hasAlpha !== v) {
            this._hasAlpha = v;
            this._changed();
        }
    }
    get w() {
        return this._w;
    }
    set w(l) {
        this._w = l;
        this._changed();
    }
    get h() {
        return this._h;
    }
    set h(l) {
        this._h = l;
        this._changed();
    }
    _getIsValid() {
        return !!this._src;
    }
    _getLookupId() {
        return this._src;
    }
    _getSourceLoader() {
        var w = this._w;
        var h = this._h;
        var src = this._src;
        var hasAlpha = this._hasAlpha;
        if (this.stage.getOption("srcBasePath")) {
            var fc = src.charCodeAt(0);
            if (src.indexOf("//") === -1 && (fc >= 65 && fc <= 90 || fc >= 97 && fc <= 122 || fc == 46)) {
                src = this.stage.getOption("srcBasePath") + src;
            }
        }
        return cb => {
            var fileType = checkFileType(src);
            switch (fileType) {
              case "SVG":
                return createSvg(cb, this.stage, "data:image/svg+xml,".concat(encodeURIComponent(src)), w, h);

              case "Blob":
                return imageLoader({
                    src: src
                }, cb);

              default:
                return this.stage.platform.loadSrcTexture({
                    src: src,
                    hasAlpha: hasAlpha
                }, cb);
            }
        };
    }
    getNonDefaults() {
        var obj = super.getNonDefaults();
        if (this._src) {
            obj.src = this._src;
        }
        return obj;
    }
}

class Artwork extends Base$1 {
    static get __componentName() {
        return "Artwork";
    }
    static get __themeStyle() {
        return styles$R;
    }
    static get properties() {
        return [ "blur", "fallbackSrc", "foregroundHeight", "foregroundSrc", "foregroundWidth", "gradient", "format", "src", "fill", "shouldScale", "srcCallback", "srcCallbackAspectRatios" ];
    }
    static get tags() {
        return [ "Blur", "CenterImage", "FillColor", "ForegroundImage", "Gradient", "Image", "Item" ];
    }
    static get aliasProperties() {
        return [ {
            prev: "foregroundH",
            curr: "foregroundHeight"
        }, {
            prev: "foregroundW",
            curr: "foregroundWidth"
        } ];
    }
    static _template() {
        return {
            rtt: true,
            Image: {}
        };
    }
    get _shouldBlur() {
        var shouldBur = this._blur || this._hasCenterImage;
        this._Image.rtt = shouldBur;
        return shouldBur;
    }
    get _hasCenterImage() {
        return -1 < [ "circle", "square" ].indexOf(this.format) || "contain" === this.format && !this._aspectRatioEqual;
    }
    set w(v) {
        if (v === super.w) return;
        super.w = v;
        this._componentSrc = this._generatePromise();
    }
    get w() {
        return super.w;
    }
    set h(v) {
        if (v === super.h) return;
        super.h = v;
        this._componentSrc = this._generatePromise();
    }
    get h() {
        return super.h;
    }
    get _actualAspectRatio() {
        if (!this.w || !this.h) return null;
        return reduceFraction("".concat(this.w, "/").concat(this.h)).replace("/", "x");
    }
    get _supportedAspectRatioHeights() {
        return this.srcCallbackAspectRatios.map((ratio => {
            var [rw, rh] = ratio.split("x").map((v => parseInt(v)));
            var calcHeight = this.w / rw * rh;
            return calcHeight;
        }));
    }
    get _closestSupportedAspectRatio() {
        var closest = this._supportedAspectRatioHeights.reduce(((prev, curr) => Math.abs(curr - this.h) < Math.abs(prev - this.h) ? curr : prev));
        return this.srcCallbackAspectRatios[this._supportedAspectRatioHeights.indexOf(closest)];
    }
    get _processedImageSrc() {
        var src = this.src || this.fallbackSrc;
        if (src !== this.fallbackSrc && this.srcCallback && typeof this.srcCallback === "function") {
            src = this.srcCallback({
                closestAspectRatio: this._closestSupportedAspectRatio,
                aspectRatio: this._actualAspectRatio,
                src: this.src,
                w: this.w,
                h: this.h
            });
        }
        return src && src.then ? src : Promise.resolve(src);
    }
    get _gradientPatch() {
        return {
            alpha: !this._Gradient && this.shouldSmooth ? .001 : 1,
            style: {
                gradientColor: getValidColor(this.style.gradientColor)
            },
            h: this.h + 4,
            type: Gradient,
            w: this.w + 4,
            x: -2,
            y: -2,
            zIndex: this.core.findZContext().zIndex + this.style.zIndexSet.gradient
        };
    }
    _construct() {
        super._construct();
        this._srcCallbackAspectRatios = [ "16x9", "3x4", "4x3", "2x1", "1x1" ];
    }
    _setSrc(v) {
        this._componentSrc = this._generatePromise();
        return v;
    }
    _getFallbackSrc() {
        return this._fallbackSrc || this.style && this.style.fallbackSrc;
    }
    _generatePromise() {
        var resolvePromise, rejectPromise;
        var complete = new Promise((function(resolve, reject) {
            resolvePromise = resolve;
            rejectPromise = reject;
        }));
        return {
            complete: complete,
            resolve: resolvePromise,
            reject: rejectPromise
        };
    }
    _setup() {
        this.alpha = .001;
        this._componentSrc = this._generatePromise();
        this._aspectRatioEqual = false;
        this._Image.on("txLoaded", this._resolveLoading.bind(this));
        this._Image.on("txError", this._rejectLoading.bind(this));
    }
    _resolveLoading() {
        this._aspectRatioEqual = this._Image.texture.source ? parseFloat(this.finalW / this.finalH).toFixed(2) === parseFloat(this._Image.texture.source.w / this._Image.texture.source.h).toFixed(2) : false;
        this._componentSrc.resolve && this._componentSrc.resolve();
        this.signal("imageLoaded");
    }
    _rejectLoading(error) {
        this._componentSrc.reject && this._componentSrc.reject(error);
        this.signal("imageLoadFailed");
    }
    _update() {
        var _this5 = this;
        return _asyncToGenerator((function*() {
            _this5._updateRadius();
            _this5._updateGradient();
            yield _this5._updateImage();
            _this5._updateFillColor();
            _this5._updateForegroundImage();
            if (!_this5.src) {
                _this5._showComponent();
                return;
            }
            try {
                yield _this5._componentSrc.complete;
                yield _this5._updateCenterImage();
                _this5._updateBlur();
                _this5._showComponent();
                _this5._updateScale();
            } catch (e) {
                _this5._handleImageLoadError();
            }
            if (_this5.shouldSmooth === undefined) _this5.shouldSmooth = true;
        }))();
    }
    _updateScale() {
        if (this.shouldScale) {
            var imageScale;
            switch (typeof this.style.imageScale) {
              case "function":
                imageScale = this.style.imageScale(this.w);
                break;

              case "number":
                imageScale = this.style.imageScale;
                break;

              default:
                imageScale = 1;
            }
            this._Image.smooth = {
                pivotX: this.style.imageScalePivotX,
                pivotY: this.style.imageScalePivotY,
                scale: [ imageScale, this._Image.scale < imageScale ? this.style.animationImageScaleEntrance : this.style.animationImageScaleExit ]
            };
        } else {
            var scale = 1;
            this._Image.smooth = {
                scale: [ scale, this.style.animationImageScaleExit ]
            };
        }
    }
    _handleImageLoadError() {
        if (this.src === this.fallbackSrc) return;
        contextInstance.error("Image ".concat(this._src, " failed to load"));
        if (this.fallbackSrc && this.fallbackSrc !== this.src) {
            this.src = this.fallbackSrc;
        }
    }
    _showComponent() {
        this.smooth = {
            alpha: [ 1, this.style.animationComponentEntrance ]
        };
    }
    _updateForegroundImage() {
        var _this6 = this;
        return _asyncToGenerator((function*() {
            if (!_this6._foregroundSrc) {
                if (_this6._ForegroundImage) {
                    _this6.patch({
                        ForegroundImage: undefined
                    });
                }
                return;
            }
            var foregroundImagePatch = {
                mount: .5,
                x: _this6.w / 2,
                y: _this6.h / 2,
                zIndex: _this6.core.findZContext().zIndex + _this6.style.zIndexSet.foreground,
                texture: {
                    type: CustomImageTexture,
                    src: _this6._foregroundSrc,
                    hasAlpha: true
                }
            };
            if (_this6.foregroundWidth && _this6.foregroundHeight) {
                foregroundImagePatch.h = _this6.foregroundHeight;
                foregroundImagePatch.w = _this6.foregroundWidth;
                _this6.patch({
                    ForegroundImage: foregroundImagePatch
                });
            } else if (_this6.foregroundWidth || _this6.foregroundHeight) {
                _this6.patch({
                    ForegroundImage: _objectSpread(_objectSpread({}, foregroundImagePatch), {}, {
                        alpha: .001
                    })
                });
                _this6._ForegroundImage.once("txLoaded", (() => {
                    var imageW = _this6._ForegroundImage.texture.getRenderWidth();
                    var imageH = _this6._ForegroundImage.texture.getRenderHeight();
                    _this6._ForegroundImage.patch({
                        alpha: 1,
                        w: _this6.foregroundHeight ? _this6.foregroundHeight * (imageW / imageH) : _this6.foregroundWidth,
                        h: _this6.foregroundWidth ? _this6.foregroundWidth * (imageH / imageW) : _this6.foregroundHeight
                    });
                }));
            }
            _this6.patch({
                ForegroundImage: foregroundImagePatch
            });
        }))();
    }
    _updateBlur() {
        if ((!this._shouldBlur || this._Image && this._Image.texture && this._Image.texture.src === this.fallbackSrc) && this._Blur) {
            if (this.shouldSmooth) {
                this._Blur._getTransition("alpha").once("finish", (() => {
                    this.patch({
                        Blur: undefined
                    });
                }));
                this._Blur.smooth = {
                    alpha: [ 0, this.style.animationBlurExit ]
                };
            } else {
                this.patch({
                    Blur: undefined
                });
            }
            return;
        }
        if (!this._srcFailed && this._shouldBlur) {
            this.patch({
                Blur: {
                    alpha: !this._Blur && this.shouldSmooth ? .001 : 1,
                    amount: this.style.blur,
                    zIndex: this.core.findZContext().zIndex + this.style.zIndexSet.blur,
                    content: {
                        Image: {
                            h: this.h,
                            texture: this._Image.getTexture(),
                            w: this.w
                        }
                    },
                    h: this.h,
                    rtt: true,
                    type: lng.components.FastBlurComponent,
                    w: this.w
                }
            });
            if (this._Blur.alpha < 1) {
                this._Blur.smooth = {
                    alpha: [ 1, this.style.animationBlurEntrance ]
                };
            }
        }
    }
    _updateCenterImage() {
        if (this.format === "contain") {
            this._updateFormatContain();
        } else if (this.format === "circle" || this.format === "square") {
            this._updateFormatSquareCircle();
        } else if (this._CenterImage) {
            this.patch({
                CenterImage: undefined
            });
        }
    }
    _updateFormatContain() {
        var _this7 = this;
        return _asyncToGenerator((function*() {
            if (_this7._CenterImage && _this7._CenterImage.mode !== _this7.format || _this7.src === _this7.fallbackSrc || _this7._aspectRatioEqual) {
                _this7.patch({
                    CenterImage: undefined
                });
                if (_this7.src === _this7.fallbackSrc || _this7._aspectRatioEqual) {
                    _this7._Image.alpha = 1;
                    return;
                }
            }
            var imageW;
            var imageH;
            var ratioW = Math.abs(_this7._Image.texture.source.w / _this7._Image.texture.source.h);
            var ratioH = Math.abs(_this7._Image.texture.source.h / _this7._Image.texture.source.w);
            if (_this7._Image.texture.source.w < _this7._Image.texture.source.h) {
                if (_this7.h * ratioW < _this7.w) {
                    imageW = _this7.h * ratioW;
                    imageH = _this7.h;
                } else {
                    imageW = _this7.w;
                    imageH = _this7.w * ratioH;
                }
            } else if (_this7._Image.texture.source.w > _this7._Image.texture.source.h) {
                if (_this7.w * ratioH < _this7.h) {
                    imageW = _this7.w;
                    imageH = _this7.w * ratioH;
                } else {
                    imageW = _this7.h * ratioW;
                    imageH = _this7.h;
                }
            } else {
                imageW = Math.min(_this7.w, _this7.h);
                imageH = imageW;
            }
            var src = yield _this7._processedImageSrc;
            _this7.patch({
                CenterImage: {
                    format: _this7.format,
                    mount: .5,
                    w: imageW,
                    h: imageH,
                    x: _this7.w / 2,
                    y: _this7.h / 2,
                    zIndex: _this7.core.findZContext().zIndex + _this7.style.zIndexSet.centerImage,
                    texture: {
                        src: src,
                        resizeMode: {
                            h: imageH,
                            type: "cover",
                            w: imageW
                        },
                        type: CustomImageTexture
                    }
                }
            });
        }))();
    }
    _updateFormatSquareCircle() {
        if (this._CenterImage && this._CenterImage.mode !== this.format || this.src === this.fallbackSrc) {
            this.patch({
                CenterImage: undefined
            });
            if (this.src === this.fallbackSrc) return;
        }
        var imageSize = Math.min(this.w, this.h) - this.style.padding * 2;
        this.patch({
            CenterImage: {
                format: this.format,
                h: imageSize,
                shader: {
                    radius: "circle" === this.format ? imageSize / 2 : this.style.centerImageRadius,
                    type: lng.shaders.RoundedRectangle
                },
                w: imageSize,
                zIndex: this.core.findZContext().zIndex + this.style.zIndexSet.centerImage,
                Image: {
                    h: imageSize,
                    mount: .5,
                    rtt: true,
                    w: imageSize,
                    x: this.w / 2,
                    y: this.h / 2,
                    texture: {
                        src: this._Image.texture.src,
                        resizeMode: {
                            h: imageSize,
                            type: "cover",
                            w: imageSize
                        },
                        type: CustomImageTexture
                    }
                }
            }
        });
    }
    _updateGradient() {
        if (!this.gradient) {
            if (this._Gradient) {
                if (this.shouldSmooth) {
                    this._Gradient._getTransition("alpha").once("finish", (() => {
                        var transition = this._Gradient && this._Gradient._getTransition("alpha");
                        if (!this.gradient && transition && transition.p === 1) this.patch({
                            Gradient: undefined
                        });
                    }));
                    this._Gradient.patch(this._gradientPatch);
                    this._Gradient.smooth = {
                        alpha: [ 0, this.style.animationGradientExit ]
                    };
                } else {
                    this.patch({
                        Gradient: undefined
                    });
                }
            }
            return;
        }
        this._createGradient();
    }
    _createGradient() {
        this.patch({
            Gradient: this._gradientPatch
        });
        if (this.shouldSmooth) {
            this.applySmooth(this._Gradient, {
                alpha: [ 1, this.style.animationGradientEntrance ]
            });
        }
    }
    _updateImage() {
        var _this8 = this;
        return _asyncToGenerator((function*() {
            _this8._aspectRatioEqual = false;
            if (!_this8._processedImageSrc) {
                if (_this8._Image) {
                    _this8._Image.texture = undefined;
                }
                return;
            }
            var src = yield _this8._processedImageSrc;
            _this8._Image.patch({
                alpha: _this8.src !== _this8.fallbackSrc && (_this8._blur || _this8._hasCenterImage) ? .001 : 1,
                h: _this8.h,
                texture: {
                    type: CustomImageTexture,
                    src: src,
                    resizeMode: {
                        type: "cover",
                        w: _this8.w,
                        h: _this8.h
                    }
                },
                w: _this8.w,
                zIndex: _this8.core.findZContext().zIndex + _this8.style.zIndexSet.image
            });
        }))();
    }
    _updateFillColor() {
        if (!this.fill) {
            this.patch({
                FillColor: undefined
            });
        } else {
            this.patch({
                FillColor: {
                    rect: true,
                    w: this.w,
                    h: this.h,
                    color: this.style.fillColor,
                    zIndex: 5
                }
            });
        }
    }
    _updateRadius() {
        this.patch(this.style.radius ? {
            shader: {
                type: lng.shaders.RoundedRectangle,
                radius: getMaxRoundRadius(this.style.radius, this.w, this.h)
            }
        } : {
            shader: undefined
        });
    }
}

var tone$o = theme => ({
    neutral: {
        color: theme.color.fillNeutral
    },
    inverse: {
        color: theme.color.fillInverse
    },
    brand: {
        color: theme.color.fillBrand
    }
});

var styles$Q = Object.freeze({
    __proto__: null,
    tone: tone$o
});

class Icon extends Base$1 {
    static get __componentName() {
        return "Icon";
    }
    static get __themeStyle() {
        return styles$Q;
    }
    static get properties() {
        return [ "icon", "fixed", "color" ];
    }
    _init() {
        this.on("txLoaded", (() => {
            if (!this.fixed) {
                this._notify.bind(this)();
            }
        }));
        this.on("txError", this._handleTxtError.bind(this));
    }
    _getColor() {
        return this._color || this.style.color;
    }
    _notify() {
        this.w = this.finalW;
        this.h = this.finalH;
        this.signal("itemChanged", this);
        this.fireAncestors("$itemChanged");
    }
    _handleTxtError() {
        contextInstance.error("Unable to load icon ".concat(this._icon));
        this._icon = null;
        this.texture = null;
    }
    _update() {
        if (!this._icon) {
            this.texture = null;
            return;
        }
        this.patch(this._iconPatch);
    }
    get _iconPatch() {
        var [isSvgTag, isSvgURI] = [ /^<svg.*<\/svg>$/, /\.svg$/ ].map((regex => RegExp.prototype.test.bind(regex)));
        var texture;
        var svgTag = isSvgTag(this.icon);
        var svgURI = isSvgURI(this.icon);
        if (svgTag) {
            texture = lng.Tools.getSvgTexture("data:image/svg+xml,".concat(encodeURIComponent(this.icon)), this.w, this.h);
        } else if (svgURI) {
            texture = lng.Tools.getSvgTexture(this.icon, this.w, this.h);
        } else {
            texture = {
                type: CustomImageTexture,
                w: this.w,
                h: this.h,
                src: this.icon
            };
        }
        var color = getValidColor(this._color || this.style.color);
        var shader = this.radius || this.style.radius ? {
            radius: this.radius || this.style.radius,
            type: lng.shaders.RoundedRectangle
        } : undefined;
        return _objectSpread({
            texture: texture,
            shader: shader
        }, color ? {
            colorUl: color,
            colorUr: color,
            colorBl: color,
            colorBr: color
        } : {});
    }
}

var base$P = theme => ({
    contentSpacing: theme.spacer.xs,
    offsetY: 1,
    paddingX: theme.spacer.md,
    paddingY: theme.spacer.xs,
    radius: theme.radius.sm,
    strokeWidth: theme.stroke.sm,
    textStyle: _objectSpread(_objectSpread({}, theme.typography.tag1), {}, {
        textAlign: "center"
    })
});

var tone$n = theme => ({
    neutral: {
        backgroundColor: theme.color.fillInverseSecondary,
        iconColor: theme.color.textNeutral,
        textStyle: {
            textColor: theme.color.textNeutral
        },
        strokeColor: theme.color.strokeNeutralSecondary
    },
    inverse: {
        backgroundColor: theme.color.fillNeutralSecondary,
        iconColor: theme.color.textInverse,
        textStyle: {
            textColor: theme.color.textInverse
        },
        strokeColor: theme.color.strokeInverseSecondary
    },
    brand: {
        backgroundColor: theme.color.fillBrand,
        iconColor: theme.color.textNeutral,
        textStyle: {
            textColor: theme.color.textNeutral
        },
        strokeColor: theme.color.strokeInverseSecondary
    }
});

var styles$P = Object.freeze({
    __proto__: null,
    base: base$P,
    tone: tone$n
});

class Badge extends Base$1 {
    static _template() {
        return {
            Text: {
                mountY: .5
            },
            Icon: {
                type: Icon,
                mountY: .5,
                signals: {
                    itemChanged: "_updateLayout"
                }
            }
        };
    }
    static get __componentName() {
        return "Badge";
    }
    static get __themeStyle() {
        return styles$P;
    }
    static get properties() {
        return [ "title", "icon", "iconAlign", "iconWidth", "iconHeight" ];
    }
    static get tags() {
        return [ "Background", "Text", "Icon" ];
    }
    _init() {
        this._Text.on("txLoaded", this._updateLayout.bind(this));
        super._init();
    }
    _update() {
        this._updateText();
        this._updateIcon();
        this._updateLayout();
        this._updateVisibility();
    }
    _updateVisibility() {
        this.alpha = this.title || this.icon ? 1 : 0;
    }
    _updateLayout() {
        this._updateWidth();
        this._updateBackground();
        this._updatePositions();
        this.signal("loadedBadge", this);
    }
    _updateBackground() {
        var height = Math.max(this._Text.renderHeight, this._Icon.h) + this.style.paddingY * 2;
        this.patch({
            h: height,
            texture: lng.Tools.getRoundRect(this.w, height, getMaxRoundRadius(this.style.radius, this.w, height), this.style.strokeWidth, this.style.strokeColor, true, this.style.backgroundColor)
        });
    }
    _updateText() {
        if (this._Text) {
            this._Text.patch({
                text: _objectSpread(_objectSpread({}, this.style.textStyle), {}, {
                    text: this.title || ""
                })
            });
        }
    }
    _updateIcon() {
        this._Icon.patch({
            icon: this.icon,
            w: this.iconWidth,
            h: this.iconHeight,
            style: {
                color: getHexColor(this.style.iconColor)
            }
        });
    }
    _updateWidth() {
        var width = 0;
        if (this.title && this.icon) {
            width = this._Text.renderWidth + this._Icon.finalW + this.style.contentSpacing + this.style.paddingX * 2;
        } else if (this.title) {
            width = this._Text.renderWidth + this.style.paddingX * 2;
        } else if (this.icon) {
            width = this._Icon.finalW + this.style.paddingX * 2;
        }
        this.w = width;
    }
    _updatePositions() {
        this._Icon.y = this.h / 2;
        if (this.iconAlign === "left" && this.title && this.icon) {
            this._Icon.x = this.style.paddingX;
            this._Text.x = this._Icon.x + this._Icon.finalW + this.style.contentSpacing;
        } else if (this.iconAlign === "right" && this.title && this.icon) {
            this._Text.x = this.style.paddingX;
            this._Icon.x = this._Text.x + this._Text.renderWidth + this.style.contentSpacing;
        } else {
            this._Text.x = this.style.paddingX;
            this._Icon.x = this.style.paddingX;
        }
        this._Text.y = this._h / 2 + this.style.offsetY;
    }
    _getIconHeight() {
        if (this.icon) {
            return !this._Icon.finalH && this._Text ? this._Text.text.lineHeight : this._Icon.finalH;
        }
        return 0;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || this.title;
    }
}

var base$O = theme => ({
    width: 0,
    justify: "center",
    minWidth: getWidthByColumnSpan(theme, 3),
    paddingX: theme.spacer.xxxl,
    paddingXNoTitle: theme.spacer.xl,
    paddingY: theme.spacer.xl,
    radius: theme.radius.sm,
    contentSpacing: theme.spacer.md,
    itemSpacing: theme.spacer.md,
    textStyle: _objectSpread(_objectSpread({}, theme.typography.button1), {}, {
        maxLines: 1,
        textColor: theme.color.textNeutral
    }),
    contentColor: theme.color.fillNeutral
});

var mode$g = theme => ({
    focused: {
        textStyle: {
            textColor: theme.color.textInverse
        },
        contentColor: theme.color.fillInverse,
        tone: {
            inverse: {
                textStyle: {
                    textColor: theme.color.textNeutral
                },
                contentColor: theme.color.fillNeutral
            },
            brand: {
                contentColor: theme.color.fillNeutral
            }
        }
    },
    disabled: {
        textStyle: {
            textColor: theme.color.textNeutralDisabled
        },
        contentColor: theme.color.fillNeutralDisabled
    }
});

var styles$O = Object.freeze({
    __proto__: null,
    base: base$O,
    mode: mode$g
});

class FocusManager extends Base$1 {
    static get __componentName() {
        return "FocusManager";
    }
    static get tags() {
        return [ "Items" ];
    }
    static get properties() {
        return [ "direction", "wrapSelected" ];
    }
    _construct() {
        super._construct();
        this._selectedIndex = 0;
        this._itemPosX = 0;
        this._itemPosY = 0;
        this.direction = this.direction || "row";
    }
    _init() {
        this._checkSkipFocus();
    }
    get Items() {
        if (!this.tag("Items")) {
            this.patch({
                Items: {}
            });
        }
        return this._Items;
    }
    _setDirection(direction) {
        var state = {
            none: "None",
            column: "Column",
            row: "Row"
        }[direction];
        if (state) {
            this._setState(state);
        }
        return direction;
    }
    _getItems() {
        return this._Items.children;
    }
    get items() {
        return this.Items.children;
    }
    set items(items) {
        this._resetItems();
        this._selectedIndex = 0;
        this.appendItems(items);
        this._checkSkipFocus();
    }
    set itemPosX(x) {
        this.Items.x = this._itemPosX = x;
    }
    get itemPosX() {
        return this._itemPosX;
    }
    set itemPosY(y) {
        this.Items.y = this._itemPosY = y;
    }
    get itemPosY() {
        return this._itemPosY;
    }
    _resetItems() {
        this.Items.childList.clear();
        this.Items.patch({
            w: 0,
            h: 0,
            x: this.itemPosX,
            y: this.itemPosY
        });
        if (this._lazyItems) {
            this._lazyItems = null;
        }
    }
    _appendLazyItem(item) {
        this.appendItems([ item ]);
    }
    appendItems() {
        var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        this.Items.childList.a(items);
        this._refocus();
    }
    appendItemsAt() {
        var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var idx = arguments.length > 1 ? arguments[1] : undefined;
        var addIndex = Number.isInteger(idx) ? idx : this.Items.children.length;
        this.shouldSmooth = false;
        this._lastAppendedIdx = addIndex;
        items.forEach(((item, itemIdx) => {
            this.Items.childList.addAt(_objectSpread(_objectSpread({}, item), {}, {
                parentFocus: this.hasFocus()
            }), addIndex + itemIdx);
        }));
        if (this.selectedIndex >= this._lastAppendedIdx) {
            this._selectedIndex += items.length;
        }
        this.requestUpdate();
        this._refocus();
    }
    prependItems(items) {
        this.appendItemsAt(items, 0);
    }
    removeItemAt(index) {
        this.shouldSmooth = false;
        this.Items.childList.removeAt(index);
        if (this.selectedIndex > index || this.selectedIndex === this.Items.children.length) {
            this._selectedIndex--;
        }
        this.requestUpdate();
        this._refocus();
    }
    _checkSkipFocus() {
        var initialSelection = this.Items.children[this.selectedIndex];
        if (initialSelection && initialSelection.skipFocus) {
            this.selectNext(false);
        }
    }
    get selected() {
        return this.Items.children[this.selectedIndex];
    }
    get selectedIndex() {
        return this._selectedIndex;
    }
    set selectedIndex(index) {
        this.prevSelected = this.selected;
        if (!this.Items.children.length || !this.Items.children[index] || !this.Items.children[index].skipFocus) {
            if (index !== this._selectedIndex) {
                this._selectedIndex = index;
            }
            if (this.selected) {
                this._selectedChange(this.selected, this.prevSelected);
            }
            this._refocus();
        }
    }
    _selectedChange(selected, prevSelected) {
        this._render(selected, prevSelected);
        this.signal("selectedChange", selected, prevSelected);
    }
    _render() {}
    _firstFocusableIndex() {
        if (!this.items.length) return 0;
        var firstItem = this.items.reduce(((acc, item, idx) => {
            if (!item.skipFocus) {
                acc.push(_objectSpread(_objectSpread({}, item), {}, {
                    originalIdx: idx
                }));
            }
            return acc;
        }), []).shift();
        return firstItem.originalIdx;
    }
    _lastFocusableIndex() {
        if (!this.items.length) return 0;
        var lastItem = this.items.reduce(((acc, item, idx) => {
            if (!item.skipFocus) {
                acc.push(_objectSpread(_objectSpread({}, item), {}, {
                    originalIdx: idx
                }));
            }
            return acc;
        }), []).pop();
        return lastItem.originalIdx;
    }
    selectPrevious() {
        this.shouldSmooth = true;
        var hasFocusable = !!(this.items || []).filter((i => !i.skipFocus)).length;
        if (this.selectedIndex === 0 && !this.wrapSelected || !hasFocusable) {
            return false;
        }
        var previousItemIndex = this.items.map((item => !!item.skipFocus)).lastIndexOf(false, this._selectedIndex - 1);
        if (previousItemIndex > -1) {
            this.selectedIndex = previousItemIndex;
            return true;
        } else if (this.wrapSelected) {
            this.selectedIndex = this._lastFocusableIndex();
            return true;
        }
        return false;
    }
    selectNext(shouldSmoothOverride) {
        if (this._lazyItems && this._lazyItems.length) {
            this._appendLazyItem(this._lazyItems.splice(0, 1)[0]);
        }
        this.shouldSmooth = shouldSmoothOverride !== null && shouldSmoothOverride !== void 0 ? shouldSmoothOverride : true;
        var hasFocusable = !!(this.items || []).filter((i => !i.skipFocus)).length;
        if (this.selectedIndex === this.Items.children.length - 1 && !this.wrapSelected || !hasFocusable) {
            return false;
        }
        var nextIndex = this.items.findIndex(((item, idx) => !item.skipFocus && idx > this._selectedIndex));
        if (nextIndex > -1) {
            this.selectedIndex = nextIndex;
            return true;
        } else if (this.wrapSelected) {
            this.selectedIndex = this._firstFocusableIndex();
            return true;
        }
        return false;
    }
    _getIndexOfItemNear(selected, prev) {
        var prevItem = prev.selected;
        if (!selected || !selected.items || !selected.items.length || !prevItem) {
            return 0;
        }
        var [itemX, itemY] = prevItem.core.getAbsoluteCoords(0, 0);
        var prevMiddle = [ itemX + prevItem.w / 2, itemY + prevItem.h / 2 ];
        var selectedCoordArray = selected.items.map(((item, index) => ({
            index: index,
            distance: !item.skipFocus ? getShortestDistance(prevMiddle, item) : null
        }))).filter((item => null !== item.distance)).sort((function(a, b) {
            return a.distance - b.distance;
        }));
        return selectedCoordArray[0].index;
    }
    _focus() {
        super._focus();
        this.items.forEach((item => item.parentFocus = true));
    }
    _unfocus() {
        super._unfocus();
        this.items.forEach((item => item.parentFocus = false));
    }
    _updateShouldSmooth() {}
    _getFocused() {
        var {selected: selected} = this;
        if (selected) {
            if (selected.focusRef) {
                return selected.tag(selected.focusRef);
            } else if (selected.cparent) {
                return selected;
            }
        }
        return this;
    }
    _updateTransitionTarget(element, property, newValue) {
        if (element && element.transition(property) && !element.transition(property).isRunning() && element.transition(property).targetValue !== newValue) {
            element.transition(property).updateTargetValue(newValue);
        }
    }
    get onScreenItems() {
        return this.Items.children.filter((child => this._isOnScreen(child)));
    }
    _isOnScreenCompletely(child) {
        return child.isFullyOnScreen ? child.isFullyOnScreen() : isComponentOnScreen(child);
    }
    get fullyOnScreenItems() {
        return this.Items.children.reduce(((rv, item) => {
            if (item instanceof FocusManager) {
                return [ ...rv, ...item.Items.children.filter(this._isOnScreenCompletely) ];
            } else if (this._isOnScreenCompletely(item)) {
                return [ ...rv, item ];
            } else {
                return rv;
            }
        }), []);
    }
    _isOnScreen() {
        throw new Error("'_isOnScreen' must be implemented by 'row'/'column'");
    }
    _isComponentHorizontallyVisible(child) {
        var x = getX(child);
        if (!Number.isFinite(x)) return false;
        var transitionX = this.getTransitionXTargetValue();
        var px = this.core.renderContext.px;
        var itemX = px + transitionX + x;
        var [leftBounds = null, , clipWidth = null] = this.core._scissor || [];
        var stageW = this.stage.w / this.stage.getRenderPrecision();
        var {w: w} = child;
        var withinLeftStageBounds = itemX >= 0;
        var withinRightStageBounds = itemX + w <= stageW;
        if (!withinLeftStageBounds || !withinRightStageBounds) return false;
        var withinLeftClippingBounds = true;
        var withinRightClippingBounds = true;
        if (Number.isFinite(leftBounds)) {
            withinLeftClippingBounds = Math.round(itemX + w) >= Math.round(leftBounds);
            withinRightClippingBounds = Math.round(itemX) <= Math.round(leftBounds + clipWidth);
        }
        return withinLeftClippingBounds && withinRightClippingBounds;
    }
    _isComponentVerticallyVisible(child) {
        var y = getY(child);
        if (!Number.isFinite(y)) return false;
        var transitionY = this.getTransitionYTargetValue();
        var py = this.core.renderContext.py;
        var [, topBounds = null, , clipHeight = null] = this.core._scissor || [];
        var {h: h} = child;
        var itemY = py + transitionY + y;
        var stageH = this.stage.h / this.stage.getRenderPrecision();
        var withinTopStageBounds = itemY + h >= 0;
        var withingBottomStageBounds = itemY <= stageH;
        if (!withinTopStageBounds || !withingBottomStageBounds) return false;
        var withinTopClippingBounds = true;
        var withinBottomClippingBounds = true;
        if (Number.isFinite(topBounds)) {
            withinTopClippingBounds = Math.round(itemY + h) > Math.round(topBounds);
            withinBottomClippingBounds = Math.round(itemY) < Math.round(topBounds + clipHeight);
        }
        return withinTopClippingBounds && withinBottomClippingBounds;
    }
    getTransitionXTargetValue() {
        return this.Items.transition("x").targetValue;
    }
    getTransitionYTargetValue() {
        return this.Items.transition("y").targetValue;
    }
    static _states() {
        return [ class None extends(this){}, class Row extends(this){
            _handleLeft() {
                return typeof this.onLeft === "function" ? this.onLeft(this) : this.selectPrevious();
            }
            _handleRight() {
                return typeof this.onRight === "function" ? this.onRight(this) : this.selectNext();
            }
        }, class Column extends(this){
            _handleUp() {
                return typeof this.onUp === "function" ? this.onUp(this) : this.selectPrevious();
            }
            _handleDown() {
                return typeof this.onDown === "function" ? this.onDown(this) : this.selectNext();
            }
        } ];
    }
}

var base$N = theme => ({
    alwaysScroll: false,
    itemSpacing: theme.layout.gutterX,
    itemTransition: theme.animation.utility,
    neverScroll: false,
    scrollIndex: 0
});

var styles$N = Object.freeze({
    __proto__: null,
    base: base$N
});

var directionPropNames = {
    row: {
        axis: "x",
        crossAxis: "y",
        lengthDimension: "w",
        crossDimension: "h",
        innerLengthDimension: "innerW",
        innerCrossDimension: "innerH"
    },
    column: {
        axis: "y",
        crossAxis: "x",
        lengthDimension: "h",
        crossDimension: "w",
        innerLengthDimension: "innerH",
        innerCrossDimension: "innerW"
    }
};

class NavigationManager extends FocusManager {
    static get __componentName() {
        return "NavigationManager";
    }
    static get __themeStyle() {
        return styles$N;
    }
    static get properties() {
        return [ ...super.properties, "alwaysScroll", "neverScroll", "scrollIndex", "autoResizeWidth", "autoResizeHeight", "lazyUpCount", "lazyUpCountBuffer", "waitForDimensions" ];
    }
    _construct() {
        super._construct();
        this.shouldSmooth = false;
        this._lazyUpCountBuffer = 2;
    }
    _init() {
        var {lengthDimension: lengthDimension, axis: axis} = this._directionPropNames;
        if (!this[lengthDimension]) {
            this._initComponentSize();
        }
        this.Items.transition(axis).on("finish", this._transitionListener.bind(this));
        super._init();
    }
    _initComponentSize() {
        var {lengthDimension: lengthDimension} = this._directionPropNames;
        if ((this === null || this === void 0 ? void 0 : this.parent.parent) instanceof NavigationManager && this !== null && this !== void 0 && this.parent.parent[lengthDimension]) {
            this[lengthDimension] = this.parent.parent[lengthDimension];
        } else {
            var parent = this.parent;
            while (parent && !parent[lengthDimension]) {
                parent = parent.parent;
            }
            this[lengthDimension] = parent && parent[lengthDimension] || this.stage.h / this.stage.getRenderPrecision();
        }
    }
    _update() {
        this._updateLayout();
    }
    _updateLayout() {
        var {lengthDimension: lengthDimension, crossDimension: crossDimension, crossAxis: crossAxis, innerCrossDimension: innerCrossDimension} = this._directionPropNames;
        var nextPosition = 0;
        var maxCrossDimensionSize = 0;
        var maxInnerCrossDimensionSize = 0;
        var childrenToCenter = [];
        var loadingChildren = [];
        for (var i = 0; i < this.Items.children.length; i++) {
            var child = this.Items.children[i];
            if (child.requestEarlyUpdate) {
                var updateDidRun = child.requestEarlyUpdate();
                if (!updateDidRun && (child.w === 0 || child.h === 0)) {
                    child._updateLayout && child._updateLayout();
                }
            }
            var childCrossDimensionSize = this._calcCrossDimensionSize(child);
            if (this.waitForDimensions && (!childCrossDimensionSize || !child[lengthDimension])) {
                loadingChildren.push(child);
            }
            maxCrossDimensionSize = max(maxCrossDimensionSize, childCrossDimensionSize);
            maxInnerCrossDimensionSize = max(maxInnerCrossDimensionSize, child[innerCrossDimension] || 0);
            this.updatePositionOnAxis(child, nextPosition);
            nextPosition += child[lengthDimension];
            if (i < this.Items.children.length - 1) {
                var extraItemSpacing = child.extraItemSpacing || 0;
                nextPosition += this.style.itemSpacing + extraItemSpacing;
            }
            if (child.centerInParent) {
                var _childCrossDimensionSize = child.Items && child.Items[crossDimension] || child[crossDimension];
                if (_childCrossDimensionSize < this[crossDimension] || !this.Items[innerCrossDimension]) {
                    childrenToCenter.push({
                        childIdx: i,
                        childCrossDimensionSize: _childCrossDimensionSize
                    });
                }
            } else {
                child[crossAxis] = 0;
            }
        }
        var itemChanged = this.Items[crossDimension] !== maxCrossDimensionSize || this.Items[lengthDimension] !== nextPosition;
        if (this.waitForDimensions) {
            this.Items.alpha = loadingChildren.length ? .001 : 1;
        }
        this.Items.patch({
            [crossDimension]: maxCrossDimensionSize,
            [innerCrossDimension]: maxInnerCrossDimensionSize || maxCrossDimensionSize,
            [lengthDimension]: nextPosition + (this._totalAddedWidth || 0)
        });
        this._autoResize();
        this._centerItemsInParent(childrenToCenter);
        this._updateLastScrollIndex();
        if (itemChanged) {
            this._performRender();
            this.fireAncestors("$itemChanged");
        }
    }
    _centerItemsInParent(items) {
        var {crossDimension: crossDimension, crossAxis: crossAxis, innerCrossDimension: innerCrossDimension} = this._directionPropNames;
        if (items.length) {
            var sizes = [ this.Items[crossDimension], this.Items[innerCrossDimension] ];
            if (this.children.length === 1) {
                sizes.push(this[crossDimension]);
            }
            var crossDimensionSize = Math.max(...sizes);
            items.forEach((_ref15 => {
                var {childIdx: childIdx, childCrossDimensionSize: childCrossDimensionSize} = _ref15;
                this.Items.children[childIdx][crossAxis] = (crossDimensionSize - childCrossDimensionSize) / 2;
            }));
        }
    }
    _autoResize() {
        if (this.autoResizeWidth) {
            this.w = this.Items.w;
        }
        if (this.autoResizeHeight) {
            this.h = this.Items.h;
        }
    }
    _updateLastScrollIndex() {
        var {axis: axis, lengthDimension: lengthDimension} = this._directionPropNames;
        if (this.alwaysScroll) {
            this._lastScrollIndex = this.Items.children.length - 1;
            return;
        }
        var itemPos = this._isRow ? this.itemPosX : this.itemPosY;
        var scrollOffset = (this.Items.children[this.scrollIndex] || {
            [axis]: 0
        })[axis] + itemPos;
        var lastChild = this.Items.childList.last;
        var endOfLastChild = lastChild ? this._calcAxisPosition(lastChild) + lastChild[lengthDimension] : 0;
        if (endOfLastChild > this[lengthDimension]) {
            var lastScrollIndex;
            for (var i = this.Items.children.length - 1; i >= 0; i--) {
                var childPosition = this._calcAxisPosition(this.Items.children[i]);
                var canScrollToChild = childPosition + this[lengthDimension] - scrollOffset > endOfLastChild;
                if (canScrollToChild) {
                    lastScrollIndex = i;
                } else {
                    break;
                }
            }
            this._lastScrollIndex = lastScrollIndex;
            return;
        }
        if (this._lastScrollIndex > this.items.length) {
            this._lastScrollIndex = this.items.length - 1;
        }
    }
    _calcCrossDimensionSize(comp) {
        if (this._isRow) {
            return getH(comp);
        }
        if (this._isColumn) {
            return getW(comp);
        }
    }
    _calcAxisPosition(comp) {
        if (this._isRow) {
            return getX(comp);
        }
        if (this._isColumn) {
            return getY(comp);
        }
    }
    _transitionListener() {
        this.shouldSmooth = false;
        this.transitionDone();
    }
    _withAfterUpdate(element) {
        return watchForUpdates({
            element: element,
            watchProps: [ this._directionPropNames.crossAxis, "w", "h", "innerW", "innerH" ],
            sideEffect: this.queueRequestUpdate.bind(this)
        });
    }
    _performRender() {}
    _appendItem(item, shouldSmoothOverride) {
        this.shouldSmooth = shouldSmoothOverride !== null && shouldSmoothOverride !== void 0 ? shouldSmoothOverride : false;
        item.parentFocus = this.hasFocus();
        item = this.Items.childList.a(item);
        var {crossDimension: crossDimension} = this._directionPropNames;
        if (!item[crossDimension]) {
            var itemCrossSize = this._isRow ? this.renderHeight : this.renderWidth;
            item[crossDimension] = item[crossDimension] || itemCrossSize;
        }
        item = this._withAfterUpdate(item);
        return item;
    }
    _appendLazyItem(item) {
        var {lengthDimension: lengthDimension, axis: axis} = this._directionPropNames;
        var lastChild = this._Items.children[this.items.length - 1];
        var nextPosition = lastChild[lengthDimension] + lastChild[axis] + (lastChild.extraItemSpacing || 0) + this.style.itemSpacing;
        var appended = this._appendItem(item, true);
        appended[axis] = nextPosition;
        this._Items[lengthDimension] += nextPosition + item[lengthDimension];
    }
    $itemChanged() {
        this.queueRequestUpdate();
    }
    appendItems() {
        var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        this.shouldSmooth = false;
        if (this._lazyItems) {
            this._lazyItems.push(...items);
            return;
        }
        if (items.length > this.lazyUpCount + this.lazyUpCountBuffer) {
            this._lazyItems = items.splice(this.lazyUpCount + this.lazyUpCountBuffer);
        }
        items.forEach((item => this._appendItem(item)));
        this.requestUpdate();
        this._refocus();
    }
    appendItemsAt() {
        var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var idx = arguments.length > 1 ? arguments[1] : undefined;
        if (this._lazyItems && idx > this.items.length - 1) {
            var addAtIdx = idx - this.items.length;
            this._lazyItems.splice(addAtIdx, 0, ...items);
            return;
        }
        var {crossDimension: crossDimension, lengthDimension: lengthDimension, innerLengthDimension: innerLengthDimension} = this._directionPropNames;
        var addIndex = Number.isInteger(idx) ? idx : this.Items.children.length;
        this.shouldSmooth = false;
        this._lastAppendedIdx = addIndex;
        this._totalAddedLength = 0;
        items.forEach(((item, itemIdx) => {
            var newItem = _objectSpread(_objectSpread({}, this._withAfterUpdate(item)), {}, {
                parentFocus: this.hasFocus()
            });
            if (!item[crossDimension]) {
                newItem[crossDimension] = item[crossDimension] || this.Items[crossDimension];
            }
            this.Items.childList.addAt(newItem, addIndex + itemIdx);
            var itemLength = item[lengthDimension] || item[innerLengthDimension] || 0;
            var extraItemSpacing = item.extraItemSpacing || 0;
            this._totalAddedLength += itemLength + this.style.itemSpacing + extraItemSpacing;
        }));
        if (this.selectedIndex >= this._lastAppendedIdx) {
            this._selectedPastAdded = true;
            this._selectedIndex += items.length;
        }
        this.requestUpdate();
        this._refocus();
    }
    updatePositionOnAxis(item, position) {
        var {axis: axis} = this._directionPropNames;
        this.applySmooth(item, {
            [axis]: position
        }, {
            [axis]: [ position, this.style.itemTransition ]
        });
        if (!this.shouldSmooth) {
            this._updateTransitionTarget(item, axis, position);
        }
    }
    scrollTo(index) {
        var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.style.itemTransition.duration * 100;
        if (index == undefined) {
            return;
        }
        if (duration === 0) {
            this.selectedIndex = index;
            return;
        }
        for (var i = 0; i !== Math.abs(this.selectedIndex - index); i++) {
            setTimeout((() => {
                this.selectedIndex > index ? this.selectPrevious() : this.selectNext();
            }), duration * i);
        }
    }
    transitionDone() {}
    shouldScrollLeft() {
        return this._isRow && this._canScrollBack;
    }
    shouldScrollRight() {
        return this._isRow && this._canScrollNext;
    }
    shouldScrollUp() {
        return this._isColumn && this._canScrollBack;
    }
    shouldScrollDown() {
        return this._isColumn && this._canScrollNext;
    }
    get _directionPropNames() {
        return directionPropNames[this.direction];
    }
    get _canScrollBack() {
        var shouldScroll = false;
        if (this._lastScrollIndex) {
            shouldScroll = this.selectedIndex < this._lastScrollIndex;
            if (this._prevLastScrollIndex !== undefined && this._prevLastScrollIndex !== this._lastScrollIndex) {
                shouldScroll = true;
            }
        } else {
            shouldScroll = this.selectedIndex >= this.scrollIndex;
        }
        var itemsStartCoord = this._isRow ? this._itemsX : this._itemsY;
        return itemsStartCoord < (this._isRow ? this.itemPosX : this.itemPosY) && shouldScroll;
    }
    get _canScrollNext() {
        var {axis: axis, lengthDimension: lengthDimension} = this._directionPropNames;
        var lastChild = this.Items.childList.last;
        var endOfItemsPosition;
        if (this._isRow) {
            endOfItemsPosition = Math.abs(this._itemsX - this.w);
        }
        if (this._isColumn) {
            endOfItemsPosition = Math.abs(this._itemsY - this.h);
        }
        return this.selectedIndex > this.scrollIndex && endOfItemsPosition < lastChild[axis] + lastChild[lengthDimension];
    }
    get _isColumn() {
        return this.direction === "column";
    }
    get _isRow() {
        return this.direction === "row";
    }
    get _itemsX() {
        return getX(this.Items);
    }
    get _itemsY() {
        return getY(this.Items);
    }
    _getAlwaysScroll() {
        return this._alwaysScroll !== undefined ? this._alwaysScroll : this.style.alwaysScroll;
    }
    _getNeverScroll() {
        if (this.alwaysScroll) {
            return false;
        }
        return this._neverScroll !== undefined ? this._neverScroll : this.style.neverScroll;
    }
    _setScrollIndex(index) {
        return index >= 0 ? index : 0;
    }
    _getScrollIndex() {
        return this._scrollIndex !== undefined ? this._scrollIndex : this.style.scrollIndex;
    }
    _setLazyUpCountBuffer(buffer) {
        if (buffer < 0) {
            console.warn("lazyUpCountBuffer must be greater than or equal to 0. Setting to 0.");
            buffer = 0;
        }
        return buffer;
    }
    isFullyOnScreen() {
        var _this$parent;
        var {offsetX: offsetX = 0, offsetY: offsetY = 0} = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var focusmanager = (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.parent;
        if (focusmanager instanceof FocusManager) {
            offsetX += focusmanager.Items.transition("x").targetValue || 0;
            offsetY += focusmanager.Items.transition("y").targetValue || 0;
        }
        return super.isFullyOnScreen({
            offsetX: offsetX,
            offsetY: offsetY
        });
    }
}

var base$M = theme => ({
    itemSpacing: theme.layout.gutterX,
    scrollIndex: 0,
    alwaysScroll: false,
    neverScroll: false,
    itemTransition: _objectSpread(_objectSpread({}, theme.animation.standardEntrance), {}, {
        duration: theme.animation.duration.fast
    })
});

var styles$M = Object.freeze({
    __proto__: null,
    base: base$M
});

class Row extends NavigationManager {
    static get __componentName() {
        return "Row";
    }
    static get __themeStyle() {
        return styles$M;
    }
    static _template() {
        return _objectSpread(_objectSpread({}, super._template()), {}, {
            direction: "row"
        });
    }
    static get properties() {
        return [ ...super.properties, "lazyScroll", "startLazyScrollIndex", "stopLazyScrollIndex" ];
    }
    _isOnScreenForScrolling(child) {
        if (!child) return false;
        var x = getX(child);
        if (!Number.isFinite(x)) return false;
        var itemsTransitionX = this.getTransitionXTargetValue();
        var rowX = this.core.renderContext.px;
        var itemX = rowX + itemsTransitionX + x;
        var xModifier;
        if (child.transition("x")) {
            xModifier = child.x - child.transition("x").targetValue;
            itemX = itemX - xModifier;
        }
        return itemX >= rowX && itemX + child.w <= rowX + this.w;
    }
    _shouldScroll() {
        var prevIndex = this.Items.childList.getIndex(this.prevSelected);
        if (this.alwaysScroll || this.lazyScroll && (this.selectedIndex < this.startLazyScrollIndex || this.selectedIndex > this.stopLazyScrollIndex || prevIndex < this.startLazyScrollIndex && this.selectedIndex === this.startLazyScrollIndex || prevIndex > this.stopLazyScrollIndex && this.selectedIndex === this.stopLazyScrollIndex)) {
            return true;
        }
        var shouldScroll = this._selectedPastAdded;
        if (!shouldScroll && !this.neverScroll) {
            var isCompletelyOnScreen = this._isOnScreenForScrolling(this.selected);
            if (this.lazyScroll) {
                shouldScroll = !isCompletelyOnScreen;
            } else {
                var lastChild = this.Items.childList.last;
                shouldScroll = lastChild && (this.shouldScrollLeft() || this.shouldScrollRight() || !isCompletelyOnScreen);
            }
        }
        return shouldScroll;
    }
    _getPrependedOffset() {
        this._selectedPastAdded = false;
        return this.Items.x - this._totalAddedWidth;
    }
    _getLazyScrollX(prev) {
        var prevIndex = this.Items.childList.getIndex(this.prevSelected);
        if (this._selectedPastAdded) {
            return this._getPrependedOffset();
        }
        if (this.selectedIndex <= this.startLazyScrollIndex) {
            return this._getScrollX();
        } else if (this.selectedIndex >= this.stopLazyScrollIndex && this.selectedIndex < prevIndex) {
            var currItemsX = this.Items.x;
            return currItemsX + (this.prevSelected.w + this.style.itemSpacing + (this.selected.extraItemSpacing || 0));
        } else if (prev && this.selectedIndex > this.stopLazyScrollIndex) {
            var prevX = prev.x;
            return -prevX + this.prevSelected.w + this.style.itemSpacing + (this.selected.extraItemSpacing || 0) + this.itemPosX;
        } else if (prev) {
            var itemsContainerX;
            var _prevIndex = this.Items.childList.getIndex(prev);
            var selectedX = this.selected.x;
            if (_prevIndex === -1) {
                return;
            }
            if (_prevIndex > this.selectedIndex) {
                itemsContainerX = -selectedX + this.itemPosX;
            } else if (_prevIndex < this.selectedIndex) {
                itemsContainerX = this.w - selectedX - this.selected.w;
            }
            return itemsContainerX;
        }
        return this._getScrollX();
    }
    _getScrollX() {
        if (this._selectedPastAdded) {
            return this._getPrependedOffset();
        }
        var itemsContainerX;
        var itemIndex = this.selectedIndex - this.scrollIndex;
        itemIndex = itemIndex < 0 ? 0 : itemIndex;
        if (itemIndex === this._firstFocusableIndex()) {
            itemIndex = 0;
        }
        if (this.Items.children[itemIndex]) {
            itemsContainerX = this.Items.children[itemIndex].transition("x") ? -this.Items.children[itemIndex].transition("x").targetValue + this.itemPosX : -this.Items.children[itemIndex].x + this.itemPosX;
        }
        return itemsContainerX;
    }
    _render(next, prev) {
        if (this.plinko && prev && prev.selected) {
            next.selectedIndex = this._getIndexOfItemNear(next, prev);
        }
        this._prevLastScrollIndex = this._lastScrollIndex;
        var itemsContainerX;
        if (!this.Items.children.length) {
            itemsContainerX = this.itemPosX;
        } else if (this._shouldScroll()) {
            itemsContainerX = this.lazyScroll && prev ? this._getLazyScrollX(prev) : this._getScrollX();
        }
        if (itemsContainerX !== undefined) {
            this.updatePositionOnAxis(this.Items, itemsContainerX);
        }
        this.onScreenEffect(this.onScreenItems);
    }
    _performRender() {
        this._render(this.selected, this.prevSelected);
    }
    _isOnScreen(child) {
        if (!child) return false;
        return this._isComponentHorizontallyVisible(child);
    }
    onScreenEffect() {}
    get _totalAddedWidth() {
        return this._totalAddedLength;
    }
    _getLazyScroll() {
        if (this.alwaysScroll) {
            return false;
        }
        return this._lazyScroll !== undefined ? this._lazyScroll : this.style.lazyScroll;
    }
    _getNeverScroll() {
        if (this.alwaysScroll || this.lazyScroll) {
            return false;
        }
        return this._neverScroll !== undefined ? this._neverScroll : this.style.neverScroll;
    }
}

var base$L = theme => ({
    backgroundColor: theme.color.interactiveNeutral,
    radius: theme.radius.md,
    animation: {}
});

var tone$m = theme => ({
    inverse: {
        backgroundColor: theme.color.interactiveInverse
    }
});

var mode$f = theme => ({
    focused: {
        backgroundColor: theme.color.interactiveNeutralFocus,
        tone: {
            inverse: {
                backgroundColor: theme.color.interactiveInverseFocus
            }
        }
    },
    disabled: {
        backgroundColor: theme.color.fillNeutralDisabled
    }
});

var styles$L = Object.freeze({
    __proto__: null,
    base: base$L,
    mode: mode$f,
    tone: tone$m
});

class Surface extends Base$1 {
    static _template() {
        return {
            Background: {}
        };
    }
    static get __componentName() {
        return "Surface";
    }
    static get __themeStyle() {
        return styles$L;
    }
    static get properties() {
        return [];
    }
    static get tags() {
        return [ "Background" ];
    }
    get innerH() {
        return this.h;
    }
    get innerW() {
        return this.w;
    }
    get _radius() {
        return getMaxRoundRadius(this.style.radius, this.w, this.h);
    }
    _update() {
        this._updateLayout();
        this._updateScale();
    }
    _updateLayout() {
        this._Background.patch({
            texture: lng.Tools.getRoundRect(this.innerW - 2, this.innerH - 2, this._radius, 0, null, true, this.style.backgroundColor)
        });
    }
    _updateScale() {
        var scale = this._isFocusedMode ? this.getFocusScale(this.w, this.h) : this.getUnfocusScale(this.w, this.h);
        this.applySmooth(this, {
            scale: scale
        }, {
            scale: [ scale, this.style.animation ]
        });
    }
}

var base$K = theme => ({
    offsetY: theme.spacer.xxs,
    offsetX: 0,
    textStyle: theme.typography.body1
});

var tone$l = theme => ({
    neutral: {
        textStyle: {
            textColor: theme.color.fillNeutral
        }
    },
    inverse: {
        textStyle: {
            textColor: theme.color.fillInverse
        }
    },
    brand: {
        textStyle: {
            textColor: theme.color.fillBrand
        }
    }
});

var styles$K = Object.freeze({
    __proto__: null,
    base: base$K,
    tone: tone$l
});

var base$J = theme => ({
    textY: 0,
    iconWidth: theme.spacer.xxl + theme.spacer.xs,
    iconHeight: theme.spacer.xxl + theme.spacer.xs,
    contentSpacing: theme.spacer.md,
    marginBottom: 0,
    strikethroughRatio: .08,
    strikethroughColor: theme.color.textNeutral,
    textStyle: _objectSpread({}, theme.typography.body1),
    maxLines: 1,
    justify: "flex-start"
});

var styles$J = Object.freeze({
    __proto__: null,
    base: base$J
});

var isText = item => typeof item === "string" || !!item.text;

var isIcon = item => !!item.icon;

var isBadge = item => !!item.badge;

class InlineContent extends Base$1 {
    static get properties() {
        return [ "content", "contentProperties", "badgeY", "badgeProperties", "justify", "contentWrap", "customStyleMappings", "maxLines", "maxLinesSuffix" ];
    }
    static get __componentName() {
        return "InlineContent";
    }
    static get __themeStyle() {
        return styles$J;
    }
    static get aliasStyles() {
        return [ {
            prev: "iconH",
            curr: "iconHeight"
        }, {
            prev: "iconW",
            curr: "iconWidth"
        } ];
    }
    _construct() {
        super._construct();
        this._maxLinesSuffix = "..";
    }
    _update() {
        this._updateContent();
        this._waitForComponentLoad();
    }
    _updateContent() {
        this.childList.clear();
        if (this._shouldTruncate) {
            this.alpha = .001;
        }
        if (this._parsedContent && this._parsedContent.length) {
            this.patch({
                flex: {
                    direction: "row",
                    wrap: !!this.contentWrap,
                    justifyContent: this.justify != undefined ? this.justify : this.style.justify
                }
            });
            this._parsedContent.forEach(((item, index) => {
                var isLast = index === this._parsedContent.length - 1;
                var base = {
                    flexItem: _objectSpread(_objectSpread({}, this.contentProperties), {}, {
                        marginBottom: isLast ? 0 : this._marginBottom,
                        marginRight: isLast ? 0 : this.contentProperties.marginRight || this.style.contentSpacing
                    })
                };
                if (isText(item)) {
                    var nextItem = this._parsedContent[index + 1];
                    if (nextItem && isText(nextItem) || this.contentWrap && nextItem && nextItem.newline && this._parsedContent[index + 2] && isText(this._parsedContent[index + 2])) {
                        base.flexItem.marginRight = 0;
                    }
                    this.childList.a(this._createText(base, item));
                } else if (isIcon(item)) {
                    this.childList.a(this._createIcon(base, item));
                } else if (isBadge(item)) {
                    this.childList.a(this._createBadge(base, item.badge));
                } else if (item.newline && this.contentWrap) {
                    this.childList.a({
                        h: 0,
                        w: this.w
                    });
                }
            }));
        }
    }
    _waitForComponentLoad() {
        if (this.children.length) {
            Promise.all(this.children.map((child => new Promise((resolve => {
                if (child.h === 0 && child.w === this.w) {
                    resolve();
                } else {
                    child.on("txLoaded", resolve);
                }
            }))))).finally((() => this._contentLoaded()));
        } else {
            this.h = 0;
            this._contentLoaded();
        }
    }
    _notifyAncestors() {
        this.fireAncestors("$loadedInlineContent", this);
        this.signal("loadedInlineContent", this.finalW, this.multiLineHeight);
    }
    _contentLoaded() {
        if (this.children.length) {
            setTimeout((() => {
                this.multiLineHeight = this.finalH;
                if (this.flex && this.flex._layout && this.flex._layout._lineLayouter && this.flex._layout._lineLayouter._lines) {
                    var totalHeight = 0;
                    this.flex._layout._lineLayouter._lines.forEach((line => {
                        totalHeight += Object.entries(line.items).slice(line.startIndex, line.endIndex + 1).sort(((a, b) => b[1].h - a[1].h))[0][1].h;
                    }));
                    this.multiLineHeight = totalHeight;
                    if (this._shouldTruncate) {
                        this._renderMaxLines();
                    }
                    this._notifyAncestors();
                } else {
                    this._contentLoaded();
                }
            }), 10);
        } else {
            this._notifyAncestors();
        }
    }
    _renderMaxLines() {
        var childrenDimensions = this._calcChildrenDimensions();
        this.childList.clear();
        var renderedLastElement = false;
        childrenDimensions.forEach(((child, index) => {
            if (renderedLastElement) {
                return;
            }
            var nextChild = childrenDimensions[index + 1];
            if (!nextChild) {
                this.childList.add(child.component);
                return;
            }
            var isOnLastLine = child.line === this.maxLines;
            var isLastBeforeMaxLines = isOnLastLine && nextChild.line > this.maxLines;
            var canRenderLastWithSuffix = isLastBeforeMaxLines && child.hasSpaceForSuffix;
            var isLastWithSpaceForSuffix = isOnLastLine && child.hasSpaceForSuffix && !nextChild.hasSpaceForSuffix;
            var isLast = !nextChild || canRenderLastWithSuffix || isLastWithSpaceForSuffix;
            if (child.line <= this.maxLines) {
                if (isLast && index !== childrenDimensions.length - 1) {
                    this.childList.add(this._addSuffix(child));
                    renderedLastElement = true;
                } else {
                    this.childList.add(child.component);
                }
            }
        }));
        this.alpha = 1;
    }
    _calcChildrenDimensions() {
        var suffixW = measureTextWidth(_objectSpread(_objectSpread({}, this.style.textStyle), {}, {
            text: this.maxLinesSuffix
        }));
        var contentEndX = 0;
        var line = 1;
        return this.children.reduce(((acc, child) => {
            var component = child;
            var type, content, w;
            var isNewLineElement = child.w == this.w && child.h === 0;
            if (isNewLineElement) {
                line++;
                contentEndX = 0;
                var _data = {
                    type: "linebreak",
                    component: component,
                    content: content,
                    line: line,
                    hasSpaceForSuffix: true
                };
                acc.push(_data);
                return acc;
            }
            if (isText(child)) {
                type = "text";
                content = child.text.text;
                w = child.texture.getRenderWidth();
            } else if (isIcon(child)) {
                type = "icon";
                w = child.w;
            } else if (child.constructor.__componentName === "Badge") {
                type = "badge";
                w = child.w;
            }
            contentEndX += w;
            contentEndX += child.flexItem.marginRight;
            if (Math.ceil(contentEndX) >= this.w) {
                line++;
                contentEndX = w;
            }
            var hasSpaceForSuffix = Math.ceil(contentEndX) + suffixW <= this.w;
            var data = {
                type: type,
                component: component,
                content: content,
                line: line,
                hasSpaceForSuffix: hasSpaceForSuffix
            };
            acc.push(data);
            return acc;
        }), []);
    }
    _addSuffix(_ref16) {
        var {type: type, component: component, content: content} = _ref16;
        var negatedRightMargin = component.flexItem.marginRight * -1;
        var suffix;
        if (type === "text") {
            var {fontFace: fontFace, fontSize: fontSize, fontStyle: fontStyle, lineHeight: lineHeight, verticalAlign: verticalAlign} = component.text;
            suffix = this._createText({
                flexItem: this.contentProperties
            }, {
                text: "".concat(content.trim()).concat(this.maxLinesSuffix),
                style: {
                    fontFace: fontFace,
                    fontSize: fontSize,
                    fontStyle: fontStyle,
                    lineHeight: lineHeight,
                    verticalAlign: verticalAlign
                }
            });
        } else {
            this.childList.add(component);
            suffix = this._createText({
                flexItem: _objectSpread(_objectSpread({}, this.contentProperties), {}, {
                    marginLeft: negatedRightMargin
                })
            }, this.maxLinesSuffix);
        }
        return suffix;
    }
    _createIcon(base, iconProps) {
        var y = (this.textHeight > this.style.textStyle.lineHeight ? this.textHeight : this.style.textStyle.lineHeight) - this.style.iconHeight;
        return _objectSpread(_objectSpread({}, base), {}, {
            type: Icon,
            y: y,
            w: this.style.iconWidth,
            h: this.style.iconHeight,
            signals: {
                itemChanged: "_updateIconPosition"
            }
        }, iconProps);
    }
    _createText(base, text) {
        var textOverrideStyles = typeof text.style === "string" ? this.customStyleMappings[text.style] : text.style;
        var textComponent = _objectSpread(_objectSpread({}, base), {}, {
            y: this.textY !== undefined ? this.textY : this.style.textY,
            h: (textOverrideStyles === null || textOverrideStyles === void 0 ? void 0 : textOverrideStyles.lineHeight) || (textOverrideStyles === null || textOverrideStyles === void 0 ? void 0 : textOverrideStyles.fontSize) || this.textHeight,
            text: _objectSpread(_objectSpread(_objectSpread({}, this.style.textStyle), textOverrideStyles), {}, {
                text: text.text || text
            })
        });
        if ((textOverrideStyles === null || textOverrideStyles === void 0 ? void 0 : textOverrideStyles.textDecoration) === "line-through") {
            var textWidth = measureTextWidth(_objectSpread(_objectSpread(_objectSpread({}, this.style.textStyle), textOverrideStyles), {}, {
                text: text.text || text
            }));
            var strikethroughLine = {
                rect: true,
                w: textWidth,
                color: this.style.strikethroughColor || (textOverrideStyles === null || textOverrideStyles === void 0 ? void 0 : textOverrideStyles.textColor) || this.style.textStyle.textColor,
                h: textComponent.h * this.style.strikethroughRatio,
                y: textComponent.h / 2,
                mountY: 1
            };
            return {
                type: lng.Component,
                w: textWidth + textComponent.flexItem.marginRight,
                h: textComponent.h,
                children: [ _objectSpread({}, textComponent), _objectSpread({}, strikethroughLine) ]
            };
        }
        return textComponent;
    }
    _createBadge(base, badge) {
        return _objectSpread(_objectSpread(_objectSpread({}, base), {}, {
            y: this.badgeY || 0
        }, this.badgeProperties), {}, {
            type: Badge,
            title: badge,
            signals: {
                loadedBadge: "_loadedBadge"
            }
        });
    }
    _updateIconPosition(icon) {
        icon.y = this.style.textStyle.lineHeight - icon.h;
    }
    _loadedBadge(badge) {
        if (this.badgeY === undefined) {
            badge.y = this.style.textStyle.lineHeight - badge.h;
        }
    }
    _formatSpaces(parsedContent) {
        var whitespace = /(.+?\s+)/;
        return flatten((parsedContent || []).reduce(((acc, item) => {
            var parsed = item;
            if (isText(item)) {
                if (typeof item === "object") {
                    var formattedWords = item.text.split(whitespace).map((word => word && _objectSpread(_objectSpread({}, item), {}, {
                        text: word
                    })));
                    acc.push(...formattedWords);
                    return acc;
                }
                parsed = item.split(whitespace);
            }
            acc.push(parsed);
            return acc;
        }), [])).map(((item, index, arr) => {
            if (item === " ") return false;
            if (arr[index + 1] === " ") return item + " ";
            return item;
        })).filter(Boolean);
    }
    _setContent(content) {
        if (content !== this._content) {
            this._content = content;
            var parsedContent = this._content;
            if (content && !Array.isArray(content)) {
                parsedContent = parseInlineContent(content);
            }
            this._parsedContent = this._formatSpaces(parsedContent);
        }
        return content;
    }
    _setBadgeProperties(badgeProperties) {
        if (typeof badgeProperties === "object") {
            return badgeProperties;
        }
    }
    _getBadgeProperties() {
        return this._badgeProperties || {};
    }
    _setContentProperties(contentProperties) {
        if (typeof contentProperties === "object") {
            return contentProperties;
        }
    }
    _getContentProperties() {
        return this._contentProperties || {};
    }
    _setCustomStyleMappings(customStyleMappings) {
        if (typeof customStyleMappings === "object") {
            return customStyleMappings;
        }
    }
    _getCustomStyleMappings() {
        return this._customStyleMappings || {};
    }
    _setMaxLines(maxLines) {
        return maxLines >= 1 ? Math.floor(maxLines) : 0;
    }
    get textHeight() {
        return this.style.textStyle.lineHeight || this.style.textStyle.fontSize;
    }
    get _marginBottom() {
        if (this.contentProperties.marginBottom !== undefined) {
            return this.contentProperties.marginBottom;
        }
        if (this.style.marginBottom) {
            return this.style.marginBottom;
        }
        return 0;
    }
    get _shouldTruncate() {
        return this.contentWrap && this.maxLines;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        if (this._announce) {
            return this._announce;
        }
        var announce = this._parsedContent && this._parsedContent.reduce(((announce, item) => {
            if (typeof item === "string") {
                announce += item;
            } else if (item.announce) {
                announce += item.announce;
            } else if (item.text) {
                var _item$style;
                announce += item.text;
                if (((_item$style = item.style) === null || _item$style === void 0 ? void 0 : _item$style.textDecoration) === "line-through") {
                    announce += "strikethrough";
                }
            } else if (item.title) {
                announce += item.title;
            } else if (item.badge) {
                announce += item.badge;
            }
            return announce + " ";
        }), "");
        return announce ? announce.replace(/\s+(?=\s)|\s$/g, "") : "";
    }
}

var base$I = theme => ({
    fadeWidth: 100,
    offset: theme.spacer.xxl,
    shouldSmooth: false,
    textStyle: theme.typography.body1
});

var styles$I = Object.freeze({
    __proto__: null,
    base: base$I
});

class FadeShader extends lng.shaders.WebGLDefaultShader {
    constructor(context) {
        super(context);
        this._margin = {
            left: 0,
            right: 0
        };
    }
    set positionLeft(v) {
        this._positionLeft = v;
    }
    set positionRight(v) {
        this._positionRight = v;
    }
    setupUniforms(operation) {
        super.setupUniforms(operation);
        var owner = operation.shaderOwner;
        if (this._positionLeft === 0) {
            this._positionLeft = .001;
        }
        if (this._positionRight === 0) {
            this._positionRight = .001;
        }
        var renderPrecision = this.ctx.stage.getRenderPrecision();
        this._setUniform("margin", [ this._positionLeft * renderPrecision, this._positionRight * renderPrecision ], this.gl.uniform1fv);
        this._setUniform("resolution", new Float32Array([ owner._w * renderPrecision, owner._h * renderPrecision ]), this.gl.uniform2fv);
    }
}

FadeShader.fragmentShaderSource = "\n  #ifdef GL_ES\n  # ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  # else\n  precision lowp float;\n  # endif\n  #endif\n\n  #define PI 3.14159265359\n\n  varying vec2 vTextureCoord;\n  varying vec4 vColor;\n\n  uniform sampler2D uSampler;\n  uniform vec2 resolution;\n  uniform float margin[2];\n\n  void main() {\n      vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n      vec2 halfRes = 0.5 * resolution.xy;\n      vec2 point = vTextureCoord.xy * resolution;\n\n\n      vec2 pos1 = vec2(point.x, point.y);\n      vec2 pos2 = pos1;\n      pos2.x += margin[0];\n\n      vec2 d = pos2 - pos1;\n      float t = dot(pos1, d) / dot(d, d);\n      t = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));\n\n      vec2 pos3 = vec2(vTextureCoord.x * resolution.x, vTextureCoord.y);\n      pos3.x -= resolution.x - margin[1];\n      vec2 pos4 = vec2(vTextureCoord.x + margin[1], vTextureCoord.y);\n\n      vec2 d2 = pos4 - pos3;\n      float t2 = dot(pos3, d2) / dot(d2, d2);\n      t2 = smoothstep(0.0, 1.0, clamp(t2, 0.0, 1.0));\n\n      color = mix(vec4(0.0), color, t);\n      color = mix(color, vec4(0.0), t2);\n\n      gl_FragColor = color;\n  }\n";

class Marquee extends Base$1 {
    static _template() {
        return {
            ContentClipper: {
                boundsMargin: [],
                ContentBox: {
                    Content: {},
                    ContentLoopTexture: {}
                }
            }
        };
    }
    static get __componentName() {
        return "Marquee";
    }
    static get __themeStyle() {
        return styles$I;
    }
    static get tags() {
        return [ "ContentClipper", {
            name: "ContentBox",
            path: "ContentClipper.ContentBox"
        }, {
            name: "Content",
            path: "ContentClipper.ContentBox.Content"
        }, {
            name: "ContentLoopTexture",
            path: "ContentClipper.ContentBox.ContentLoopTexture"
        } ];
    }
    static get properties() {
        return [ "autoStart", "title", "contentTexture", "color", "centerAlign", "delay", "repeat", "overrideLoopX" ];
    }
    static get aliasStyles() {
        return [ {
            prev: "fadeW",
            curr: "fadeWidth"
        } ];
    }
    _construct() {
        super._construct();
        this._scrolling = false;
        this._autoStart = false;
        this._centerAlign = false;
    }
    _init() {
        this._Content.on("txLoaded", this._updateContentTexture.bind(this));
        super._init();
    }
    _updateContentTexture() {
        var restartScrolling = this._restartScrolling;
        this.stopScrolling();
        if (!this._currentTexture.h) {
            this._ContentClipper.h = this._currentTexture.text && this._currentTexture.text.lineHeight ? this._currentTexture.text.lineHeight : this._Content.finalH;
        }
        if (this._shouldClip) {
            this._updateShader();
        } else {
            this._ContentClipper.shader = null;
            this._positionTexture();
        }
        restartScrolling && this.startScrolling();
        this.signal("marqueeContentLoaded");
    }
    _update() {
        this._updateColor();
        this._updateTexture();
        this._updateShader();
        this._restartScrolling && this.startScrolling();
    }
    get _restartScrolling() {
        return this.autoStart || this._scrolling || this._shouldTryScrolling;
    }
    _updateColor() {
        if (this.color) {
            this._Content.smooth = {
                color: utils$1.getValidColor(this.color)
            };
        }
    }
    get _currentTexture() {
        return this._Content.text || this._Content.texture || {};
    }
    _updateTexture() {
        var content = {
            rtt: true
        };
        if (this.contentTexture) {
            content.texture = this.contentTexture;
        } else if (this.title) {
            content.text = _objectSpread(_objectSpread(_objectSpread({}, this.style.textStyle), this.title), {}, {
                text: this.textContent
            });
        }
        this.patch({
            ContentClipper: {
                w: this.w + 14,
                ContentBox: {
                    Content: content,
                    ContentLoopTexture: {}
                }
            }
        });
        this.signal("marqueeContentLoaded");
    }
    _updateShader() {
        this._ContentClipper.patch({
            w: this.w > 0 ? this.w + this.style.fadeWidth / 2 : 0,
            shader: {
                type: FadeShader,
                positionLeft: 0,
                positionRight: this.style.fadeWidth
            },
            rtt: true
        });
    }
    _updateAnimation() {
        this._scrollAnimation && this._scrollAnimation.stopNow();
        this._scrollAnimation = this.animation({
            duration: this._loopWidth / 50,
            delay: isNaN(this.delay) ? 1.5 : this.delay,
            repeat: isNaN(this.repeat) ? -1 : this.repeat,
            actions: [ {
                t: "ContentBox",
                p: "x",
                v: {
                    sm: 0,
                    0: {
                        v: 0
                    },
                    .5: {
                        v: -(this._loopWidth + this.style.offset)
                    }
                }
            }, {
                t: "ContentClipper",
                p: "shader.positionLeft",
                v: {
                    sm: 0,
                    0: {
                        v: 0
                    },
                    .1: {
                        v: this.style.fadeWidth
                    },
                    .4: {
                        v: this.style.fadeWidth
                    },
                    .5: {
                        v: 0
                    }
                }
            } ]
        });
    }
    _positionTexture() {
        var x = this._shouldCenter() ? (this.w - this._textRenderedW) / 2 : 0;
        if (this.style.shouldSmooth) {
            this._ContentBox.smooth = {
                x: x
            };
        } else {
            this._ContentBox.x = x;
        }
    }
    startScrolling() {
        this._Content.off("txLoaded", this.startScrolling.bind(this));
        this._shouldTryScrolling = true;
        if (this._textRenderedW === 0) {
            this._Content.on("txLoaded", this.startScrolling.bind(this));
        }
        if (this._shouldClip) {
            this._scrolling = true;
            this._ContentLoopTexture.x = this._loopWidth + this.style.offset;
            this._ContentLoopTexture.texture = this._Content.getTexture();
            this._updateAnimation();
            this._scrollAnimation.start();
        } else {
            this._scrolling = false;
        }
    }
    stopScrolling() {
        this._shouldTryScrolling = false;
        this._scrolling = false;
        if (this._scrollAnimation) {
            this._scrollAnimation.stopNow();
            this._ContentLoopTexture.texture = null;
        }
    }
    get _shouldClip() {
        return this._textRenderedW > this.w - this.style.fadeWidth / 4;
    }
    _shouldCenter() {
        return this._centerAlign || this._Content.text && this._Content.text.textAlign === "center";
    }
    _setAutoStart(autoStart) {
        if (this.autoStart && !autoStart) {
            this._updateContentTexture();
        }
        return autoStart;
    }
    _setCenterAlign(center) {
        this._centerAlign = center;
        this._updateContentTexture();
        return center;
    }
    get textContent() {
        var _ref17, _this$title$text, _this$title;
        return (_ref17 = (_this$title$text = (_this$title = this.title) === null || _this$title === void 0 ? void 0 : _this$title.text) !== null && _this$title$text !== void 0 ? _this$title$text : this.title) !== null && _ref17 !== void 0 ? _ref17 : "";
    }
    get _loopWidth() {
        return this.overrideLoopX || this._textRenderedW;
    }
    get _textRenderedW() {
        return this._Content.renderWidth;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || this.title && this.title.text;
    }
}

var lightningTextDefaults = Object.entries(Object.getOwnPropertyDescriptors(lng.textures.TextTexture.prototype)).reduce(((acc, _ref18) => {
    var [prop] = _ref18;
    var value = lng.textures.TextTexture.prototype[prop];
    if (prop.startsWith("_") || [ "undefined", "function" ].includes(typeof value)) return acc;
    return _objectSpread({
        [prop]: value
    }, acc);
}), {});

class TextBox extends Base$1 {
    static _template() {
        return {
            alpha: .001
        };
    }
    static get __componentName() {
        return "TextBox";
    }
    static get __themeStyle() {
        return styles$K;
    }
    static get tags() {
        return [ "InlineContent", "Marquee", "Text" ];
    }
    static get properties() {
        return [ ...InlineContent.properties, "content", "fixed", "marquee", "marqueeProps", "hideOnLoad" ];
    }
    _setDimensions(w, h) {
        var width = w;
        var height = h;
        if (!this._isInlineContent) {
            width = this._Text.texture.getRenderWidth();
            height = this._Text.texture.getRenderHeight();
        }
        var sizeChanged = this.w !== width || this.h !== height;
        if (width && height && sizeChanged) {
            this.h = height;
            if (!this.fixed) {
                this.w = width;
            }
            if (!this.hideOnLoad && this.alpha < 1) {
                this.alpha = 1;
            }
            this._notifyAncestors();
        }
    }
    _setContent(content) {
        this._isInlineContent = false;
        if (Array.isArray(content) || utils$1.isMarkupString(content)) {
            this._isInlineContent = true;
        }
        if ("string" !== typeof content && !this._isInlineContent) {
            return "";
        }
        return content;
    }
    get title() {
        return this._content;
    }
    _notifyAncestors() {
        var w = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.w;
        var h = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.h;
        this.fireAncestors("$itemChanged");
        this.signal("textBoxChanged", {
            w: w,
            h: h
        });
    }
    _construct() {
        super._construct();
        this._marqueeContentListenerAttached = false;
        this._marqueeOverrideLoopX = undefined;
        this._resetMarqueePromise();
    }
    _update() {
        if (!this.content) {
            if (this._Text || this._InlineContent) {
                this.w = this.h = 0;
                this._notifyAncestors();
                this._updateMarquee();
                this.patch({
                    Text: undefined,
                    InlineContent: undefined
                });
            }
            return;
        }
        this._isInlineContent ? this._updateInlineContent() : this._updateText();
        this._updateMarquee();
    }
    _updateInlineContent() {
        this.patch({
            Text: undefined
        });
        var inlineContentPatch = InlineContent.properties.reduce(((acc, prop) => {
            if (this[prop] != undefined) {
                acc[prop] = this[prop];
            }
            return acc;
        }), {
            style: _objectSpread(_objectSpread({}, this.style), {}, {
                textStyle: this._textStyleSet
            })
        });
        if (this._textStyleSet.wordWrapWidth) {
            inlineContentPatch.w = this._textStyleSet.wordWrapWidth;
            inlineContentPatch.rtt = true;
        }
        if (this._textStyleSet.maxLines) {
            inlineContentPatch.maxLines = this._textStyleSet.maxLines;
        }
        if (this._textStyleSet.maxLinesSuffix) {
            inlineContentPatch.maxLinesSuffix = this._textStyleSet.maxLinesSuffix;
        }
        this.patch({
            alpha: 1,
            InlineContent: _objectSpread(_objectSpread({
                type: InlineContent,
                w: this.w
            }, inlineContentPatch), {}, {
                signals: {
                    loadedInlineContent: "_setDimensions"
                }
            })
        });
    }
    _updateText() {
        this.patch({
            InlineContent: undefined
        });
        if (!this._Text) {
            this.patch({
                Text: {}
            });
            this._Text.on("txLoaded", this._setDimensions.bind(this));
        }
        var fontStyle = this._textStyleSet;
        if (this._Text) {
            this._Text.patch({
                y: this.style.offsetY,
                x: this.style.offsetX,
                text: _objectSpread(_objectSpread({}, lightningTextDefaults), fontStyle)
            });
        }
    }
    set marqueeOverrideLoopX(v) {
        this._marqueeOverrideLoopX = v;
        if (this._Marquee) this._Marquee.overrideLoopX = this._marqueeOverrideLoopX;
        this._resolveAwaitMarqueeOverrideX();
    }
    get marqueeOverrideLoopX() {
        return this._marqueeOverrideLoopX;
    }
    _resetMarqueePromise() {
        this._awaitMarqueeOverrideX = new Promise(((resolve, reject) => {
            this._resolveAwaitMarqueeOverrideX = resolve;
            this._rejectAwaitMarqueeOverrideX = reject;
        }));
    }
    _loadedMarqueeContent() {
        this.signal("willMarquee", this._Marquee);
    }
    _updateMarquee() {
        if (this._Marquee && !this.marquee) {
            this._toggleMarquee(this._contentTag);
        }
        if (this.marquee) {
            this._resetMarqueePromise();
            var marqueePatch = _objectSpread(_objectSpread({}, this.marqueeProps), {}, {
                w: this._textStyleSet.wordWrapWidth || this.w,
                h: this.h,
                y: this.style.offsetY,
                x: this.style.offsetX,
                signals: {
                    marqueeContentLoaded: "_loadedMarqueeContent"
                }
            });
            if (!this._Marquee) {
                marqueePatch.type = Marquee;
            }
            if (this._isInlineContent) {
                this._InlineContent.w = 0;
                marqueePatch.title = undefined;
                marqueePatch.contentTexture = this._contentTag.getTexture();
                marqueePatch.w = this._textStyleSet.wordWrapWidth || this.w;
            } else {
                marqueePatch.contentTexture = undefined;
                marqueePatch.title = _objectSpread(_objectSpread({
                    text: this._contentTag.text.text
                }, this._textStyleSet), {}, {
                    wordWrapWidth: 0,
                    maxLines: 1
                });
            }
            this.patch({
                Marquee: marqueePatch
            });
            if (!this._marqueeContentListenerAttached) {
                this._marqueeContentListenerAttached = true;
            }
            if ("undefined" !== typeof this._marqueeOverrideLoopX) {
                this._awaitMarqueeOverrideX.then((() => {
                    this._toggleMarquee(this._contentTag);
                }));
            } else {
                this._toggleMarquee(this._contentTag);
            }
        }
    }
    _getMarqueeProps() {
        var _this$_marqueeProps;
        return (_this$_marqueeProps = this._marqueeProps) !== null && _this$_marqueeProps !== void 0 ? _this$_marqueeProps : {};
    }
    get _textStyleSet() {
        var fontStyle = _objectSpread(_objectSpread({}, this.theme.typography.body1), null !== this.style.textStyle && "object" === typeof this.style.textStyle && Object.keys(this.style.textStyle) ? this.style.textStyle : this.theme.typography[this.style.textStyle]);
        this.constructor.properties.forEach((prop => {
            if ("fontStyle" !== prop && "undefined" !== typeof this["_".concat(prop)]) {
                var key = "content" === prop ? "text" : prop;
                fontStyle[key] = this["_".concat(prop)];
            }
        }));
        if (this.w && !this._isInlineContent && !this.style.textStyle.wordWrapWidth && this.fixed) {
            fontStyle.wordWrapWidth = this.w;
        }
        return fontStyle;
    }
    get _contentTag() {
        return this._isInlineContent ? this._InlineContent : this._Text;
    }
    _toggleMarquee(contentTag) {
        if (this.marquee) {
            if (contentTag) {
                contentTag.alpha = .001;
            }
            if (this._Marquee) {
                this._Marquee.alpha = 1;
                this._Marquee.startScrolling();
            }
        } else {
            if (contentTag) {
                contentTag.alpha = 1;
            }
            if (this._Marquee) {
                this._Marquee.alpha = .001;
                this._Marquee.stopScrolling();
            }
        }
    }
    toggleMarquee() {
        this._toggleMarquee(this._contentTag);
    }
    get announce() {
        return this._announce || (this._isInlineContent && this._InlineContent ? this._InlineContent.announce : this.content);
    }
    set announce(announce) {
        super.announce = announce;
    }
    set smooth(v) {
        contextInstance.warn("warning: value smoothing is known to cause bugs with the TextBox - patch updated values instead.");
        super.smooth = v;
    }
}

class Button extends Surface {
    static get __componentName() {
        return "Button";
    }
    static get __themeStyle() {
        return styles$O;
    }
    static get properties() {
        return [ "fixed", "justify", "prefix", "suffix", "title" ];
    }
    static get aliasStyles() {
        return [ {
            prev: "titlePadding",
            curr: "contentSpacing"
        } ];
    }
    static get tags() {
        return [ ...super.tags, "Content", {
            name: "TextWrapper",
            path: "Content.TextWrapper"
        }, {
            name: "Title",
            path: "Content.TextWrapper.Title"
        }, {
            name: "Prefix",
            path: "Content.Prefix"
        }, {
            name: "Suffix",
            path: "Content.Suffix"
        } ];
    }
    static _template() {
        return _objectSpread(_objectSpread({}, super._template()), {}, {
            Content: {
                mount: .5,
                x: w => w / 2,
                y: h => h / 2,
                zIndex: 2
            }
        });
    }
    _update() {
        this._updatePrefix();
        this._updateTitle();
        this._updateSuffix();
        this._updateAllPositioning();
        this._updateTruncation();
    }
    _updateAllPositioning() {
        this._updatePositions();
        this._updateContentDimensions();
        this._updateSurfaceDimensions();
        this._updateContentPosition();
        super._update();
    }
    $itemChanged() {
        this._updateAllPositioning();
        this._updateTruncation();
    }
    _onTitleTextBoxChanged() {
        this._updateAllPositioning();
    }
    _updatePositions() {
        if (this._hasPrefix && this._Prefix !== undefined) {
            this._Prefix.x = this._prefixX;
        }
        if (this._hasTitle) {
            this._TextWrapper.x = this._titleX;
        }
        if (this._hasSuffix && this._Suffix !== undefined) {
            this._Suffix.x = this._suffixX;
        }
    }
    _updatePrefix() {
        var prefixString = JSON.stringify(this.prefix);
        if (this.prefix) {
            var prefixPatch = {
                style: {
                    itemSpacing: this.style.itemSpacing
                }
            };
            if (!this._Prefix) {
                prefixPatch = _objectSpread(_objectSpread({}, this._rowProps), prefixPatch);
            }
            this._Content.patch({
                Prefix: prefixPatch
            });
            this._updatePrefixSuffixStyles("prefix");
        } else {
            this._Content.patch({
                Prefix: undefined
            });
        }
        this._prevPrefix = prefixString;
    }
    _updatePrefixSuffixStyles() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "prefix";
        var map = {
            prefix: {
                tag: this._Prefix,
                prop: this.prefix,
                prevProp: this._prevPrefix
            },
            suffix: {
                tag: this._Suffix,
                prop: this.suffix,
                prevProp: this._prevSuffix
            }
        };
        var {tag: tag, prop: prop} = map[type];
        var {prevProp: prevProp} = map[type];
        var propString = JSON.stringify(prop);
        if (propString !== prevProp) {
            prevProp = propString;
            tag.items = this._addButtonProps(prop);
        } else {
            tag.Items.children.forEach(((item, idx) => {
                item.color = Array.isArray(prop) ? prop[idx].color : prop.color;
                item.style = _objectSpread(_objectSpread({}, item.style), {}, {
                    color: this.style.contentColor
                });
            }));
        }
    }
    _updateTitle() {
        if (this._hasTitle) {
            var titlePatch = {
                content: this.title,
                style: {
                    textStyle: this.style.textStyle
                }
            };
            if (!this._Title) {
                titlePatch = _objectSpread({
                    type: TextBox,
                    mountY: .5,
                    y: h => h / 2,
                    signals: {
                        textBoxChanged: "_onTitleTextBoxChanged"
                    }
                }, titlePatch);
            }
            this._Content.patch({
                TextWrapper: {
                    mountY: .5,
                    Title: titlePatch
                }
            });
        } else {
            this._Content.patch({
                TextWrapper: {
                    Title: undefined
                }
            });
        }
    }
    _updateSuffix() {
        if (this.suffix) {
            var suffixPatch = {
                style: {
                    itemSpacing: this.style.itemSpacing
                }
            };
            if (!this._Suffix) {
                suffixPatch = _objectSpread(_objectSpread({}, this._rowProps), suffixPatch);
            }
            this._Content.patch({
                Suffix: suffixPatch
            });
            this._updatePrefixSuffixStyles("suffix");
        } else {
            this._Content.patch({
                Suffix: undefined
            });
        }
    }
    _updateTruncation() {
        if (this._Title) {
            this._Title.patch({
                style: {
                    textStyle: _objectSpread(_objectSpread({}, this.style.textStyle), {}, {
                        wordWrap: this.fixed,
                        wordWrapWidth: this.fixed ? this._fixedWordWrapWidth : 0
                    })
                }
            });
        }
    }
    _updateContentDimensions() {
        var contentDimensionsPatch = {};
        var y = this.h / 2;
        if (this._Content.transition("w").targetValue !== this._contentW) {
            this._Content.w = this._contentW;
        }
        if (this._Content.y !== y) {
            contentDimensionsPatch.y = y;
        }
        if (Object.keys(contentDimensionsPatch).length > 0) {
            this._Content.patch(contentDimensionsPatch);
        }
    }
    _updateContentPosition() {
        this._Content.patch(this._contentProps);
    }
    _updateSurfaceDimensions() {
        var newWidth = this.w;
        if (this.fixed) {
            newWidth = this._w;
        } else {
            newWidth = this._calcDynamicWidth();
        }
        if (newWidth !== this.w) {
            this.w = newWidth;
        }
        if (!this._hSetByUser && !this.style.h) {
            this._h = this.style.textStyle.lineHeight + this.style.paddingY * 2;
        }
        this.fireAncestors("$itemChanged");
    }
    _calcDynamicWidth() {
        return !this._hasTitle && (this._hasPrefix || this._hasSuffix) || this._Title && !this._Title.visible && (this._hasPrefix || this._hasSuffix) ? this._contentW + this._paddingX : Math.max(this._contentW + this._paddingX, this.style.minWidth);
    }
    _addButtonProps(arr) {
        var items = Array.isArray(arr) ? arr : [ arr ];
        return items.map((item => _objectSpread(_objectSpread(_objectSpread({}, this._buttonProps), item), {}, {
            style: _objectSpread({
                color: this.style.contentColor
            }, item.style)
        })));
    }
    _getJustify() {
        return !!this._justify ? this._justify : this.style.justify;
    }
    get _contentProps() {
        var mountX;
        var x;
        switch (this.justify) {
          case "left":
            mountX = 0;
            x = this._paddingLeft;
            break;

          case "right":
            mountX = 1;
            x = this.w - this._paddingRight;
            break;

          case "center":
          default:
            mountX = .5;
            x = this.w / 2;
            break;
        }
        return {
            mountX: mountX,
            x: x
        };
    }
    get _buttonProps() {
        return {
            centerInParent: true,
            mode: this.mode
        };
    }
    get _hasPrefix() {
        return !!(this.prefix && Object.keys(this.prefix).length);
    }
    get _prefixW() {
        return this._hasPrefix && this._Prefix !== undefined ? this._Prefix.w : 0;
    }
    get _prefixX() {
        return 0;
    }
    get _hasTitle() {
        return !!this.title;
    }
    get _titleW() {
        if (this._hasTitle && this._Title && this._Title._Text && this._Title.visible) {
            return this._Title.w;
        }
        return 0;
    }
    get _titleX() {
        return this._hasPrefix ? this._prefixW + this.style.contentSpacing : 0;
    }
    get _hasSuffix() {
        return !!(this.suffix && Object.keys(this.suffix).length);
    }
    get _suffixW() {
        return this._hasSuffix && this._Suffix !== undefined ? this._Suffix.w : 0;
    }
    get _suffixX() {
        if (this._hasTitle) {
            return this._titleW + this._TextWrapper.x + this.style.contentSpacing;
        } else if (this._hasPrefix) {
            return this._prefixW + this.style.itemSpacing;
        }
        return 0;
    }
    get _contentW() {
        if (this._hasSuffix) {
            return this._suffixX + this._suffixW;
        } else if (this._hasTitle && this._Title && this._Title.visible) {
            return this._titleX + this._titleW;
        } else if (this._hasPrefix) {
            return this._prefixX + this._prefixW;
        }
        return 0;
    }
    get _rowProps() {
        return {
            type: Row,
            mountY: .5,
            autoResizeHeight: true,
            autoResizeWidth: true
        };
    }
    get _totalTitlePaddingX() {
        var totalTitlePadding = 0;
        if (this._hasPrefix) {
            totalTitlePadding += this.style.contentSpacing;
        }
        if (this._hasSuffix) {
            totalTitlePadding += this.style.contentSpacing;
        }
        return totalTitlePadding;
    }
    get _fixedWordWrapWidth() {
        var {w: w, _paddingX: _paddingX, _prefixW: _prefixW, _suffixW: _suffixW, _totalTitlePaddingX: _totalTitlePaddingX} = this;
        var nonTextSpace = _paddingX + _prefixW + _suffixW + _totalTitlePaddingX;
        return Math.max(1, w - nonTextSpace);
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        if (this._announce) {
            return this._announce;
        }
        var announce = [];
        if (this.title) {
            announce.push(this.title);
        }
        announce.push(this._announceComponentName);
        if (this._hasPrefix && this._Prefix.items.length) {
            announce.push(...this._Prefix.items.map((item => item.announce)));
        }
        if (this._hasSuffix && this._Suffix.items.length) {
            announce.push(...this._Suffix.items.map((item => item.announce)));
        }
        return announce;
    }
    get _announceComponentName() {
        return Button.__componentName;
    }
    get _paddingX() {
        return this._paddingLeft + this._paddingRight;
    }
    get _paddingLeft() {
        return this._hasTitle ? this.style.paddingX : this.style.paddingXNoTitle;
    }
    get _paddingRight() {
        return this._hasTitle ? this.style.paddingX : this.style.paddingXNoTitle;
    }
}

var base$H = theme => ({
    minWidth: getWidthByColumnSpan(theme, 1),
    paddingX: theme.spacer.xxl,
    paddingXNoTitle: theme.spacer.lg,
    paddingY: theme.spacer.lg,
    textStyle: theme.typography.button2
});

var styles$H = Object.freeze({
    __proto__: null,
    base: base$H
});

class ButtonSmall extends Button {
    static get __componentName() {
        return "ButtonSmall";
    }
    static get __themeStyle() {
        return styles$H;
    }
}

var base$G = theme => ({
    height: theme.spacer.xxl * 12,
    paddingHorizontal: theme.spacer.xl,
    paddingVertical: theme.spacer.xl,
    radius: theme.radius.md,
    titleTextStyle: _objectSpread(_objectSpread({}, theme.typography.headline1), {}, {
        wordWrap: true,
        maxLines: 2,
        textColor: theme.color.textNeutral
    }),
    width: utils$1.getWidthByUpCount(theme, 6)
});

var mode$e = theme => ({
    focused: {
        tone: {
            neutral: {
                backgroundColor: theme.color.interactiveNeutralFocusSoft
            },
            inverse: {
                backgroundColor: theme.color.interactiveInverseFocusSoft
            },
            brand: {
                backgroundColor: theme.color.interactiveBrandFocusSoft
            }
        }
    },
    disabled: {
        titleTextStyle: {
            textColor: theme.color.textNeutralDisabled
        }
    }
});

var styles$G = Object.freeze({
    __proto__: null,
    base: base$G,
    mode: mode$e
});

class Card extends Surface {
    static get __componentName() {
        return "Card";
    }
    static get __themeStyle() {
        return styles$G;
    }
    static get properties() {
        return [ ...super.properties, "title" ];
    }
    static get tags() {
        return [ ...super.tags, "Title" ];
    }
    static _template() {
        return _objectSpread(_objectSpread({}, super._template()), {}, {
            Title: {
                type: TextBox,
                signals: {
                    textBoxChanged: "_updatePositions"
                }
            }
        });
    }
    _update() {
        super._update();
        this._updateTitle();
        this._updatePositions();
    }
    _updatePositions() {
        this._updateTitlePosition();
    }
    _updateTitle() {
        this._Title.patch({
            content: this.title,
            style: {
                textStyle: _objectSpread(_objectSpread({}, this.style.titleTextStyle), {}, {
                    wordWrapWidth: this._calculateTextWidth()
                })
            }
        });
    }
    _calculateTextWidth() {
        return this.w - this.style.paddingHorizontal * 2;
    }
    _updateTitlePosition() {
        this._Title.x = this.style.paddingHorizontal;
        this._Title.y = this.style.paddingVertical;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || this._Title && this._Title.announce;
    }
}

var base$F = theme => ({
    titleTextStyle: _objectSpread(_objectSpread({}, theme.typography.headline3), {}, {
        wordWrap: true,
        maxLines: 2,
        textColor: theme.color.textNeutral
    }),
    descriptionTextStyle: _objectSpread(_objectSpread({}, theme.typography.body2), {}, {
        textColor: theme.color.textNeutral,
        wordWrap: true,
        maxLines: 3
    }),
    detailsTextStyle: _objectSpread(_objectSpread({}, theme.typography.body3), {}, {
        textColor: theme.color.textNeutral,
        wordWrap: true,
        maxLines: 1
    })
});

var mode$d = theme => ({
    disabled: {
        descriptionTextStyle: {
            textColor: theme.color.textNeutralDisabled
        },
        detailsTextStyle: {
            textColor: theme.color.textNeutralDisabled
        }
    }
});

var styles$F = Object.freeze({
    __proto__: null,
    base: base$F,
    mode: mode$d
});

class CardTitle extends Card {
    static get __componentName() {
        return "CardTitle";
    }
    static get __themeStyle() {
        return styles$F;
    }
    static get tags() {
        return [ ...super.tags, "Description", "Details" ];
    }
    static get properties() {
        return [ ...super.properties, "description", "details" ];
    }
    static _template() {
        return _objectSpread(_objectSpread({}, super._template()), {}, {
            Description: {
                type: TextBox,
                signals: {
                    textBoxChanged: "_updatePositions"
                }
            },
            Details: {
                type: TextBox,
                mountY: 1
            }
        });
    }
    _update() {
        super._update();
        this._updateDescription();
        this._updateDetails();
        this._updatePositions();
    }
    _updatePositions() {
        super._updatePositions();
        this._updateDescriptionPosition();
        this._updateDetailsPosition();
    }
    _updateDescription() {
        this._Description.patch({
            content: this.description,
            style: {
                textStyle: _objectSpread(_objectSpread({}, this.style.descriptionTextStyle), {}, {
                    wordWrapWidth: this._calculateTextWidth()
                })
            }
        });
    }
    _updateDescriptionPosition() {
        this._Description.x = this.style.paddingHorizontal;
        this._Description.y = this.style.paddingVertical + this._Title.h;
    }
    _updateDetails() {
        this._Details.patch({
            content: this.details,
            style: {
                textStyle: _objectSpread(_objectSpread({}, this.style.detailsTextStyle), {}, {
                    wordWrapWidth: this._calculateTextWidth()
                })
            }
        });
    }
    _updateDetailsPosition() {
        this._Details.x = this.style.paddingHorizontal;
        this._Details.y = this.h - this.style.paddingVertical;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || [ this._Title && this._Title.announce, this._Description && this._Description.announce, this._Details && this._Details.announce ];
    }
}

var base$E = theme => ({
    descriptionTextStyle: _objectSpread(_objectSpread({}, theme.typography.body2), {}, {
        textColor: theme.color.textNeutralSecondary,
        wordWrap: true,
        maxLines: 8
    }),
    height: theme.spacer.xxxl * 15,
    subtitleTextStyle: _objectSpread(_objectSpread({}, theme.typography.body3), {}, {
        maxLines: 2,
        textColor: theme.color.textNeutral,
        wordWrap: true
    }),
    width: utils$1.getWidthByColumnSpan(theme, 4)
});

var mode$c = theme => ({
    disabled: {
        descriptionTextStyle: {
            textColor: theme.color.textNeutralDisabled
        },
        subtitleTextStyle: {
            textColor: theme.color.textNeutralDisabled
        }
    }
});

var styles$E = Object.freeze({
    __proto__: null,
    base: base$E,
    mode: mode$c
});

var base$D = theme => {
    var size = theme.spacer.xxl;
    return {
        alpha: theme.alpha.primary,
        width: size,
        height: size,
        knobHeight: size / 2,
        knobWidth: size / 2,
        radius: size / 2,
        strokeWidth: theme.stroke.sm
    };
};

var tone$k = theme => ({
    neutral: {
        backgroundColor: theme.color.fillInverseSecondary,
        backgroundColorChecked: theme.color.fillNeutral,
        knobColor: theme.color.fillInverse,
        strokeColor: theme.color.strokeNeutralSecondary
    },
    inverse: {
        backgroundColor: theme.color.fillNeutralSecondary,
        backgroundColorChecked: theme.color.fillInverse,
        knobColor: theme.color.fillNeutral,
        strokeColor: theme.color.strokeInverseSecondary
    },
    brand: {
        backgroundColor: theme.color.fillNeutralSecondary,
        backgroundColorChecked: theme.color.fillBrand,
        knobColor: theme.color.fillInverse,
        strokeColor: theme.color.strokeNeutralSecondary
    }
});

var mode$b = theme => ({
    disabled: {
        alpha: theme.alpha.inactive
    }
});

var styles$D = Object.freeze({
    __proto__: null,
    base: base$D,
    mode: mode$b,
    tone: tone$k
});

class Radio extends Base$1 {
    static get __componentName() {
        return "Radio";
    }
    static get __themeStyle() {
        return styles$D;
    }
    static _template() {
        var center = {
            mount: .5,
            x: w => w / 2,
            y: h => h / 2
        };
        return {
            Body: _objectSpread(_objectSpread({
                rtt: true
            }, center), {}, {
                Knob: _objectSpread(_objectSpread({}, center), {}, {
                    alpha: 0
                })
            }),
            Stroke: center
        };
    }
    static get tags() {
        return [ "Knob", "Body", "Stroke" ];
    }
    static get properties() {
        return [ "checked" ];
    }
    _update() {
        this._updateBody();
        this._updateStroke();
        this._updateKnob();
        if (this._checkedChanged) {
            this.fireAncestors("$announce", this.announce);
            this._checkedChanged = false;
        }
        this._updateOpacity();
    }
    _updateBody() {
        var bodyColor = this.checked ? this.style.backgroundColorChecked : this.style.backgroundColor;
        var width = this.w - this.style.strokeWidth * 2 - 2;
        var height = this.h - this.style.strokeWidth * 2 - 2;
        this._Body.patch({
            texture: lng.Tools.getRoundRect(width, height, getMaxRoundRadius(this.style.radius, width, height, this.style.strokeWidth * 2 - 2), null, null, true, bodyColor)
        });
    }
    _updateStroke() {
        this._Stroke.patch({
            texture: lng.Tools.getRoundRect(this.w - 2, this.h - 2, getMaxRoundRadius(this.style.radius, this.w, this.h), this.style.strokeWidth, this.style.strokeColor, false)
        });
    }
    _updateKnob() {
        this._Knob.patch({
            texture: lng.Tools.getRoundRect(this.style.knobWidth, this.style.knobHeight, this.style.knobWidth / 2, null, null, true, this.style.knobColor)
        });
        this.applySmooth(this._Knob, {
            alpha: this.checked ? 1 : 0
        });
    }
    _updateOpacity() {
        this.applySmooth(this, {
            alpha: this.style.alpha
        });
    }
    _setChecked(checked) {
        this._checkedChanged = checked !== this._checked;
        return checked;
    }
    toggle() {
        if (!this._isDisabledMode) {
            this.checked = !this.checked;
        }
        return this;
    }
    _handleEnter() {
        if (typeof this.onEnter === "function") {
            return this.onEnter(this);
        } else {
            this.toggle();
        }
        return false;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || (this.checked ? "Checked" : "Unchecked");
    }
}

var base$C = theme => {
    var size = theme.spacer.xl;
    return {
        width: size,
        height: size,
        knobHeight: size / 2,
        knobWidth: size / 2,
        radius: size / 2
    };
};

var styles$C = Object.freeze({
    __proto__: null,
    base: base$C
});

class RadioSmall extends Radio {
    static get __componentName() {
        return "RadioSmall";
    }
    static get __themeStyle() {
        return styles$C;
    }
}

class CardRadio extends CardTitle {
    static get __componentName() {
        return "CardRadio";
    }
    static get __themeStyle() {
        return styles$E;
    }
    static get properties() {
        return [ ...super.properties, "radio", "subtitle" ];
    }
    static get tags() {
        return [ ...super.tags, "Radio", "Subtitle" ];
    }
    static _template() {
        return _objectSpread(_objectSpread({}, super._template()), {}, {
            Subtitle: {
                type: TextBox,
                signals: {
                    textBoxChanged: "_updatePositions"
                }
            }
        });
    }
    _update() {
        super._update();
        this._updateRadio();
        this._updateSubtitle();
        this._updatePositions();
    }
    _updatePositions() {
        super._updatePositions();
        this._updateSubtitlePosition();
    }
    _updateSubtitle() {
        this._Subtitle.patch({
            content: this.subtitle,
            style: {
                textStyle: _objectSpread(_objectSpread({}, this.style.subtitleTextStyle), {}, {
                    wordWrapWidth: this._calculateTextWidth()
                })
            }
        });
    }
    _updateRadio() {
        var radioPatch = _objectSpread(_objectSpread({}, this.radio), {}, {
            mode: this.mode,
            mountX: 1,
            x: this.w - this.style.paddingHorizontal,
            y: this.style.paddingVertical
        });
        if (!this._Radio) {
            radioPatch.type = Radio;
        }
        this.patch({
            Radio: radioPatch
        });
    }
    _updateSubtitlePosition() {
        this._Subtitle.x = this.style.paddingHorizontal;
        this._Subtitle.y = this.style.paddingVertical + this._Title.h;
    }
    _updateDescriptionPosition() {
        this._Description.x = this.style.paddingHorizontal;
        this._Description.y = this.style.paddingVertical * 2 + this._Title.h + this._Subtitle.h;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || [ this._Title && this._Title.announce, this._Subtitle && this._Subtitle.announce, this._Description && this._Description.announce, this._Details && this._Details.announce ];
    }
}

var base$B = theme => ({
    height: theme.spacer.xxl * 5,
    iconWidth: theme.spacer.xxl,
    iconHeight: theme.spacer.xxl,
    width: utils$1.getWidthByColumnSpan(theme, 3)
});

var styles$B = Object.freeze({
    __proto__: null,
    base: base$B
});

class CardSection extends Card {
    static get __componentName() {
        return "CardSection";
    }
    static get __themeStyle() {
        return styles$B;
    }
    static get tags() {
        return [ ...super.tags, "Icon" ];
    }
    static get properties() {
        return [ ...super.properties, "iconWidth", "iconHeight", "iconSrc" ];
    }
    _update() {
        super._update();
        this._updateIcon();
    }
    _updateIcon() {
        var {iconWidth: iconWidth, iconHeight: iconHeight} = this.style;
        var iconObject = {
            w: iconWidth,
            h: iconHeight,
            icon: this.iconSrc,
            x: this.w - iconWidth - this.style.paddingHorizontal,
            y: (this._Title.style.textStyle.lineHeight - iconHeight) / 2 + this.style.paddingVertical
        };
        if (!this._Icon) {
            iconObject.type = Icon;
        }
        this.patch({
            Icon: iconObject
        });
    }
    _calculateTextWidth() {
        var textWidth = this.w - this.style.paddingHorizontal * 2;
        return this.iconSrc ? textWidth - this.iconWidth : textWidth;
    }
}

var base$A = theme => {
    var strokeWidth = theme.stroke.sm;
    var size = theme.spacer.xxl;
    return {
        alpha: theme.alpha.primary,
        width: size,
        height: size,
        iconWidth: theme.spacer.lg,
        iconHeight: theme.spacer.lg,
        icon: theme.asset.check,
        radius: theme.radius.xs,
        strokeWidth: strokeWidth
    };
};

var tone$j = theme => ({
    neutral: {
        strokeColor: theme.color.strokeNeutralSecondary,
        checkColor: theme.color.fillInverse,
        backgroundColor: theme.color.fillInverseSecondary,
        backgroundColorChecked: theme.color.fillNeutral
    },
    inverse: {
        strokeColor: theme.color.strokeInverseSecondary,
        checkColor: theme.color.fillNeutral,
        backgroundColor: theme.color.fillNeutralSecondary,
        backgroundColorChecked: theme.color.fillInverse
    },
    brand: {
        strokeColor: theme.color.strokeNeutralSecondary,
        checkColor: theme.color.fillInverse,
        backgroundColor: theme.color.fillNeutralSecondary,
        backgroundColorChecked: theme.color.fillBrand
    }
});

var mode$a = theme => ({
    disabled: {
        alpha: theme.alpha.inactive
    }
});

var styles$A = Object.freeze({
    __proto__: null,
    base: base$A,
    mode: mode$a,
    tone: tone$j
});

class Checkbox extends Base$1 {
    static get __componentName() {
        return "Checkbox";
    }
    static get __themeStyle() {
        return styles$A;
    }
    static _template() {
        var center = {
            mount: .5,
            x: w => w / 2,
            y: h => h / 2
        };
        return {
            Body: _objectSpread(_objectSpread({
                rtt: true
            }, center), {}, {
                Check: _objectSpread(_objectSpread({
                    type: Icon
                }, center), {}, {
                    alpha: 0
                })
            }),
            Stroke: center
        };
    }
    static get tags() {
        return [ "Check", "Body", "Stroke" ];
    }
    static get properties() {
        return [ "checked" ];
    }
    static get aliasStyles() {
        return [ {
            prev: "checkSrc",
            curr: "icon"
        }, {
            prev: "checkH",
            curr: "iconHeight"
        }, {
            prev: "checkW",
            curr: "iconWidth"
        }, {
            prev: "checkHeight",
            curr: "iconHeight"
        }, {
            prev: "checkWidth",
            curr: "iconWidth"
        } ];
    }
    _update() {
        this._updateBody();
        this._updateStroke();
        this._updateCheck();
        if (this._checkedChanged) {
            this.fireAncestors("$announce", this.announce);
            this._checkedChanged = false;
        }
        this._updateOpacity();
    }
    _updateCheck() {
        this._Check.patch({
            w: this.style.iconWidth,
            h: this.style.iconHeight,
            icon: this.style.icon,
            style: {
                color: this.style.checkColor
            }
        });
        var alphaPatch = {
            alpha: this.checked ? 1 : 0
        };
        this.applySmooth(this._Check, alphaPatch);
    }
    _updateBody() {
        var bodyColor = this.checked ? this.style.backgroundColorChecked : this.style.backgroundColor;
        var width = this.w - this.style.strokeWidth * 2 - 2;
        var height = this.h - this.style.strokeWidth * 2 - 2;
        this._Body.patch({
            texture: lng.Tools.getRoundRect(width, height, getMaxRoundRadius(this.style.radius, width, height, this.style.strokeWidth * 2 - 2), 0, null, true, bodyColor)
        });
    }
    _updateStroke() {
        this._Stroke.patch({
            texture: lng.Tools.getRoundRect(this.w - 2, this.h - 2, getMaxRoundRadius(this.style.radius, this.w - 2, this.h - 2), this.style.strokeWidth, this.style.strokeColor, false)
        });
    }
    _updateOpacity() {
        this.applySmooth(this, {
            alpha: this.style.alpha
        });
    }
    _setChecked(checked) {
        this._checkedChanged = checked !== this._checked;
        return checked;
    }
    toggle() {
        if (!this._isDisabledMode) {
            this.checked = !this.checked;
        }
        return this;
    }
    _handleEnter() {
        if (typeof this.onEnter === "function") {
            return this.onEnter(this);
        } else {
            this.toggle();
        }
        return false;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || (this.checked ? "Checked" : "Unchecked");
    }
}

var base$z = theme => ({
    radius: [ theme.radius.md, theme.radius.md, theme.radius.md, theme.radius.none ],
    paddingX: theme.spacer.lg,
    paddingY: theme.spacer.md,
    offsetY: theme.spacer.xxs,
    textStyle: theme.typography.caption1
});

var tone$i = theme => ({
    neutral: {
        textStyle: {
            textColor: theme.color.textInverse
        },
        backgroundColor: theme.color.fillNeutral
    },
    inverse: {
        textStyle: {
            textColor: theme.color.textNeutral
        },
        backgroundColor: theme.color.fillInverse
    },
    brand: {
        textStyle: {
            textColor: theme.color.textNeutral
        },
        backgroundColor: theme.color.fillBrand
    }
});

var styles$z = Object.freeze({
    __proto__: null,
    base: base$z,
    tone: tone$i
});

class Label extends Base$1 {
    static _template() {
        return {
            Background: {},
            Text: {
                mountY: .5,
                mountX: .5,
                text: {}
            }
        };
    }
    static get __componentName() {
        return "Label";
    }
    static get __themeStyle() {
        return styles$z;
    }
    static get properties() {
        return [ "title" ];
    }
    static get tags() {
        return [ "Background", "Text" ];
    }
    _init() {
        this._Text.on("txLoaded", this._updateBackground.bind(this));
        super._init();
    }
    _update() {
        this._updateBackground();
        this._updateText();
    }
    _updateText() {
        if (this._Text) {
            this._Text.patch({
                text: _objectSpread(_objectSpread({}, this.style.textStyle), {}, {
                    text: this.title
                })
            });
        }
    }
    _updateBackground() {
        this._Text.x = this.w / 2;
        this._Text.y = this.h / 2 + this.style.offsetY;
        this.h = !this.title ? 0 : this._Text.renderHeight + 2 * this.style.paddingY;
        this.w = !this.title ? 0 : this._Text.renderWidth + 2 * this.style.paddingX;
        this._Background.patch({
            texture: lng.Tools.getRoundRect(this.w - 2, this.h - 2, this.style.radius, 0, null, true, this.style.backgroundColor)
        });
        this.signal("loadedLabel", this);
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || this._Text && this._Text.text.text;
    }
}

function withMarqueeSync(Base) {
    return class extends Base {
        static get name() {
            return Base.name;
        }
        _init() {
            super._init();
            if (this._shouldSync) {
                this._updateSignals();
            }
        }
        _update() {
            super._update();
            if (this._shouldSync) {
                this._updateSignals();
            } else {
                this._cleanupSyncValues();
            }
        }
        _cleanupSyncValues() {
            this.syncArray.map((component => {
                component.marqueeOverrideLoopX = undefined;
                component.signals && component.signals.willMarquee && delete component.signals.willMarquee;
            }));
        }
        _updateSignals() {
            if (this.syncArray) {
                this.syncArray.map((component => {
                    component.signals = _objectSpread(_objectSpread({}, component.signals), {}, {
                        willMarquee: "_willMarquee"
                    });
                }));
            }
        }
        _willMarquee(compRef) {
            if (this._shouldSync) {
                this._longestMarqueeWidth = Math.max(compRef._textRenderedW || 0, this._longestMarqueeWidth || 0);
                this.syncArray.map((component => {
                    component.marqueeOverrideLoopX = this._longestMarqueeWidth;
                }));
            }
        }
        get _shouldSync() {
            if (this.style.marqueeSync === false) {
                return false;
            }
            if (!this.syncArray) {
                loggerInstance.warn("warning: components using MarqueeSync must have a syncArray getter defined.");
                return false;
            } else if (!Array.isArray(this.syncArray)) {
                loggerInstance.warn("warning: syncArray must be typeof array.");
                return false;
            } else if (this.syncArray.length < 2) {
                loggerInstance.warn("warning: syncArray must contain at least two component references.");
                return false;
            } else {
                return true;
            }
        }
    };
}

var base$y = theme => ({
    descriptionTextStyle: _objectSpread(_objectSpread({}, theme.typography.body2), {}, {
        maxLines: 1
    }),
    fadeWidth: 100,
    logoWidth: theme.typography.body3.lineHeight,
    logoHeight: theme.typography.body3.lineHeight,
    logoPadding: theme.spacer.lg,
    detailsTextStyle: theme.typography.body3,
    subtitleTextStyle: theme.typography.body3,
    titleTextStyle: _objectSpread(_objectSpread({}, theme.typography.headline1), {}, {
        maxLines: 1
    }),
    marqueeSync: true,
    alpha: theme.alpha.primary
});

var mode$9 = theme => ({
    disabled: {
        detailsTextStyle: {
            textColor: theme.color.textNeutralDisabled
        },
        alpha: theme.alpha.inactive
    }
});

var tone$h = theme => ({
    neutral: {
        titleTextStyle: {
            textColor: theme.color.textNeutral
        },
        subtitleTextStyle: {
            textColor: theme.color.textNeutralSecondary
        },
        detailsTextStyle: {
            textColor: theme.color.textNeutral
        },
        descriptionTextStyle: {
            textColor: theme.color.textNeutralSecondary
        },
        mode: {
            disabled: {
                titleTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                },
                detailsTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                },
                descriptionTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                }
            }
        }
    },
    inverse: {
        titleTextStyle: {
            textColor: theme.color.textInverse
        },
        subtitleTextStyle: {
            textColor: theme.color.textInverseSecondary
        },
        detailsTextStyle: {
            textColor: theme.color.textInverse
        },
        descriptionTextStyle: {
            textColor: theme.color.textInverseSecondary
        },
        mode: {
            disabled: {
                titleTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                },
                subtitleTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                },
                detailsTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                },
                descriptionTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                }
            }
        }
    },
    brand: {
        titleTextStyle: {
            textColor: theme.color.textNeutral
        },
        subtitleTextStyle: {
            textColor: theme.color.textNeutralSecondary
        },
        detailsTextStyle: {
            textColor: theme.color.textNeutral
        },
        descriptionTextStyle: {
            textColor: theme.color.textNeutralSecondary
        },
        mode: {
            disabled: {
                titleTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                },
                detailsTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                },
                descriptionTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                }
            }
        }
    }
});

var styles$y = Object.freeze({
    __proto__: null,
    base: base$y,
    mode: mode$9,
    tone: tone$h
});

class MetadataBase extends Base$1 {
    static get __componentName() {
        return "MetadataBase";
    }
    static get __themeStyle() {
        return styles$y;
    }
    static _template() {
        return {
            Text: {
                flex: {
                    direction: "column",
                    justifyContent: "flex-start"
                },
                DetailsWrapper: {}
            }
        };
    }
    static get properties() {
        return [ "description", "logo", "logoHeight", "logoPosition", "logoTitle", "logoWidth", "details", "subtitle", "title", "marquee" ];
    }
    static get tags() {
        return [ "Text", {
            name: "Title",
            path: "Text.Title"
        }, {
            name: "Subtitle",
            path: "Text.Subtitle"
        }, {
            name: "DetailsWrapper",
            path: "Text.DetailsWrapper"
        }, {
            name: "Details",
            path: "Text.DetailsWrapper.Details"
        }, {
            name: "Description",
            path: "Text.Description"
        }, "Logo" ];
    }
    _titleLoaded() {
        this._updateLayout();
    }
    _subtitleLoaded() {
        this._updateLayout();
    }
    _detailsLoaded(_ref19) {
        var {w: w, h: h} = _ref19;
        this._updateDetailsLayout({
            w: w,
            h: h
        });
        this._updateLayout();
    }
    _descriptionLoaded() {
        this._updateLayout();
    }
    _updateDetailsLayout(_ref20) {
        var {w: w, h: h} = _ref20;
        if (!this.details && !this._Details) {
            return;
        }
        if (this._DetailsWrapper) {
            this._DetailsWrapper.alpha = this.style.alpha;
            this._DetailsWrapper.w = w;
            this._DetailsWrapper.h = h;
        }
    }
    _update() {
        this._updateLines();
        this._updateLayout();
    }
    _updateLines() {
        this._Text.w = this._textW();
        this._updateTitle();
        this._updateSubtitle();
        this._updateDetails();
        this._updateDescription();
    }
    _updateLayout() {
        this._Text.h = this._textH();
        this._updateMetadataHeight();
        this._updatePositions();
        this._updateLogo();
    }
    _updatePositions() {
        this._Text.x = this.logo && this.logoPosition === "left" ? this.logoWidth + this.style.logoPadding : 0;
        this._Text.y = (this.h - this._Text.h) / 2;
    }
    _updateMetadataHeight() {
        var newH = Math.max(this.logoHeight, this._Text.h);
        if (this.h !== newH) {
            this.h = newH;
            this.signal("updateComponentDimensions");
        }
    }
    _updateTitle() {
        if (!this.title && !this._Title) {
            return;
        }
        if (!this._Title) {
            this._Text.childList.addAt({
                ref: "Title",
                type: TextBox,
                signals: {
                    textBoxChanged: "_titleLoaded"
                }
            }, 0);
        }
        this._Title.patch({
            content: this.title,
            marquee: this.marquee,
            style: {
                textStyle: _objectSpread(_objectSpread({}, this.style.titleTextStyle), {}, {
                    maxLines: 1,
                    wordWrap: true,
                    wordWrapWidth: this._Text.w
                })
            }
        });
    }
    _updateSubtitle() {
        if (!this.subtitle && !this._Subtitle) {
            return;
        }
        if (!this._Subtitle) {
            this._Text.childList.addAt({
                ref: "Subtitle",
                type: TextBox,
                signals: {
                    textBoxChanged: "_subtitleLoaded"
                }
            }, 1);
        }
        this._Subtitle.patch({
            content: this.subtitle,
            marquee: this.marquee,
            style: {
                textStyle: _objectSpread(_objectSpread({}, this.style.subtitleTextStyle), {}, {
                    maxLines: 1,
                    wordWrap: true,
                    wordWrapWidth: this._Text.w
                })
            }
        });
    }
    resetMarquee() {
        if (this.marquee) {
            if (this.title) {
                if (!this._Title) {
                    this._updateTitle();
                }
                this._Title.toggleMarquee();
            }
            if (this.description) {
                if (!this._Description) {
                    this._updateDescription();
                }
                this._Description.toggleMarquee();
            }
        }
    }
    _updateDetails() {
        if (!this.details && !this._Details) {
            return;
        }
        if (!this._Details) {
            this._DetailsWrapper.patch({
                Details: {
                    type: TextBox,
                    signals: {
                        textBoxChanged: "_detailsLoaded"
                    }
                }
            });
        }
        this._Details.patch({
            content: this.details,
            style: {
                textStyle: this.style.detailsTextStyle
            }
        });
        if (this._Details.finalW > this._textW()) {
            this._Details.patch({
                w: this._textW() + this.style.fadeWidth / 2,
                shader: {
                    type: FadeShader,
                    positionLeft: 0,
                    positionRight: this.style.fadeWidth
                },
                rtt: true
            });
        } else {
            this._DetailsWrapper.shader = undefined;
        }
        this._DetailsWrapper.visible = this.details ? true : false;
        this._DetailsWrapper.alpha = this.style.alpha;
    }
    _updateDescription() {
        if (!this.description && !this._Description) {
            return;
        }
        if (!this._Description) {
            this._Text.childList.add({
                ref: "Description",
                type: TextBox,
                signals: {
                    textBoxChanged: "_descriptionLoaded"
                }
            });
        }
        this._Description.patch({
            content: this.description,
            marquee: this.marquee,
            style: {
                textStyle: _objectSpread(_objectSpread({}, this.style.descriptionTextStyle), {}, {
                    maxLines: 1,
                    wordWrap: true,
                    wordWrapWidth: this._Text.w
                })
            }
        });
    }
    _updateLogo() {
        if (!this.logo && !this._Logo) {
            return;
        }
        if (!this._Logo) {
            this.patch({
                Logo: {
                    flexItem: false,
                    type: Icon
                }
            });
        }
        this.logoPosition = this.logoPosition || "right";
        var subtitleH = this.subtitle && this._Subtitle && this._Subtitle.h || 0;
        this._Logo.patch({
            w: this.logoWidth,
            h: this.logoHeight,
            icon: this.logo,
            alpha: this.style.alpha
        });
        this._Logo.x = this.logoPosition === "left" ? 0 : this.w - this._Logo.w;
        this._Logo.y = (this.h - this.logoHeight + subtitleH) / 2;
    }
    _textW() {
        return this.w - (this.logo ? this.logoWidth + this.style.logoPadding : 0);
    }
    _textH() {
        var titleH = this.title && this._Title && this._Title.h || 0;
        var subtitleH = this.subtitle && this._Subtitle && this._Subtitle.h || 0;
        var detailsH = this.details && this._DetailsWrapper && this._DetailsWrapper.h || 0;
        var descriptionH = this.description && this._Description && this._Description.h || 0;
        return titleH + subtitleH + detailsH + descriptionH;
    }
    _getLogoWidth() {
        return this._logoWidth !== undefined ? this._logoWidth : this.style.logoWidth;
    }
    _setLogoWidth(w) {
        return w !== undefined ? w : this.logoWidth;
    }
    _getLogoHeight() {
        return this._logoHeight !== undefined ? this._logoHeight : this.style.logoHeight;
    }
    _setLogoHeight(h) {
        return h !== undefined ? h : this.logoHeight;
    }
    get syncArray() {
        return [ ...this._Title ? [ this._Title ] : [], ...this._Subtitle ? [ this._Subtitle ] : [], ...this._Description ? [ this._Description ] : [], ...this._Details ? [ this._Details ] : [] ];
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || [ this._Title && this._Title.announce, this._Subtitle && this._Subtitle.announce, this._Details && this._Details.announce, this._Description && this._Description.announce, this.logoTitle ];
    }
}

var MetadataBase$1 = withMarqueeSync(MetadataBase);

var base$x = theme => ({
    titleTextStyle: theme.typography.headline3,
    descriptionTextStyle: theme.typography.body3
});

var tone$g = theme => ({
    neutral: {
        detailsTextStyle: {
            textColor: theme.color.textNeutralSecondary
        },
        descriptionTextStyle: {
            textColor: theme.color.textNeutral
        },
        mode: {
            disabled: {
                detailsTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                },
                descriptionTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                }
            }
        }
    },
    inverse: {
        detailsTextStyle: {
            textColor: theme.color.textInverseSecondary
        },
        descriptionTextStyle: {
            textColor: theme.color.textInverse
        },
        mode: {
            disabled: {
                detailsTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                },
                descriptionTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                }
            }
        }
    },
    brand: {
        detailsTextStyle: {
            textColor: theme.color.textNeutralSecondary
        },
        descriptionTextStyle: {
            textColor: theme.color.textNeutral
        },
        mode: {
            disabled: {
                detailsTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                },
                descriptionTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                }
            }
        }
    }
});

var styles$x = Object.freeze({
    __proto__: null,
    base: base$x,
    tone: tone$g
});

class MetadataTile extends MetadataBase$1 {
    static get __componentName() {
        return "MetadataTile";
    }
    static get __themeStyle() {
        return styles$x;
    }
    _updateDetails() {
        if (!this.details && !this._Details) {
            return;
        }
        if (this.description && this._Details) {
            this._Details.patch({
                content: ""
            });
            this._Details.alpha = 0;
            this._Details.visible = false;
        } else {
            super._updateDetails();
        }
    }
    _updateDetailsLayout(_ref21) {
        var {h: h} = _ref21;
        if (!this.details && !this._Details) {
            return;
        }
        if (this._Details && !this.description) {
            this._DetailsWrapper.h = h;
            this._DetailsWrapper.alpha = this.style.alpha;
        } else {
            this._DetailsWrapper.h = 0;
        }
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || [ this._Title && this._Title.announce, this._Details && this._Details.announce || this._Description && this._Description.announce, this.logoTitle ];
    }
    _textH() {
        var titleH = this.title && this._Title && this._Title.h || 0;
        var detailsH = this.details && this._Details && this._Details.visible && this._DetailsWrapper.h || 0;
        var descriptionH = this.description && this._Description && this._Description.h || 0;
        return titleH + detailsH + descriptionH;
    }
}

var base$w = theme => ({
    height: theme.spacer.md,
    animation: theme.animation.utility,
    radius: theme.radius.xs
});

var tone$f = theme => ({
    neutral: {
        barColor: theme.color.fillNeutralTertiary,
        progressColor: theme.color.fillNeutral
    },
    inverse: {
        barColor: theme.color.fillInverseTertiary,
        progressColor: theme.color.fillInverse
    },
    brand: {
        barColor: theme.color.fillNeutralTertiary,
        progressColor: theme.color.fillBrand
    }
});

var styles$w = Object.freeze({
    __proto__: null,
    base: base$w,
    tone: tone$f
});

class ProgressBar extends Base$1 {
    static _template() {
        return {
            Bar: {
                zIndex: 1
            },
            Progress: {
                alpha: 0,
                zIndex: 2
            }
        };
    }
    static get __themeStyle() {
        return styles$w;
    }
    static get __componentName() {
        return "ProgressBar";
    }
    static get properties() {
        return [ "progress" ];
    }
    static get tags() {
        return [ "Bar", "Progress" ];
    }
    _construct() {
        super._construct && super._construct();
        this._progress = 0;
    }
    _update() {
        this._updateTextures();
        this._updateProgress();
        if (this._progressChanged) {
            this.fireAncestors("$announce", this.announce);
            this._progressChanged = false;
        }
    }
    _updateTextures() {
        var w = this._getProgressWidth();
        var radius = getMaxRoundRadius(this.style.radius, this.w - 2, this.h);
        this._Bar.texture = lng.Tools.getRoundRect(this.w - 2, this.h, radius, 0, 0, true, this.style.barColor);
        this._Progress.texture = lng.Tools.getRoundRect(w + 1, this.h, radius, 0, 0, true, this.style.progressColor);
    }
    _updateProgress() {
        var w = this._getProgressWidth();
        this._Progress.smooth = {
            w: [ w, this.style.animation ],
            alpha: Number(w > 0)
        };
    }
    _setProgress(progress) {
        this._progressChanged = progress !== this._progress;
        return progress;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        if (this._announce !== undefined && this._announce !== null) {
            return this._announce;
        }
        var progress = this.progress;
        if (progress > 1) {
            progress = 1;
        } else if (progress < 0) {
            progress = 0;
        }
        return "".concat(Math.round(progress * 100), "%");
    }
    _getProgressWidth() {
        var p = this.w * this._progress;
        var w = p <= 0 ? 0 : Math.min(p, this.w);
        return w;
    }
}

var base$v = theme => ({
    animationEntrance: theme.animation.standardEntrance,
    animationExit: theme.animation.standardExit,
    logoWidth: theme.spacer.lg * 5,
    logoHeight: theme.spacer.xxl + theme.spacer.md,
    metadataLocation: "standard",
    paddingX: theme.spacer.xl,
    paddingY: theme.spacer.lg,
    paddingYProgress: theme.spacer.xl,
    paddingYBetweenContent: theme.spacer.md,
    radius: theme.radius.md,
    alpha: theme.alpha.primary
});

var tone$e = theme => ({
    neutral: {
        mode: {
            focused: {
                backgroundColor: theme.color.interactiveNeutralFocusSoft
            }
        }
    },
    inverse: {
        mode: {
            focused: {
                backgroundColor: theme.color.interactiveInverseFocusSoft
            }
        }
    },
    brand: {
        mode: {
            focused: {
                backgroundColor: theme.color.interactiveBrandFocusSoft
            }
        }
    }
});

var mode$8 = theme => ({
    disabled: {
        alpha: theme.alpha.inactive
    }
});

var styles$v = Object.freeze({
    __proto__: null,
    base: base$v,
    mode: mode$8,
    tone: tone$e
});

class Tile extends Surface {
    static get __componentName() {
        return "Tile";
    }
    static get __themeStyle() {
        return styles$v;
    }
    static _template() {
        return _objectSpread(_objectSpread({}, super._template()), {}, {
            Tile: {
                Artwork: {
                    type: Artwork,
                    signals: {
                        imageLoaded: "_imageLoaded"
                    },
                    mount: .5
                },
                Content: {
                    mount: .5
                }
            }
        });
    }
    static get properties() {
        return [ "artwork", "badge", "checkbox", "circle", "label", "logo", "metadata", "metadataLocation", "persistentMetadata", "progressBar", "src" ];
    }
    static get aliasStyles() {
        return [ {
            prev: "iconHeight",
            curr: "logoHeight"
        }, {
            prev: "iconWidth",
            curr: "logoWidth"
        } ];
    }
    static get aliasProperties() {
        return [ {
            prev: "iconSrc",
            curr: "logo"
        } ];
    }
    static get tags() {
        return [ ...super.tags, "Artwork", "Content", "Tile", {
            name: "Badge",
            path: "Content.Badge"
        }, {
            name: "Checkbox",
            path: "Content.Checkbox"
        }, {
            name: "Logo",
            path: "Content.Logo"
        }, {
            name: "Metadata",
            path: "Content.Metadata"
        }, {
            name: "ProgressBar",
            path: "Content.ProgressBar"
        }, {
            name: "Label",
            path: "Content.Label"
        } ];
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || [ this._Metadata && this._Metadata.announce, this._Badge && this._Badge.announce, this._Label && this._Label.announce, this._ProgressBar && this._ProgressBar.announce ];
    }
    _update() {
        super._update();
        this._updateTileColor();
        this._updateContent();
        this._updateArtwork();
        this._updateBadge();
        this._updateLabel();
        this._updateCheckbox();
        this._updateProgressBar();
        this._updateMetadata();
        this._updateLogo();
    }
    _getRenderHeight() {
        var _this$_Metadata;
        return !this._isInsetMetadata ? this._h + (((_this$_Metadata = this._Metadata) === null || _this$_Metadata === void 0 ? void 0 : _this$_Metadata.h) + this.style.paddingY || 0) : super._getRenderHeight();
    }
    get innerH() {
        return this._h;
    }
    get _shouldShowGradient() {
        var _this$progressBar;
        return Boolean((this._isInsetMetadata && this._hasMetadata && this._shouldShowMetadata || ((_this$progressBar = this.progressBar) === null || _this$progressBar === void 0 ? void 0 : _this$progressBar.progress) > 0 || this._shouldShowLogo) && !this._isCircleLayout);
    }
    get _isCircleLayout() {
        return Boolean(this._itemLayout && this._itemLayout.circle);
    }
    get _foregroundDefaultWidth() {
        return parseFloat(this._w / this._h).toFixed(2) === parseFloat(16 / 9).toFixed(2) ? this.innerW * .5 : this.innerW * .75;
    }
    _updateTileColor() {
        this._Tile.alpha = this.style.alpha;
    }
    _updateContent() {
        var itemContainerPatch = {
            h: this._h,
            w: this._w,
            x: this._w / 2,
            y: this._h / 2
        };
        this.applySmooth(this._Content, itemContainerPatch, Object.keys(itemContainerPatch).reduce(((acc, prop) => {
            acc[prop] = [ itemContainerPatch[prop], this._isFocusedMode ? this.style.animationEntrance : this.style.animationExit ];
            return acc;
        }), {}));
    }
    _updateLogo() {
        if (!this.logo) {
            this.patch({
                Logo: undefined
            });
            return;
        }
        var logoObject = {
            w: this.style.logoWidth,
            h: this.style.logoHeight,
            icon: this.logo,
            alpha: this._shouldShowLogo ? this.style.alpha : .001,
            x: this.style.paddingX,
            y: this._calculateLogoYPosition()
        };
        if (!this._Logo) {
            this.patch({
                Logo: _objectSpread({
                    type: Icon,
                    mountY: 1
                }, logoObject)
            });
        } else {
            this.applySmooth(this._Logo, logoObject);
        }
    }
    _calculateLogoYPosition() {
        if (this._isInsetMetadata && this._Metadata) {
            return this._metadataY - this._Metadata.h;
        }
        return this._progressBarY ? this._progressBarY - this.style.paddingYBetweenContent : this._h - this.style.paddingY;
    }
    get _shouldShowLogo() {
        return this.logo && (this.persistentMetadata || this._isFocusedMode);
    }
    _updateArtwork() {
        var _this$style3, _this$artwork;
        this._Artwork.patch(_objectSpread(_objectSpread({
            mode: this.mode,
            h: this._h,
            w: this._w,
            x: this._w / 2,
            y: this._h / 2,
            src: this.src
        }, this.artwork || {}), {}, {
            style: _objectSpread({
                radius: (_this$style3 = this.style) === null || _this$style3 === void 0 ? void 0 : _this$style3.radius
            }, (_this$artwork = this.artwork) === null || _this$artwork === void 0 ? void 0 : _this$artwork.style),
            gradient: this._shouldShowGradient,
            shouldScale: this._isFocusedMode
        }));
    }
    _getSrc() {
        return this.artwork && this.artwork.src || this._src;
    }
    _imageLoaded() {
        this._Background.alpha = 0;
    }
    _updateBadge() {
        var _this$badge;
        if (!((_this$badge = this.badge) !== null && _this$badge !== void 0 && _this$badge.title) || this._isCircleLayout) {
            if (this._Badge) {
                this._Content.patch({
                    Badge: undefined
                });
            }
            return;
        }
        var badgePatch = _objectSpread(_objectSpread({}, this.badge), {}, {
            mode: this.mode,
            x: this.style.paddingX,
            y: this.style.paddingY,
            alpha: this._shouldShowBadgeLabel ? 1 : .001
        });
        if (!this._Badge) {
            this._Content.patch({
                Badge: _objectSpread(_objectSpread({
                    type: Badge
                }, badgePatch), {}, {
                    signals: {
                        loadedBadge: "_updateBadge"
                    }
                })
            });
            return;
        } else {
            this._Badge.patch(badgePatch);
        }
        this.applySmooth(this._Badge, badgePatch, _objectSpread(_objectSpread({}, badgePatch), this._badgeLabelTransitions));
    }
    _updateLabel() {
        var _this$label;
        if (!((_this$label = this.label) !== null && _this$label !== void 0 && _this$label.title) || this._isCircleLayout) {
            if (this._Label) {
                this._Content.patch({
                    Label: undefined
                });
            }
            return;
        }
        var labelPatch = _objectSpread(_objectSpread({}, this.label), {}, {
            mode: this.mode,
            x: this._w - this.style.paddingX,
            y: this.style.paddingY,
            alpha: this._shouldShowBadgeLabel ? 1 : .001
        });
        if (!this._Label) {
            this._Content.patch({
                Label: _objectSpread(_objectSpread({
                    type: Label,
                    mountX: 1
                }, labelPatch), {}, {
                    signals: {
                        loadedLabel: "_updateLabel"
                    }
                })
            });
            return;
        } else {
            this._Label.patch(labelPatch);
        }
        this.applySmooth(this._Label, labelPatch, _objectSpread(_objectSpread({}, labelPatch), {}, {
            x: [ labelPatch.x, this._shouldShowBadgeLabel ? this.style.animationEntrance : this.style.animationExit ]
        }, this._badgeLabelTransitions));
    }
    get _shouldShowBadgeLabel() {
        return this.persistentMetadata || this._isFocusedMode && !this._isCircleLayout;
    }
    get _badgeLabelTransitions() {
        return {
            y: [ this._shouldShowBadgeLabel ? this.style.paddingY : 0, this._shouldShowBadgeLabel ? this.style.animationEntrance : this.style.animationExit ],
            alpha: [ this._shouldShowBadgeLabel ? 1 : .001, this._shouldShowBadgeLabel ? this.style.animationEntrance : this.style.animationExit ]
        };
    }
    _updateCheckbox() {
        var _this$checkbox;
        if (!(typeof ((_this$checkbox = this.checkbox) === null || _this$checkbox === void 0 ? void 0 : _this$checkbox.checked) === "boolean" && this.checkbox.checked) || this._isCircleLayout) {
            if (this._Checkbox) {
                this._Content.patch({
                    Checkbox: undefined
                });
            }
            return;
        }
        var checkboxPatch = _objectSpread(_objectSpread({}, this.checkbox), {}, {
            mode: this.mode,
            x: this._w - this.style.paddingX,
            y: this._h - this.style.paddingY
        });
        if (!this._Checkbox) {
            this._Content.patch({
                Checkbox: _objectSpread(_objectSpread({}, checkboxPatch), {}, {
                    type: Checkbox,
                    mount: 1
                })
            });
            return;
        }
        this.applySmooth(this._Checkbox, checkboxPatch);
    }
    get _progressBarY() {
        return (this._ProgressBar && this._ProgressBar._getTransition("alpha")._targetValue !== 0 ? this._ProgressBar._getTransition("y")._targetValue || this._ProgressBar.y : 0) || 0;
    }
    _updateProgressBar() {
        var _this$progressBar2;
        if (!(typeof ((_this$progressBar2 = this.progressBar) === null || _this$progressBar2 === void 0 ? void 0 : _this$progressBar2.progress) === "number" && this.progressBar.progress) || this._isCircleLayout) {
            if (this._ProgressBar) {
                if (this.shouldSmooth) {
                    this._ProgressBar._getTransition("alpha").once("finish", (() => {
                        this._removeProgressBar();
                    }));
                    this._ProgressBar.smooth = {
                        alpha: 0
                    };
                } else {
                    this._removeProgressBar();
                }
            }
            return;
        }
        if (this.progressBar.progress > 0) {
            var progressPatch = _objectSpread(_objectSpread({}, this.progressBar), {}, {
                mode: this.mode,
                w: this._w - this.style.paddingX * 2,
                x: this._w / 2,
                y: this._h - this.style.paddingYProgress
            });
            if (!this._ProgressBar) {
                this._Content.patch({
                    ProgressBar: _objectSpread(_objectSpread({}, progressPatch), {}, {
                        type: ProgressBar,
                        mountX: .5,
                        mountY: 1,
                        alpha: this._hasMetadata && this.shouldSmooth ? .001 : 1
                    })
                });
                if (this.shouldSmooth) {
                    this._ProgressBar.smooth = {
                        alpha: [ 1, {
                            delay: this.style.animationEntrance.duration
                        } ]
                    };
                }
                return;
            }
            this.applySmooth(this._ProgressBar, progressPatch, Object.keys(progressPatch).reduce(((acc, prop) => {
                acc[prop] = [ progressPatch[prop], this._isFocusedMode ? this.style.animationEntrance : this.style.animationExit ];
                return acc;
            }), {}));
        }
    }
    _removeProgressBar() {
        this._Content.patch({
            ProgressBar: undefined
        });
        this._updateMetadata();
    }
    get _shouldShowMetadata() {
        return this._hasMetadata && (this.persistentMetadata && !this._isInsetMetadata || this._isFocusedMode && !this._isInsetMetadata || (this.persistentMetadata || this._isFocusedMode) && this._isInsetMetadata && !this._isCircleLayout);
    }
    get _isInsetMetadata() {
        return this.metadataLocation === "inset";
    }
    get _metadataTransitions() {
        return {
            y: [ this._metadataY, this._shouldShowMetadata ? this.style.animationEntrance : this.style.animationExit ],
            alpha: [ this._metadataAlpha, this._shouldShowMetadata ? this.style.animationEntrance : this.style.animationExit ]
        };
    }
    get _hasMetadata() {
        return MetadataTile.properties.some((prop => this.metadata && this.metadata[prop]));
    }
    get _metadataY() {
        if (this._shouldShowMetadata) {
            if (this._isInsetMetadata) {
                return this._progressBarY ? this._progressBarY - this.style.paddingYBetweenContent : this._h - this.style.paddingY;
            }
        }
        return this._h + this.style.paddingY;
    }
    get _metadataAlpha() {
        return this._shouldShowMetadata ? 1 : .001;
    }
    get _metadataPatch() {
        return {
            alpha: this._metadataAlpha,
            w: this._w - this.style.paddingX * 2,
            x: this._w / 2,
            y: this._metadataY
        };
    }
    get _nonSmoothingMetadataPatch() {
        return _objectSpread({
            mode: this.mode,
            mountX: .5,
            mountY: this._isInsetMetadata ? 1 : 0,
            marquee: this._isFocusedMode
        }, this.metadata || {});
    }
    _getMetadataLocation() {
        var _this$_metadataLocati;
        return (_this$_metadataLocati = this._metadataLocation) !== null && _this$_metadataLocati !== void 0 ? _this$_metadataLocati : this.style.metadataLocation;
    }
    _updateMetadata() {
        if (!this._hasMetadata) {
            this._Content.patch({
                Metadata: undefined
            });
            return;
        }
        if (!this._Metadata && this._hasMetadata) {
            this._Content.patch({
                Metadata: _objectSpread(_objectSpread({
                    type: MetadataTile,
                    signals: {
                        updateComponentDimensions: "_metadataLoaded"
                    }
                }, this._nonSmoothingMetadataPatch), this._metadataPatch)
            });
            return;
        }
        this._Metadata.patch(this._nonSmoothingMetadataPatch);
        this._animateMetadata();
    }
    _animateMetadata() {
        if (!this._Metadata) {
            return;
        }
        this.applySmooth(this._Metadata, this._metadataPatch, this._metadataTransitions);
        if (!this._isFocusedMode) {
            this._resetMarqueeAnimation();
        }
    }
    _metadataLoaded() {
        this._animateMetadata();
        this._updateLogo();
        this._updateDimensions();
        if (!this._isInsetMetadata) {
            this.fireAncestors("$itemChanged");
        }
    }
    _resetMarqueeAnimation() {
        var alphaTransition = this._Metadata._getTransition("alpha");
        if (alphaTransition) {
            alphaTransition.on("finish", (() => {
                if (this._Metadata) {
                    this._Metadata.resetMarquee();
                }
            }));
        } else {
            this._Metadata.resetMarquee();
        }
    }
}

function base$u(theme) {
    return {
        alpha: theme.alpha.primary,
        counterTextStyle: theme.typography.headline3,
        itemSize: theme.layout.gutterX * 2,
        itemSpacing: theme.spacer.md,
        radius: theme.radius.sm
    };
}

var mode$7 = theme => ({
    disabled: {
        alpha: theme.alpha.inactive
    }
});

var tone$d = theme => ({
    neutral: {
        counterBackgroundColor: theme.color.fillInverseSecondary
    },
    inverse: {
        counterBackgroundColor: theme.color.fillNeutralSecondary
    },
    brand: {
        counterBackgroundColor: theme.color.fillInverseSecondary
    }
});

var styles$u = Object.freeze({
    __proto__: null,
    base: base$u,
    mode: mode$7,
    tone: tone$d
});

class Provider extends Base$1 {
    static get __componentName() {
        return "Provider";
    }
    static get __themeStyle() {
        return styles$u;
    }
    static _template() {
        return {
            Row: {
                type: Row,
                autoResizeWidth: true
            }
        };
    }
    static get properties() {
        return [ "disableRadius", "counterText", "providers", "visibleCount" ];
    }
    static get tags() {
        return [ "Row" ];
    }
    get providersHidden() {
        return this.providers.length - this._visibleCount;
    }
    _construct() {
        this._providers = [];
        super._construct();
    }
    _update() {
        this._updateProviders();
        this._updateCounter();
    }
    _updateProviders() {
        var providerList = [];
        this.providers.slice(0, this.visibleCount).forEach((provider => {
            var patch = {
                centerInParent: true,
                radius: this.disableRadius ? 0 : getMaxRoundRadius(this.style.radius, this.style.itemSize, this.style.itemSize),
                alpha: this.style.alpha,
                style: provider.style || {}
            };
            if (provider.type === Icon && provider.icon && provider.w && provider.h) {
                var ratio = provider.w / provider.h;
                patch = _objectSpread(_objectSpread({
                    type: Icon,
                    icon: provider.icon
                }, provider), {}, {
                    w: this.style.itemSize * ratio,
                    h: this.style.itemSize
                }, patch);
            } else {
                patch = _objectSpread({
                    type: Icon,
                    w: this.style.itemSize,
                    h: this.style.itemSize
                }, patch);
                if (typeof provider === "object") {
                    patch = _objectSpread(_objectSpread({}, patch), provider);
                } else {
                    patch.icon = provider;
                }
            }
            providerList.push(patch);
        }));
        this._Row.patch({
            style: {
                itemSpacing: this.style.itemSpacing
            },
            items: providerList,
            h: this.style.itemSize
        });
    }
    _updateCounter() {
        if (this.providers.length > this.visibleCount) {
            var remaining = this.providersHidden;
            var counter = {
                announce: "+".concat(remaining),
                alpha: this.style.alpha,
                w: this.style.itemSize,
                h: this.style.itemSize,
                centerInParent: true,
                Background: {
                    w: this.style.itemSize,
                    h: this.style.itemSize,
                    texture: lng.Tools.getRoundRect(this.style.itemSize, this.style.itemSize, getMaxRoundRadius(this.style.radius, this.style.itemSize, this.style.itemSize), 0, null, true, this.style.counterBackgroundColor)
                },
                Text: {
                    type: TextBox,
                    mountX: .5,
                    mountY: .5,
                    x: this.style.itemSize / 2,
                    y: this.style.itemSize / 2,
                    content: this.counterText || "+".concat(remaining),
                    style: {
                        textStyle: this.style.counterTextStyle
                    }
                }
            };
            this._Row.appendItems([ counter ]);
        }
    }
    $itemChanged() {
        this.signal("providerChanged");
    }
    _getVisibleCount() {
        var min = 1;
        var max = this.providers.length;
        var visibleCount = Math.min(Math.max(min, this._visibleCount), max);
        if (this._visibleCount < min) {
            console.warn("Warning: The specified visible count (".concat(this._visibleCount, ") is less than the minimum value (").concat(min, "). Setting it to ").concat(min, "."));
        }
        if (this._visibleCount > max) {
            console.warn("Warning: The specified visible count (".concat(this._visibleCount, ") is greater than the maximum value (").concat(max, "). Setting it to ").concat(max, "."));
        }
        return visibleCount;
    }
    get w() {
        return this._Row.w;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || this._Row.items && this._Row.items.length && this._Row.items.map((item => item.announce));
    }
}

var base$t = theme => ({
    detailsTextStyle: theme.typography.body3,
    descriptionTextStyle: {
        maxLines: 3
    },
    descriptionDetailsStyle: {
        paddingY: 5
    },
    fadeWidth: theme.spacer.md * theme.spacer.md,
    provider: {
        itemSize: theme.spacer.xxxl + theme.spacer.md
    }
});

var tone$c = theme => ({
    neutral: {
        detailsTextStyle: {
            textColor: theme.color.textNeutral
        },
        mode: {
            disabled: {
                detailsTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                }
            }
        }
    },
    inverse: {
        detailsTextStyle: {
            textColor: theme.color.textInverse
        },
        mode: {
            disabled: {
                detailsTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                }
            }
        }
    },
    brand: {
        detailsTextStyle: {
            textColor: theme.color.textNeutral
        },
        mode: {
            disabled: {
                detailsTextStyle: {
                    textColor: theme.color.textNeutralDisabled
                }
            }
        }
    }
});

var styles$t = Object.freeze({
    __proto__: null,
    base: base$t,
    tone: tone$c
});

class MetadataCardContent extends MetadataBase$1 {
    static get __componentName() {
        return "MetadataCardContent";
    }
    static get __themeStyle() {
        return styles$t;
    }
    static _template() {
        return {
            Text: {
                flex: {
                    direction: "column",
                    justifyContent: "flex-start"
                },
                Title: {
                    type: TextBox
                },
                Subtitle: {
                    type: TextBox
                },
                Description: {
                    type: TextBox
                },
                DescriptionDetails: {
                    type: TextBox
                }
            },
            DetailsWrapper: {
                DetailsFader: {
                    Details: {
                        mountY: .5,
                        type: TextBox,
                        signals: {
                            textBoxChanged: "_resolveDetails"
                        }
                    }
                },
                Provider: {
                    mount: 1,
                    type: Provider,
                    signals: {
                        providerChanged: "_resolveProvider"
                    }
                }
            }
        };
    }
    static get properties() {
        return [ "description", "descriptionDetails", "details", "provider", "subtitle", "title" ];
    }
    static get tags() {
        return [ "Text", {
            name: "Title",
            path: "Text.Title"
        }, {
            name: "Subtitle",
            path: "Text.Subtitle"
        }, {
            name: "Description",
            path: "Text.Description"
        }, {
            name: "DescriptionDetails",
            path: "Text.DescriptionDetails"
        }, "DetailsWrapper", {
            name: "DetailsFader",
            path: "DetailsWrapper.DetailsFader"
        }, {
            name: "Details",
            path: "DetailsWrapper.DetailsFader.Details"
        }, {
            name: "Provider",
            path: "DetailsWrapper.Provider"
        } ];
    }
    _setDetails(details) {
        if (details) {
            this._detailsPromise = new Promise((resolve => {
                this._detailsPromiseResolver = resolve;
            }));
        } else {
            this._detailsPromise = undefined;
        }
        return details;
    }
    _setProvider(provider) {
        if (provider) {
            this._providerPromise = new Promise((resolve => {
                this._providerPromiseResolver = resolve;
            }));
        } else {
            this._providerPromise = undefined;
        }
        return provider;
    }
    _update() {
        var _this9 = this;
        return _asyncToGenerator((function*() {
            _this9._updateLines();
            _this9._updateProvider();
            yield Promise.all([ _this9._detailsPromise, _this9._providerPromise ].filter(Boolean));
            _this9._updatePositions();
        }))();
    }
    _updateLines() {
        this._Text.w = this.w;
        this._updateTitle();
        this._updateSubtitle();
        this._updateDescription();
        this._updateDescriptionDetails();
        this._updateDetails();
    }
    _updateSubtitle() {
        if (!this.subtitle && !this._Subtitle) {
            return;
        }
        if (!this._Subtitle) {
            this._Text.childList.addAt({
                ref: "Subtitle",
                type: TextBox
            });
        }
        this._Subtitle.patch({
            content: this.subtitle,
            style: {
                textStyle: _objectSpread(_objectSpread({}, this.style.subtitleTextStyle), {}, {
                    maxLines: 1,
                    wordWrap: true,
                    wordWrapWidth: this._Text.w
                })
            }
        });
    }
    _updateDescription() {
        this._Description.patch({
            content: this.description,
            style: {
                textStyle: _objectSpread(_objectSpread({}, this.style.descriptionTextStyle), {}, {
                    wordWrap: true,
                    wordWrapWidth: this._Text.w
                })
            }
        });
    }
    _updateDescriptionDetails() {
        this._DescriptionDetails.patch({
            content: this.descriptionDetails,
            style: {
                textStyle: _objectSpread(_objectSpread({}, this.style.descriptionDetailsTextStyle), {}, {
                    maxLines: 1,
                    wordWrap: true,
                    wordWrapWidth: this._Text.w
                })
            },
            y: this.style.descriptionDetailsStyle.paddingY
        });
    }
    _updateDetails() {
        var maxWidth = this._detailsMaxW;
        this._Details.patch({
            content: this.details,
            style: {
                textStyle: _objectSpread(_objectSpread({}, this.style.detailsTextStyle), {}, {
                    wordWrap: true,
                    maxLines: 1,
                    wordWrapWidth: maxWidth + this.style.fadeWidth / 2
                })
            }
        });
        if (this._Details.finalW > maxWidth) {
            this._DetailsFader.patch({
                w: maxWidth + this.style.fadeWidth / 2,
                shader: {
                    type: FadeShader,
                    positionLeft: 0,
                    positionRight: this.style.fadeWidth
                }
            });
        } else {
            this._DetailsFader.shader = undefined;
        }
    }
    _resolveDetails() {
        this._detailsPromiseResolver && this._detailsPromiseResolver();
        this._updatePositions();
    }
    _updateProvider() {
        if (this.provider) {
            this._Provider.patch(_objectSpread(_objectSpread({
                mode: this.mode
            }, this.provider), {}, {
                style: this.style.provider
            }));
        }
    }
    _resolveProvider() {
        this._providerPromiseResolver && this._providerPromiseResolver();
        this._updatePositions();
        this._updateDetails();
    }
    _updatePositions() {
        this._Text.h = this._textH;
        this._Text.w = this._textW;
        this._DetailsWrapper.w = this._textW;
        this._DetailsWrapper.h = Math.max(this._providerH, this._Details.h);
        this._DetailsWrapper.y = this.h - this._DetailsWrapper.h;
        this._Details.y = this._DetailsWrapper.h / 2;
        this._Provider.x = this._DetailsWrapper.w - this._providerW;
        this._Provider.y = this._DetailsWrapper.h - this._providerH;
    }
    get _textW() {
        return this.w;
    }
    get _textH() {
        return this.h - this._providerH;
    }
    get _providerW() {
        return this._Provider.w;
    }
    get _providerH() {
        return this._Provider._Row._Items.h;
    }
    get _detailsMaxW() {
        return this.w - this._providerW - this.style.fadeWidth / 2;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || [ this._Title && this._Title.announce, this._Subtitle && this._Subtitle.announce, this._Description && this._Description.announce, this._DescriptionDetails && this._DescriptionDetails.announce, this._Details && this._Details.announce, this._Provider && this._Provider.announce ];
    }
}

var base$s = theme => ({
    expandedWidth: utils$1.getWidthByUpCount(theme, 2),
    expandedHeight: utils$1.getDimensions(theme, {
        ratioX: 16,
        ratioY: 9,
        upCount: 4
    }).h,
    imageSize: {
        width: utils$1.getDimensions(theme, {
            ratioX: 16,
            ratioY: 9,
            upCount: 4
        }).w,
        height: utils$1.getDimensions(theme, {
            ratioX: 16,
            ratioY: 9,
            upCount: 4
        }).h
    },
    metadata: {
        descriptionTextStyle: {
            maxLines: 2
        }
    },
    paddingVertical: theme.spacer.md * 1.5
});

var styles$s = Object.freeze({
    __proto__: null,
    base: base$s
});

class CardContent extends Card {
    static get __componentName() {
        return "CardContent";
    }
    static get __themeStyle() {
        return styles$s;
    }
    static _template() {
        return _objectSpread(_objectSpread({}, super._template()), {}, {
            Tile: {
                type: Tile
            }
        });
    }
    static get properties() {
        return [ ...super.properties, "tile", "metadata", "orientation", "collapseToMetadata", "shouldCollapse", "src" ];
    }
    static get tags() {
        return [ ...super.tags, "Metadata", "Tile" ];
    }
    static get aliasStyles() {
        return [ {
            prev: "expandedW",
            curr: "expandedWidth"
        }, {
            prev: "expandedH",
            curr: "expandedHeight"
        } ];
    }
    _update() {
        this._updateSize();
        this._updateTile();
        this._updateMetadata();
        super._update();
    }
    _updateTitle() {}
    _updateTitlePosition() {}
    _updateTile() {
        var _tile;
        var w = this.style.imageSize.w;
        var h = this.style.expandedHeight;
        var radius = Array.isArray(this.style.radius) && this.style.radius.length === 4 ? this.style.radius : Array(4).fill(this.style.radius);
        var tileRadius = radius;
        if (!this._collapse) {
            tileRadius = this._orientation === "horizontal" ? [ radius[0], 0, 0, radius[3] ] : [ radius[0], radius[1], 0, 0 ];
        }
        if (this._orientation !== "horizontal") {
            w = this.style.expandedWidth;
            h = this.style.imageSize.h;
        }
        var tile = this.tile;
        if (this.src) {
            tile = utils$1.clone({
                src: this.src
            }, this.tile);
        }
        this._Tile.patch(_objectSpread(_objectSpread({
            w: w,
            h: h
        }, tile), {}, {
            style: _objectSpread(_objectSpread({}, ((_tile = tile) === null || _tile === void 0 ? void 0 : _tile.style) || {}), {}, {
                radius: tileRadius
            }),
            persistentMetadata: true,
            alpha: this._shouldShowTile ? 1 : 0
        }));
    }
    _updateMetadata() {
        var metadataPatch = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, this.metadata), this._metadataPosition), this._metadataDimensions), {}, {
            mode: this.mode,
            alpha: this._shouldShowMetadata ? 1 : 0,
            style: this.style.metadata
        });
        if (this.style.marqueeOnFocus) {
            metadataPatch.marquee = this._isFocusedMode;
        }
        if (!this._Metadata) {
            metadataPatch.type = MetadataCardContent;
        }
        this.patch({
            Metadata: metadataPatch
        });
    }
    _updateSize() {
        var w = this.style.expandedWidth;
        var h = this.style.expandedHeight;
        if (this._collapse) {
            if (this._orientation === "horizontal") {
                w = this._collapseW;
            } else {
                h = this._collapseH;
            }
        }
        this.w = w;
        this.h = h;
    }
    _getSrc() {
        return this.tile && (this.tile.artwork && this.tile.artwork.src || this.tile.src) || this._src;
    }
    get _metadataDimensions() {
        var paddingHorizontal = this.style.paddingHorizontal * 2;
        var paddingVertical = this.style.paddingVertical * 2;
        var w = this.style.expandedWidth - this.style.imageSize.w - paddingHorizontal;
        var h = this.style.expandedHeight - paddingVertical;
        if (this.orientation !== "horizontal") {
            w = this.style.expandedWidth - paddingHorizontal;
            h = this.style.expandedHeight - this.style.imageSize.h - paddingVertical;
        }
        return {
            w: w,
            h: h
        };
    }
    get _metadataPosition() {
        var paddingHorizontal = this.style.paddingHorizontal;
        var paddingVertical = this.style.paddingVertical;
        var x = paddingHorizontal + (this._collapse ? 0 : this.style.imageSize.w);
        var y = paddingVertical;
        if (this.orientation !== "horizontal") {
            x = paddingHorizontal;
            y = paddingVertical + (this._collapse ? 0 : this.style.imageSize.h);
        }
        return {
            x: x,
            y: y
        };
    }
    get _shouldShowMetadata() {
        return !this._collapse || this.collapseToMetadata;
    }
    get _shouldShowTile() {
        return !this._collapse || this._collapse && !this.collapseToMetadata;
    }
    get _collapse() {
        return this.shouldCollapse && !this._isFocusedMode;
    }
    get _collapseW() {
        return this.collapseToMetadata ? this.style.expandedWidth - this.style.imageSize.w : this.style.imageSize.w;
    }
    get _collapseH() {
        return this.collapseToMetadata ? this.style.expandedHeight - this.style.imageSize.h : this.style.imageSize.h;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || [ this._Metadata && this._Metadata.announce, this._Tile && this._Tile.announce ];
    }
}

class CardContentHorizontal extends CardContent {
    static get __componentName() {
        return "CardContentHorizontal";
    }
    static get __themeStyle() {
        return styles$s;
    }
    _init() {
        this._orientation = "horizontal";
        super._init();
    }
}

var base$r = theme => {
    var {w: w, h: h} = utils$1.getDimensions(theme, {
        ratioX: 16,
        ratioY: 9,
        upCount: 3
    });
    return {
        expandedWidth: utils$1.getWidthByColumnSpan(theme, 8),
        expandedHeight: h,
        imageSize: {
            width: w,
            height: h
        },
        metadata: {
            descriptionTextStyle: {
                maxLines: 3
            }
        }
    };
};

var styles$r = Object.freeze({
    __proto__: null,
    base: base$r
});

class CardContentHorizontalLarge extends CardContentHorizontal {
    static get __componentName() {
        return "CardContentHorizontalLarge";
    }
    static get __themeStyle() {
        return styles$r;
    }
}

var base$q = theme => ({
    expandedWidth: utils$1.getWidthByUpCount(theme, 4),
    expandedHeight: utils$1.getDimensions(theme, {
        ratioX: 16,
        ratioY: 9,
        upCount: 4
    }).h + theme.spacer.xxxl * 7 + theme.spacer.lg + theme.spacer.xxs,
    metadata: {
        descriptionTextStyle: {
            maxLines: 3
        }
    },
    marqueeOnFocus: true
});

var styles$q = Object.freeze({
    __proto__: null,
    base: base$q
});

class CardContentVertical extends CardContent {
    static get __componentName() {
        return "CardContentVertical";
    }
    static get __themeStyle() {
        return styles$q;
    }
    _init() {
        this._orientation = "vertical";
        super._init();
    }
}

var base$p = theme => ({
    expandedHeight: utils$1.getDimensions(theme, {
        ratioX: 16,
        ratioY: 9,
        upCount: 4
    }).h + theme.spacer.md * 14,
    metadata: {
        descriptionTextStyle: {
            maxLines: 1
        }
    }
});

var styles$p = Object.freeze({
    __proto__: null,
    base: base$p
});

class CardContentVerticalSmall extends CardContentVertical {
    static get __componentName() {
        return "CardContentVerticalSmall";
    }
    static get __themeStyle() {
        return styles$p;
    }
    _setMetadata(metadata) {
        return _objectSpread(_objectSpread({}, metadata), {}, {
            details: undefined,
            provider: undefined
        });
    }
}

var base$o = theme => {
    var strokeWidth = theme.stroke.sm;
    var size = theme.spacer.xl;
    return {
        width: size,
        height: size,
        iconWidth: theme.spacer.md,
        iconHeight: theme.spacer.md,
        radius: theme.radius.xs,
        strokeWidth: strokeWidth
    };
};

var styles$o = Object.freeze({
    __proto__: null,
    base: base$o
});

class CheckboxSmall extends Checkbox {
    static get __themeStyle() {
        return styles$o;
    }
}

var base$n = theme => ({
    itemSpacing: theme.layout.gutterY,
    scrollIndex: 0,
    itemTransition: _objectSpread(_objectSpread({}, theme.animation.standardEntrance), {}, {
        duration: theme.animation.duration.fast
    })
});

var styles$n = Object.freeze({
    __proto__: null,
    base: base$n
});

class Column extends NavigationManager {
    static get __componentName() {
        return "Column";
    }
    static get __themeStyle() {
        return styles$n;
    }
    static _template() {
        return _objectSpread(_objectSpread({}, super._template()), {}, {
            direction: "column"
        });
    }
    _isOnScreenForScrolling(child) {
        if (!child) return false;
        var y = getY(child);
        if (!Number.isFinite(y)) return false;
        var itemsTransitionY = this.getTransitionYTargetValue();
        var columnY = this.core.renderContext.py;
        var itemY = columnY + itemsTransitionY + y;
        var yModifier;
        if (child.transition("y")) {
            yModifier = child.y - child.transition("y").targetValue;
            itemY = itemY - yModifier;
        }
        return itemY >= columnY && itemY + child.h <= columnY + this.h;
    }
    _shouldScroll() {
        if (this.alwaysScroll) {
            return true;
        }
        var shouldScroll = false;
        if (!this.neverScroll) {
            var isCompletelyOnScreen = this._isOnScreenForScrolling(this.selected);
            var lastChild = this.Items.childList.last;
            shouldScroll = lastChild && (this.shouldScrollUp() || this.shouldScrollDown() || !isCompletelyOnScreen);
        }
        if (this.selectedIndex < this.scrollIndex) {
            shouldScroll = false;
        }
        return shouldScroll;
    }
    _getScrollY() {
        var itemsContainerY;
        var itemIndex = this.selectedIndex - this.scrollIndex;
        itemIndex = itemIndex < 0 ? 0 : itemIndex;
        if (itemIndex === this._firstFocusableIndex()) {
            itemIndex = 0;
        }
        if (this.Items.children[itemIndex]) {
            itemsContainerY = this.Items.children[itemIndex].transition("y") ? -this.Items.children[itemIndex].transition("y").targetValue + this.itemPosY : -this.Items.children[itemIndex].y + this.itemPosY;
        }
        return itemsContainerY;
    }
    _render(next, prev) {
        this._prevLastScrollIndex = this._lastScrollIndex;
        if (this.plinko && prev && prev.selected && !(this.items.indexOf(prev) === 0 && prev.skipPlinko)) {
            var prevPlinko = this.checkSkipPlinko(prev, next);
            next.selectedIndex = this._getIndexOfItemNear(next, prevPlinko || prev);
        } else if (next && !next.selectedIndex) {
            next.selectedIndex = 0;
        }
        var itemsContainerY;
        if (!this.Items.children.length) {
            itemsContainerY = this.itemPosY;
        } else if (this._shouldScroll()) {
            itemsContainerY = this._getScrollY();
        }
        if (itemsContainerY !== undefined) {
            this.updatePositionOnAxis(this.Items, itemsContainerY);
        }
        this.onScreenEffect(this.onScreenItems);
    }
    _performRender() {
        this._render(this.selected, this.prevSelected);
    }
    checkSkipPlinko(prev, next) {
        if (!prev || !prev.skipPlinko || [ 0, this.items.length - 1 ].includes(this.items.indexOf(prev))) {
            return null;
        }
        var prevIndex = this.items.indexOf(prev);
        var direction = prevIndex - this.items.indexOf(next);
        var up = direction > 0;
        var prevItems = up ? this.items.slice(prevIndex).map((i => ({
            skipPlinko: i.skipPlinko,
            index: this.items.indexOf(i)
        }))) : this.items.slice(0, prevIndex + 1).map((i => ({
            skipPlinko: i.skipPlinko,
            index: this.items.indexOf(i)
        }))).reverse();
        var endOfMultiSkipPlinkos = prevItems.find((i => i.skipPlinko && !this.items[i.index + direction].skipPlinko));
        var prevPlinkoIndex = endOfMultiSkipPlinkos ? endOfMultiSkipPlinkos.index + direction : prevIndex + direction;
        return this.items[prevPlinkoIndex];
    }
    get _itemsY() {
        return getY(this.Items);
    }
    $removeItem(item) {
        if (item) {
            var wasSelected = item === this.selected;
            this.Items.childList.remove(item);
            this.queueRequestUpdate();
            if (wasSelected || this.selectedIndex >= this.items.length) {
                this.selectedIndex = this._selectedIndex;
            }
            if (!this.items.length) {
                this.fireAncestors("$columnEmpty");
            }
        }
    }
    $columnChanged() {
        this.queueRequestUpdate();
    }
    _isOnScreen(child) {
        if (!child) return false;
        return this._isComponentVerticallyVisible(child);
    }
    onScreenEffect() {}
}

var base$m = theme => {
    var paddingX = theme.spacer.lg;
    var radius = theme.radius.xl;
    var logoRadius = Math.max(radius - paddingX / 2, 0);
    return {
        height: theme.spacer.md * 8,
        iconStyle: {
            radius: radius,
            width: theme.spacer.xxxl,
            height: theme.spacer.xxxl
        },
        logoStyle: {
            radius: logoRadius,
            width: theme.spacer.md * 7,
            height: theme.spacer.md * 6
        },
        minWidth: theme.spacer.md * 9,
        paddingX: paddingX,
        paddingXNoTitle: theme.spacer.md,
        prefixPadding: theme.spacer.md,
        radius: radius,
        contentSpacing: theme.spacer.md
    };
};

var styles$m = Object.freeze({
    __proto__: null,
    base: base$m
});

class Control extends ButtonSmall {
    static get __componentName() {
        return "Control";
    }
    static get __themeStyle() {
        return styles$m;
    }
    static get properties() {
        return [ ...super.properties, "icon", "logo", "shouldCollapse" ];
    }
    static get aliasStyles() {
        return [ {
            prev: "titlePadding",
            curr: "contentSpacing"
        } ];
    }
    _update() {
        this._updatePrefixStyle();
        super._updateTitle();
        this._updateCollapseStatus();
        super._update();
    }
    _updateCollapseStatus() {
        if (this._Title) {
            this._Title.visible = !this._collapse;
        }
    }
    _updatePrefixStyle() {
        if (this._prefix) {
            if (this.logo) {
                this._updatePrefixObj(this.logo, {
                    style: _objectSpread({
                        color: undefined
                    }, this.style.logoStyle)
                });
            } else if (this.icon) {
                this._updatePrefixObj(this.icon, {
                    style: this.style.iconStyle
                });
            }
        }
    }
    _patchTitle(x, mountX) {
        this._Title.patch({
            x: x,
            mountX: mountX
        });
    }
    _updateContentPosition() {
        if (this._prefix && this._Title) {
            this._Content.patch({
                mountX: 0,
                x: this._paddingLeft
            });
            switch (this._justify) {
              case "left":
                this._patchTitle(0, 0);
                break;

              case "right":
                if (this.w < this._Prefix.w + this._Title.w) {
                    this._patchTitle(0, 0);
                } else {
                    var leftOverSpace = this.w - (this._paddingLeft + this._paddingRight + this._Prefix.w + this.style.contentSpacing);
                    this._patchTitle(leftOverSpace, 1);
                }
                break;

              case "center":
              default:
                if (this.fixed) {
                    if (this.w < this._Prefix.w + this._Title.w) {
                        this._patchTitle(0, 0);
                    } else {
                        var middle = (this.w - (this._paddingLeft + this._Prefix.w + this._paddingRight)) / 2;
                        this._patchTitle(middle, .5);
                    }
                } else if (this._Prefix !== undefined) {
                    var _middle = (this.w - (this._paddingLeft + this._Prefix.w + this.style.contentSpacing + this._paddingRight)) / 2;
                    this._patchTitle(_middle, .5);
                }
                break;
            }
        } else {
            super._updateContentPosition();
            this._Title && this._patchTitle(0, 0);
        }
    }
    _setPrefix() {
        return;
    }
    _setSuffix() {
        return;
    }
    _updatePrefixObj(icon) {
        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this._prefix = _objectSpread({
            type: Icon,
            icon: icon
        }, props);
    }
    _setIcon(icon) {
        if (!this.logo) {
            if (icon) {
                this._updatePrefixObj(icon, {
                    style: this.style.iconStyle
                });
            } else {
                this._prefix = icon;
            }
        }
        return icon;
    }
    _setLogo(logo) {
        if (logo) {
            this._updatePrefixObj(logo, {
                style: _objectSpread({
                    color: undefined
                }, this.style.logoStyle)
            });
        } else if (this.icon) {
            this._updatePrefixObj(this.icon, {
                style: this.style.iconStyle
            });
        } else {
            this._prefix = logo;
        }
        return logo;
    }
    get _paddingLeft() {
        return this.logo ? this.style.paddingXNoTitle : this.style.paddingX;
    }
    get _paddingRight() {
        return this.logo && (!this._hasTitle || this._collapse) ? this.style.paddingXNoTitle : this.style.paddingX;
    }
    get _collapse() {
        return this.shouldCollapse && !this._isFocusedMode;
    }
    get _announceComponentName() {
        return Control.__componentName;
    }
}

var base$l = theme => {
    var parentStyle = base$m(theme);
    var height = theme.spacer.md * 7;
    var radiusOffset = (parentStyle.height - height) / 2;
    var radius = Math.max(parentStyle.radius - radiusOffset, 0);
    var logoRadius = Math.max(radius - parentStyle.paddingX / 2, 0);
    return {
        height: height,
        logoStyle: {
            radius: logoRadius,
            height: theme.spacer.md * 5,
            width: theme.spacer.md * 6
        },
        radius: radius,
        minWidth: theme.spacer.md * 8,
        textStyle: theme.typography.button2
    };
};

var styles$l = Object.freeze({
    __proto__: null,
    base: base$l
});

class ControlSmall extends Control {
    static get __componentName() {
        return "ControlSmall";
    }
    static get __themeStyle() {
        return styles$l;
    }
}

var base$k = theme => ({
    width: getWidthByUpCount(theme, 1),
    titleMarginBottom: theme.spacer.lg,
    titleMarginLeft: theme.layout.gutterX,
    titleTextStyle: _objectSpread(_objectSpread({}, theme.typography.headline1), {}, {
        textColor: theme.color.textNeutral
    })
});

var tone$b = theme => ({
    neutral: {
        titleTextStyle: {
            textColor: theme.color.textNeutral
        }
    },
    inverse: {
        titleTextStyle: {
            textColor: theme.color.textInverse
        }
    },
    brand: {
        titleTextStyle: {
            textColor: theme.color.textNeutral
        }
    }
});

var styles$k = Object.freeze({
    __proto__: null,
    base: base$k,
    tone: tone$b
});

class TitleRow extends Row {
    static get __componentName() {
        return "TitleRow";
    }
    static get __themeStyle() {
        return styles$k;
    }
    static get properties() {
        return [ ...super.properties, "title" ];
    }
    static get tags() {
        return [ ...super.tags, "Title" ];
    }
    static get aliasStyles() {
        return [ {
            prev: "rowMarginTop",
            curr: "titleMarginBottom"
        } ];
    }
    _titleLoaded() {
        this._updateRow();
    }
    _construct() {
        super._construct();
        this._autoResizeHeight = true;
    }
    _update() {
        super._update();
        this._updateTitle();
        this._updateRow();
    }
    _autoResize() {
        this.w = this.w || this.style.w;
        this.h = this.autoResizeHeight ? this.Items.y + this.Items.h : this.h;
    }
    _updateTitle() {
        if (!this.title) {
            if (this._Title) {
                this.patch({
                    Title: undefined
                });
            }
            return;
        }
        var titlePatch = {
            x: this.style.titleMarginLeft,
            content: this.title,
            style: {
                textStyle: this.style.titleTextStyle
            }
        };
        if (!this._Title) {
            titlePatch = _objectSpread(_objectSpread({}, this._titleFirstLoadProps), titlePatch);
        }
        this.patch({
            Title: titlePatch
        });
    }
    get _titleFirstLoadProps() {
        return {
            type: TextBox,
            signals: {
                textBoxChanged: "_titleLoaded"
            }
        };
    }
    _updateRow() {
        this.applySmooth(this.Items, {
            y: this.title ? this._Title.finalH + this.style.titleMarginBottom : 0
        });
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || this._Title && this._Title.announce;
    }
}

var base$j = theme => ({
    extraItemSpacing: theme.spacer.lg
});

var styles$j = Object.freeze({
    __proto__: null,
    base: base$j
});

class ControlRow extends TitleRow {
    static get __componentName() {
        return "ControlRow";
    }
    static get __themeStyles() {
        return styles$j;
    }
    static _template() {
        return _objectSpread(_objectSpread({}, super._template()), {}, {
            alpha: 0,
            lazyScroll: true,
            signals: {
                selectedChange: "_getMoreItems"
            }
        });
    }
    static get properties() {
        return [ ...super.properties, "extraItemSpacing" ];
    }
    _construct() {
        super._construct();
        this._leftControls = [];
        this._contentItems = [];
        this._rightControls = [];
        this._lastLeftControlIndex = -1;
        this._lastItemIndex = -1;
        this._lazyLoadBuffer = 0;
    }
    _updateContent() {
        var itemsToAppend = [];
        if (this.leftControls.length) {
            itemsToAppend.push(...this._withExtraSpacing(this.leftControls, true));
        }
        if (this.contentItems.length) {
            itemsToAppend.push(...this._withExtraSpacing(this.contentItems));
        }
        if (this.rightControls.length) {
            itemsToAppend.push(...this.rightControls);
        }
        if (itemsToAppend.length) {
            this.patch({
                alpha: 1,
                items: itemsToAppend,
                selectedIndex: this.leftControls.length,
                startLazyScrollIndex: this.leftControls.length,
                stopLazyScrollIndex: this.leftControls.length + this.items.length - 1
            });
        }
    }
    _withExtraSpacing(items) {
        var isControl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var itemsCopy = [ ...items ];
        var prevItems = isControl ? this._prevLeftControls : this._prevItems;
        if (prevItems && prevItems.length && itemsCopy[prevItems.length - 1]) {
            itemsCopy[prevItems.length - 1].extraItemSpacing = 0;
        }
        itemsCopy[itemsCopy.length - 1].extraItemSpacing = this.extraItemSpacing == undefined ? this.style.extraItemSpacing : this.extraItemSpacing;
        if (isControl) {
            this._prevLeftControls = itemsCopy;
        } else {
            this._prevItems = itemsCopy;
        }
        return itemsCopy;
    }
    _getMoreItems() {
        if (this.lazyLoadBuffer) {
            var loadMoreIndex = this.contentItems.length - 1 - this.lazyLoadBuffer;
            if (this.selectedIndex - this.leftControls.length >= loadMoreIndex && this.selectedIndex < this.leftControls.length + this.contentItems.length) {
                this.loadMoreItems();
            }
        }
    }
    loadMoreItems() {
        this.signal("loadMoreItems");
    }
    _selectedChange(selected, prevSelected) {
        super._selectedChange(selected, prevSelected);
        this._getMoreItems();
    }
    _appendItemsAt(items, appendIndex, removeSpacingIndex) {
        var itemsCopy = [ ...items ];
        if (removeSpacingIndex != undefined && removeSpacingIndex >= 0) {
            this.items[removeSpacingIndex].extraItemSpacing = undefined;
            itemsCopy[itemsCopy.length - 1].extraItemSpacing = this.extraItemSpacing == undefined ? this.style.extraItemSpacing : this.extraItemSpacing;
        }
        this.appendItemsAt(itemsCopy, appendIndex);
    }
    addContentItems(items) {
        var lastSelected = this.selectedIndex;
        var itemsToAdd = this._createContentItems(items);
        var addIndex = this._lastItemIndex + 1;
        this._appendItemsAt(itemsToAdd, addIndex, this._lastItemIndex);
        this._lastItemIndex += itemsToAdd.length;
        if (this._contentItems) {
            this._contentItems = [ ...this.contentItems, ...itemsToAdd ];
        }
        this._updateContent();
        this.selectedIndex = lastSelected;
        this.patch({
            stopLazyScrollIndex: this.leftControls.length + this.items.length - 1
        });
    }
    addContentItemsAt(items, itemIndex) {
        var itemsToAdd = this._createContentItems(items);
        var addIndex = this._lastLeftControlIndex + 1 + itemIndex;
        if (addIndex === this._lastItemIndex + 1) {
            this.addContentItems(itemsToAdd);
        } else {
            this._appendItemsAt(itemsToAdd, addIndex);
            if (this._contentItems) {
                this._contentItems.splice(addIndex, 0, ...itemsToAdd);
                this._lastItemIndex = this.contentItems.length - 1;
            }
            this.patch({
                stopLazyScrollIndex: this.leftControls.length + this.items.length - 1
            });
        }
    }
    removeContentItemAt(index) {
        var removeIndex = this._lastLeftControlIndex + 1 + index;
        this.removeItemAt(removeIndex);
        this._lastItemIndex--;
        if (this._contentItems) {
            this._contentItems.splice(index, 1);
        }
        this.patch({
            startLazyScrollIndex: this.leftControls.length,
            stopLazyScrollIndex: this.leftControls.length + this.items.length - 1
        });
    }
    addLeftControls(controls) {
        var itemsToAdd = this._createControls(controls);
        var addIndex = this._lastLeftControlIndex + 1;
        this._appendItemsAt(itemsToAdd, addIndex, this._lastLeftControlIndex);
        if (this._leftControls) {
            this._leftControls = [ ...this._leftControls, ...controls ];
            this._lastLeftControlIndex = this._leftControls.length - 1;
            this._lastItemIndex += controls.length;
        }
        this.patch({
            startLazyScrollIndex: this.leftControls.length,
            stopLazyScrollIndex: this.leftControls.length + this.items.length - 1
        });
    }
    addLeftControlsAt(controls, index) {
        var itemsToAdd = this._createControls(controls);
        if (index === this._lastLeftControlIndex + 1) {
            this.addLeftControls(controls);
        } else {
            this._appendItemsAt(itemsToAdd, index);
            if (this.leftControls) {
                this._leftControls.splice(index, 0, ...controls);
                this._lastLeftControlIndex = this._leftControls.length - 1;
                this._lastItemIndex += controls.length;
            }
            this.patch({
                startLazyScrollIndex: this.leftControls.length,
                stopLazyScrollIndex: this.leftControls.length + this.items.length - 1
            });
        }
    }
    removeLeftControlAt(index) {
        this.removeItemAt(index);
        this._lastLeftControlIndex--;
        this._lastItemIndex--;
        if (this.leftControls) {
            this._leftControls.splice(index, 1);
        }
        this.patch({
            startLazyScrollIndex: this.leftControls.length,
            stopLazyScrollIndex: this.leftControls.length + this.items.length - 1
        });
    }
    addRightControls(controls) {
        this._rightControls.push(...controls);
        this._appendItemsAt(this._createControls(controls), this.items.length);
    }
    addRightControlsAt(controls, index) {
        var appendIndex = this._leftControls.length + this._contentItems.length + index;
        this._rightControls.splice(index, 0, ...controls);
        this._appendItemsAt(this._createControls(controls), appendIndex);
    }
    removeRightControlAt(index) {
        var removeIndex = this.leftControls.length + this.contentItems.length + index;
        this.removeItemAt(removeIndex);
        if (this.rightControls) {
            this._rightControls.splice(index, 1);
        }
    }
    _createControls(controls) {
        return controls.map((controlProps => _objectSpread({
            backgroundType: "fill",
            centerInParent: true
        }, controlProps)));
    }
    _createContentItems(contentItems) {
        var newContentItems = contentItems.map((itemProps => _objectSpread(_objectSpread({}, itemProps), {}, {
            centerInParent: true
        })));
        return newContentItems;
    }
    _setLeftControls(leftControls) {
        this._leftControls = this._createControls(leftControls);
        this._lastLeftControlIndex = leftControls.length - 1;
        this._updateContent();
    }
    _getLeftControls() {
        return this._leftControls;
    }
    _setRightControls(rightControls) {
        this._rightControls = this._createControls(rightControls);
        this._updateContent();
    }
    _getRightControls() {
        return this._rightControls;
    }
    _getContentItems() {
        return this._contentItems;
    }
    _setContentItems(items) {
        this._contentItems = this._createContentItems(items);
        this._lastItemIndex = this._lastLeftControlIndex + items.length;
        this._updateContent();
    }
    _getLeftControlItems() {
        if (this.leftControls.length) {
            return this.items.slice(0, this._lastLeftControlIndex + 1);
        }
        return [];
    }
    _getContentItemItems() {
        if (this.contentItems.length) {
            return this.items.slice(this._lastLeftControlIndex + 1, this._lastItemIndex + 1);
        }
        return [];
    }
    _getRightControlItems() {
        if (this.rightControls.length) {
            var leftSiblingIndex = this._lastItemIndex || this._lastLeftControlIndex;
            return leftSiblingIndex ? this.items.slice(leftSiblingIndex + 1) : this.items;
        }
        return [];
    }
    set leftControls(leftControls) {
        this._setLeftControls(leftControls);
    }
    get leftControls() {
        return this._getLeftControls();
    }
    set rightControls(rightControls) {
        this._setRightControls(rightControls);
    }
    get rightControls() {
        return this._getRightControls();
    }
    set contentItems(items) {
        this._setContentItems(items);
    }
    get contentItems() {
        return this._getContentItems();
    }
    set lazyLoadBuffer(lazyLoadBuffer) {
        this._lazyLoadBuffer = lazyLoadBuffer;
        this._getMoreItems();
    }
    get lazyLoadBuffer() {
        return this._lazyLoadBuffer;
    }
}

var base$i = theme => ({
    propertyTextStyle: _objectSpread(_objectSpread({}, theme.typography.headline1), {}, {
        textColor: theme.color.textNeutral
    }),
    valueTextStyle: _objectSpread(_objectSpread({}, theme.typography.body1), {}, {
        textColor: theme.color.textNeutral
    })
});

var styles$i = Object.freeze({
    __proto__: null,
    base: base$i
});

class Spacer extends Base$1 {
    static get __componentName() {
        return "Spacer";
    }
    static _template() {
        return {
            Line: {
                h: Spacer._lineThickness,
                rect: true,
                mountY: .5,
                TickLeft: _objectSpread(_objectSpread({}, Spacer._tick), {}, {
                    x: Spacer._lineThickness * -1
                }),
                TickRight: Spacer._tick
            }
        };
    }
    static get properties() {
        return [ "lineColor" ];
    }
    static get tags() {
        return [ "Line", "TickLeft", "TickRight" ];
    }
    static get _lineThickness() {
        return 3;
    }
    static get _tickLength() {
        return 25;
    }
    static get _tick() {
        return {
            rect: true,
            mountY: .5,
            w: Spacer._lineThickness,
            h: Spacer._tickLength,
            y: Spacer._lineThickness / 2
        };
    }
    _update() {
        this._Line.w = this.w;
        this._TickRight.x = this._Line.w;
        if (this.lineColor) {
            this._Line.color = this._TickLeft.color = this._TickRight.color = this.lineColor;
        }
        this.rotation = this.vertical ? Math.PI / 2 : 0;
        this.signal("spacerLoaded");
    }
}

class GridOverlay extends Base$1 {
    static get __componentName() {
        return "GridOverlay";
    }
    static get __themeStyle() {
        return styles$i;
    }
    static _template() {
        var textRow = {
            type: Row,
            autoResizeHeight: true,
            Items: {
                Property: {
                    type: TextBox,
                    signals: {
                        textBoxChanged: "_update"
                    }
                },
                Value: {
                    type: TextBox,
                    signals: {
                        textBoxChanged: "_update"
                    },
                    centerInParent: true
                }
            }
        };
        return {
            Columns: {
                alpha: .001,
                type: Row
            },
            Margins: {
                alpha: .001,
                Horizontal: {
                    Left: {
                        type: Spacer,
                        signals: {
                            spacerLoaded: "_update"
                        }
                    },
                    Right: {
                        type: Spacer,
                        signals: {
                            spacerLoaded: "_update"
                        }
                    }
                },
                Vertical: {
                    Top: {
                        type: Spacer,
                        vertical: true
                    }
                }
            },
            Safe: {
                alpha: .001,
                Horizontal: {
                    Left: {
                        type: Spacer,
                        signals: {
                            spacerLoaded: "_update"
                        }
                    },
                    Right: {
                        type: Spacer,
                        signals: {
                            spacerLoaded: "_update"
                        }
                    }
                },
                Vertical: {
                    Top: {
                        type: Spacer,
                        vertical: true
                    },
                    Bottom: {
                        type: Spacer,
                        vertical: true
                    }
                }
            },
            Gutters: {
                alpha: .001,
                Horizontal: {
                    type: Spacer,
                    signals: {
                        spacerLoaded: "_update"
                    }
                }
            },
            TextPanel: {
                alpha: .001,
                type: Column,
                autoResizeHeight: true,
                Items: {
                    ScreenW: textRow,
                    ScreenH: textRow,
                    ColumnCount: textRow,
                    MarginX: textRow,
                    MarginY: textRow,
                    GutterX: textRow,
                    GutterY: textRow,
                    Safe: textRow
                }
            }
        };
    }
    static get properties() {
        return [ "showColumns", "showMargins", "showSafe", "showGutters", "showText" ];
    }
    static get tags() {
        return [ "Columns", "Margins", {
            name: "MarginHorizontal",
            path: "Margins.Horizontal"
        }, {
            name: "MarginLeft",
            path: "Margins.Horizontal.Left"
        }, {
            name: "MarginRight",
            path: "Margins.Horizontal.Right"
        }, {
            name: "MarginVertical",
            path: "Margins.Vertical"
        }, {
            name: "MarginTop",
            path: "Margins.Vertical.Top"
        }, "Safe", {
            name: "SafeHorizontal",
            path: "Safe.Horizontal"
        }, {
            name: "SafeLeft",
            path: "Safe.Horizontal.Left"
        }, {
            name: "SafeRight",
            path: "Safe.Horizontal.Right"
        }, {
            name: "SafeVertical",
            path: "Safe.Vertical"
        }, {
            name: "SafeTop",
            path: "Safe.Vertical.Top"
        }, {
            name: "SafeBottom",
            path: "Safe.Vertical.Bottom"
        }, "Gutters", {
            name: "GutterHorizontal",
            path: "Gutters.Horizontal"
        }, "TextPanel", {
            name: "TextScreenW",
            path: "TextPanel.Items.ScreenW"
        }, {
            name: "TextScreenH",
            path: "TextPanel.Items.ScreenH"
        }, {
            name: "TextColumnCount",
            path: "TextPanel.Items.ColumnCount"
        }, {
            name: "TextMarginX",
            path: "TextPanel.Items.MarginX"
        }, {
            name: "TextMarginY",
            path: "TextPanel.Items.MarginY"
        }, {
            name: "TextGutterX",
            path: "TextPanel.Items.GutterX"
        }, {
            name: "TextGutterY",
            path: "TextPanel.Items.GutterY"
        }, {
            name: "TextSafe",
            path: "TextPanel.Items.Safe"
        } ];
    }
    _construct() {
        super._construct();
        this._showColumns = this._showMargins = this._showSafe = this._showGutters = this._showText = true;
    }
    _update() {
        this._updateGlobalThemeProps();
        this._updateMargins();
        this._updateSafe();
        this._updateColumns();
        this._updateGutters();
        this._updateText();
        this._updateVisibility();
    }
    _updateVisibility() {
        this._Columns.smooth = {
            alpha: Number(this.showColumns)
        };
        this._Margins.smooth = {
            alpha: Number(this.showMargins)
        };
        this._Safe.smooth = {
            alpha: Number(this.showSafe)
        };
        this._Gutters.smooth = {
            alpha: Number(this.showGutters)
        };
        this._TextPanel.smooth = {
            alpha: Number(this.showText)
        };
    }
    _updateGlobalThemeProps() {
        var {layout: layout, color: color} = contextInstance.theme;
        var {screenW: screenW, screenH: screenH, columnCount: columnCount, marginX: marginX, marginY: marginY, gutterX: gutterX, gutterY: gutterY, safe: safe} = layout;
        this._screenW = screenW;
        this._screenH = screenH;
        this._columnCount = columnCount;
        this._marginX = marginX;
        this._marginY = marginY;
        this._safe = safe;
        this._gutterX = gutterX;
        this._gutterY = gutterY;
        this._columnColor = color.interactiveNeutralFocusSoft;
        this._marginColor = color.green;
        this._safeColor = color.red;
        this._gutterColor = color.blue;
    }
    _updateMargins() {
        var marginPatch = {
            lineColor: this._marginColor
        };
        var marginHorizontalPatch = _objectSpread(_objectSpread({}, marginPatch), {}, {
            w: this._marginX
        });
        this._MarginHorizontal.y = this._screenH / 2;
        this._MarginLeft.patch(marginHorizontalPatch);
        this._MarginRight.patch(marginHorizontalPatch);
        this._MarginRight.x = this._screenW - this._marginX;
        var marginVerticalPatch = _objectSpread(_objectSpread({}, marginPatch), {}, {
            w: this._marginY
        });
        this._MarginVertical.x = this._marginX - marginVerticalPatch.w / 2;
        this._MarginTop.patch(marginVerticalPatch);
        this._MarginTop.patch(marginVerticalPatch);
        this._MarginTop.y = marginVerticalPatch.w / 2;
    }
    _updateSafe() {
        var safePatch = {
            lineColor: this._safeColor,
            w: this._safe
        };
        this._SafeHorizontal.y = this._screenH / 4;
        this._SafeLeft.patch(safePatch);
        this._SafeRight.patch(safePatch);
        this._SafeRight.x = this._screenW - this._safe;
        this._SafeVertical.x = (this._screenW - safePatch.w) / 2;
        this._SafeVertical.y = safePatch.w / 2;
        this._SafeTop.patch(safePatch);
        this._SafeBottom.patch(safePatch);
        this._SafeBottom.y = this._screenH - this._safe;
    }
    _updateColumns() {
        this._Columns.patch({
            w: this._screenW,
            h: this._screenH,
            x: this._marginX,
            style: {
                itemSpacing: this._gutterX
            },
            items: this._columnRects
        });
    }
    get _columnRects() {
        return Array.apply(null, {
            length: this._columnCount
        }).map((() => ({
            rect: true,
            w: getWidthByColumnSpan(this.theme, 1),
            h: this._screenH,
            color: this._columnColor
        })));
    }
    _updateGutters() {
        var gutterPatch = {
            lineColor: this._gutterColor,
            w: this._gutterY
        };
        this._GutterHorizontal.patch(_objectSpread(_objectSpread({}, gutterPatch), {}, {
            x: (this._screenW - gutterPatch.w) / 2,
            y: this._screenH / 4
        }));
    }
    _updatePropertyTextStyle(textPanelName, color) {
        var style = {
            textStyle: _objectSpread({}, this.style.propertyTextStyle)
        };
        if (color) {
            style.textStyle.textColor = color;
        }
        textPanelName.Items.tag("Property").style = style;
    }
    _updateValueTextStyle(textPanelName) {
        textPanelName.Items.tag("Value").style = {
            textStyle: this.style.valueTextStyle
        };
    }
    _updateText() {
        var prop = "Property";
        var val = "Value";
        this._TextPanel.x = this._screenW - this._marginX - getWidthByColumnSpan(this.theme, 3);
        this._TextPanel.y = this._safe;
        this._TextScreenW.Items.tag(prop).content = "Screen Width";
        this._TextScreenW.Items.tag(val).content = "".concat(this._screenW, "px");
        this._updatePropertyTextStyle(this._TextScreenW);
        this._updateValueTextStyle(this._TextScreenW);
        this._TextScreenH.Items.tag(prop).content = "Screen Height";
        this._TextScreenH.Items.tag(val).content = "".concat(this._screenH, "px");
        this._updatePropertyTextStyle(this._TextScreenH);
        this._updateValueTextStyle(this._TextScreenH);
        this._TextColumnCount.Items.tag(prop).content = "Columns";
        this._TextColumnCount.Items.tag(val).content = "".concat(this._columnCount, ", ").concat(Math.round(getWidthByColumnSpan(this.theme, 1)), "px each");
        this._updatePropertyTextStyle(this._TextColumnCount);
        this._updateValueTextStyle(this._TextColumnCount);
        this._TextMarginX.Items.tag(prop).content = "Margin-X";
        this._TextMarginX.Items.tag(val).content = "".concat(this._marginX, "px");
        this._updatePropertyTextStyle(this._TextMarginX, this._marginColor);
        this._updateValueTextStyle(this._TextMarginX);
        this._TextMarginY.Items.tag(prop).content = "Margin-Y";
        this._TextMarginY.Items.tag(val).content = "".concat(this._marginY, "px");
        this._updatePropertyTextStyle(this._TextMarginY, this._marginColor);
        this._updateValueTextStyle(this._TextMarginY);
        this._TextGutterX.Items.tag(prop).content = "Gutter-X";
        this._TextGutterX.Items.tag(val).content = "".concat(this._gutterX, "px");
        this._updatePropertyTextStyle(this._TextGutterX, this._gutterColor);
        this._updateValueTextStyle(this._TextGutterX);
        this._TextGutterY.Items.tag(prop).content = "Gutter-Y";
        this._TextGutterY.Items.tag(val).content = "".concat(this._gutterY, "px");
        this._updatePropertyTextStyle(this._TextGutterY, this._gutterColor);
        this._updateValueTextStyle(this._TextGutterY);
        this._TextSafe.Items.tag(prop).content = "Safe";
        this._TextSafe.Items.tag(val).content = "".concat(this._safe, "px");
        this._updatePropertyTextStyle(this._TextSafe, this._safeColor);
        this._updateValueTextStyle(this._TextSafe);
    }
}

var base$h = theme => ({
    cursorStyle: {
        textColor: theme.color.textNeutral,
        blink: true,
        width: theme.spacer.xs,
        height: theme.spacer.xxl
    },
    eyebrowTextStyle: _objectSpread(_objectSpread({}, theme.typography.caption1), {}, {
        maxLines: 1,
        textColor: theme.color.textNeutral
    }),
    textStyle: _objectSpread(_objectSpread({}, theme.typography.body1), {}, {
        maxLines: 1,
        textColor: theme.color.textNeutral
    }),
    helpTextStyle: _objectSpread(_objectSpread({}, theme.typography.caption1), {}, {
        maxLines: 1,
        textColor: theme.color.textNeutralSecondary
    }),
    minWidth: getWidthByUpCount(theme, 4),
    paddingX: theme.spacer.xl,
    paddingY: theme.spacer.xl,
    backgroundColor: theme.color.interactiveNeutral
});

var mode$6 = theme => ({
    disabled: {
        eyebrowTextStyle: {
            textColor: theme.color.textNeutralDisabled
        },
        helpTextStyle: {
            textColor: theme.color.textNeutralDisabled
        }
    },
    focused: {
        cursorStyle: {
            textColor: theme.color.textInverse
        },
        eyebrowTextStyle: {
            textColor: theme.color.textNeutral
        },
        helpTextStyle: {
            textColor: theme.color.textNeutralSecondary
        }
    }
});

var tone$a = theme => ({
    inverse: {
        mode: {
            focused: {
                eyebrowTextStyle: {
                    textColor: theme.color.textNeutral
                },
                helpTextStyle: {
                    textColor: theme.color.textNeutral
                }
            }
        }
    }
});

var styles$h = Object.freeze({
    __proto__: null,
    base: base$h,
    mode: mode$6,
    tone: tone$a
});

class Input extends Button {
    static get __componentName() {
        return "Input";
    }
    static get __themeStyle() {
        return styles$h;
    }
    static _template() {
        return _objectSpread(_objectSpread({}, super._template()), {}, {
            Eyebrow: {
                type: TextBox
            },
            HelpText: {
                type: TextBox
            }
        });
    }
    static get properties() {
        return [ ...super.properties, "actualTitle", "cursor", "eyebrow", "helpText", "listening", "mask", "password", "position" ];
    }
    static get tags() {
        return [ ...super.tags, "Eyebrow", "HelpText", {
            name: "Cursor",
            path: "Content.Cursor"
        }, {
            name: "HiddenContent",
            path: "Content.HiddenContent"
        } ];
    }
    _construct() {
        super._construct();
        this._title = "";
        this.actualTitle = "";
        this.position = this.title ? this.title.length : 0;
        this._justify = "left";
        this._fixed = true;
        this.w = this.style.minWidth;
    }
    $itemChanged() {
        super.$itemChanged();
        this._updateTextWrapper();
        this._updateHiddenContent();
        this._updateCursorPosition();
        this._updateTitleScrollPosition();
    }
    _onTitleTextBoxChanged() {
        this._updateHiddenContent();
    }
    _onHiddenTextBoxChanged() {
        this._updateCursorPosition();
    }
    _update() {
        this._updatePassword();
        super._update();
        this._updateEyebrow();
        this._updateHelpText();
        this._updateTextWrapper();
        this._updateHiddenContent();
        this._updateCursor();
        this._updateCursorListening();
        this._updateCursorBlink();
        this._updateCursorPosition();
        this._updateTitleScrollPosition();
    }
    _updatePassword() {
        this.title = this.password ? this.mask.repeat(this.actualTitle.length) : this.actualTitle;
    }
    _updateTruncation() {
        if (this._Title) {
            this._Title.patch({
                style: {
                    textStyle: _objectSpread(_objectSpread({}, this.style.textStyle), {}, {
                        wordWrap: false
                    })
                }
            });
        }
    }
    _updateEyebrow() {
        this._Eyebrow.patch({
            content: this.eyebrow,
            style: {
                textStyle: this.style.eyebrowTextStyle
            },
            mountY: 1,
            x: this.style.paddingX,
            y: this.y - this.style.paddingY
        });
    }
    _updateHelpText() {
        this._HelpText.patch({
            content: this.helpText,
            style: {
                textStyle: this.style.helpTextStyle
            },
            x: this.style.paddingX,
            y: this.y + this.innerH + this.style.paddingY
        });
    }
    _updateTextWrapper() {
        this._TextWrapper.clipping = true;
        this._TextWrapper.w = this._visibleContentWidth;
        if (this._Title) {
            this._TextWrapper.h = this._Title.h;
        }
    }
    _updateHiddenContent() {
        if (!this._HiddenContent) {
            this._Content.patch({
                HiddenContent: {
                    type: TextBox,
                    mountY: .5,
                    y: h => h / 2,
                    signals: {
                        textBoxChanged: "_onHiddenTextBoxChanged"
                    }
                }
            });
        }
        var {title: value = "", position: position, password: password, mask: mask} = this;
        var textBeforeCursor = password ? mask.repeat(value.length).substring(0, position) : value.substring(0, position);
        this._HiddenContent.patch({
            style: {
                textStyle: this.style.textStyle
            },
            content: textBeforeCursor
        });
        this._HiddenContent._Text && this._HiddenContent._Text.patch({
            alpha: .001
        });
    }
    _updateCursor() {
        if (this.style.cursorStyle && this.style.cursorStyle.blink) {
            if (!this._Cursor) {
                this._Content.patch({
                    Cursor: {
                        rect: true,
                        mountY: .5
                    }
                });
                this.cursorBlink = this._Cursor.animation({
                    duration: 1.5,
                    repeat: -1,
                    actions: [ {
                        p: "alpha",
                        v: {
                            0: 0,
                            .5: 1,
                            1: 0
                        }
                    } ]
                });
            }
            this._Cursor.patch(this.style.cursorStyle);
        }
    }
    _updateCursorListening() {
        if (!this._isDisabledMode) {
            if (this.cursorBlink && !this.cursorBlink.isPlaying()) {
                this.cursorBlink.start();
            }
        } else {
            if (this.cursorBlink) this.isCursorActive ? this.cursorBlink.start() : this.cursorBlink.stop();
        }
        this._Cursor.smooth = {
            color: this.style.cursorStyle.textColor
        };
    }
    _updateCursorBlink() {
        if (this.cursorBlink) {
            if (this.isCursorActive) {
                this.cursorBlink.start();
            } else {
                this.cursorBlink.stop();
                this._Cursor.patch({
                    alpha: .001
                });
            }
        }
    }
    _updateCursorPosition() {
        this._Cursor.x = this._titleX + (this._isOverflow ? this._TextWrapper.w : this._HiddenContent.w);
    }
    _updateTitleScrollPosition() {
        if (this._Title) {
            this._Title.x = this._isOverflow ? this._visibleContentWidth - this._HiddenContent.w : 0;
            if (this._HiddenContent && this._TextWrapper) {
                this._HiddenContent.x = this._TextWrapper.x + this._Title.x;
            }
        }
    }
    get _suffixX() {
        var suffixX = this._hasPrefix ? this.w - this._paddingLeft - this._paddingRight - this._prefixW : this.w - this._paddingLeft - this._paddingRight - this.style.paddingX;
        return suffixX > 0 ? suffixX : 0;
    }
    get isCursorActive() {
        return this.listening && (this._isFocusedMode || this._isUnfocusedMode);
    }
    get _isOverflow() {
        return this._HiddenContent.w > this._visibleContentWidth;
    }
    get _visibleContentWidth() {
        return this._fixedWordWrapWidth;
    }
    set value(value) {
        this.title = this.actualTitle = value;
        this.position = 0;
        this._updatePassword();
    }
    get value() {
        return this.actualTitle;
    }
    clear() {
        if (this.isCursorActive) {
            this.title = this.actualTitle = "";
            this.position = 0;
        }
    }
    insert(content) {
        if (this.isCursorActive) {
            this.actualTitle = this.actualTitle.slice(0, this.position) + content + this.actualTitle.slice(this.position);
            this._updatePassword();
            this.position += content.length;
        }
    }
    backspace() {
        if (this.isCursorActive && this.position > 0) {
            this.actualTitle = this.actualTitle.slice(0, this.position - 1) + this.actualTitle.slice(this.position);
            this._updatePassword();
            this.position--;
        }
    }
    _handleLeft() {
        if (this._isDisabledMode) {
            return false;
        }
        this.moveLeft();
        if (typeof this.onLeft === "function") {
            return this.onLeft(this);
        }
        return true;
    }
    _handleRight() {
        if (this._isDisabledMode) {
            return false;
        }
        this.moveRight();
        if (typeof this.onRight === "function") {
            return this.onRight(this);
        }
        return true;
    }
    moveLeft() {
        var {position: position} = this;
        if (position >= 0) {
            this.position--;
            return true;
        }
        return false;
    }
    moveRight() {
        var {position: position, title: title} = this;
        if (position < title.length) {
            this.position++;
            return true;
        }
        return false;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        if (this._announce) {
            return this._announce;
        }
        if (this.password) {
            return [ this.eyebrow, this.helpText ];
        } else {
            return [ this.eyebrow, "Input: " + this.title, this.helpText ];
        }
    }
}

var base$g = theme => {
    var textStyle = theme.typography.headline2;
    return {
        height: theme.spacer.md * 9,
        minWidth: theme.spacer.md * 7,
        paddingX: theme.spacer.md,
        textStyle: textStyle,
        sizes: {
            sm: 1,
            md: 2,
            lg: 3,
            xl: 4,
            xxl: 5
        },
        baseWidth: theme.spacer.md * 7,
        iconWidth: textStyle.lineHeight,
        iconHeight: textStyle.lineHeight
    };
};

var styles$g = Object.freeze({
    __proto__: null,
    base: base$g
});

var isUpperCase = string => /^[A-Z]$/.test(string);

var isAlphaChar = string => /^[A-Za-z]$/.test(string);

var alphaNato = {
    a: "alpha",
    b: "bravo",
    c: "charlie",
    d: "delta",
    e: "echo",
    f: "foxtrot",
    g: "golf",
    h: "hotel",
    i: "india",
    j: "juliett",
    k: "kilo",
    l: "lima",
    m: "mike",
    n: "november",
    o: "oscar",
    p: "papa",
    q: "quebec",
    r: "romeo",
    s: "sierra",
    t: "tango",
    u: "uniform",
    v: "victor",
    w: "whiskey",
    x: "x-ray",
    y: "yankee",
    z: "zulu"
};

function getNato(title) {
    if (isAlphaChar(title)) {
        return "".concat(title, ", ").concat(alphaNato[title.toLowerCase()]);
    }
    return title;
}

class Key extends Button {
    static get __componentName() {
        return "Key";
    }
    static get __themeStyle() {
        return styles$g;
    }
    static get properties() {
        return [ ...super.properties, "icon", "size", "toggle", "keySpacing" ];
    }
    static get aliasStyles() {
        return [ {
            prev: "iconH",
            curr: "iconHeight"
        }, {
            prev: "iconW",
            curr: "iconWidth"
        } ];
    }
    _construct() {
        super._construct();
        this._size = "sm";
        this._keySpacing = 0;
    }
    _update() {
        this._updatePrefixStyle();
        super._update();
    }
    _calcDynamicWidth() {
        var sizeMultiplier = this.style.sizes[this.size || "sm"];
        var baseSize = this.style.baseWidth * sizeMultiplier;
        var padding = this.keySpacing * (sizeMultiplier - 1);
        return baseSize + padding;
    }
    _updatePrefixStyle() {
        if (this._prefix && this.icon) {
            this._updatePrefixObj(this.icon, {
                style: this.style.iconStyle
            });
        }
    }
    _updatePrefixObj(icon) {
        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this._prefix = _objectSpread({
            type: Icon,
            icon: icon,
            w: this.style.iconWidth,
            h: this.style.iconHeight
        }, props);
    }
    _setIcon(icon) {
        if (icon) {
            this._updatePrefixObj(icon, {
                style: this.style.iconStyle
            });
        } else {
            this._prefix = icon;
        }
        return icon;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        if (this._announce) {
            return this._announce;
        }
        if (isUpperCase(this.title)) {
            return "Capital ".concat(getNato(this.title), ", button");
        }
        return getNato(this.title) + ", button";
    }
    _handleEnter() {
        if (typeof this.onEnter === "function") {
            return this.onEnter(this);
        } else {
            if (this.toggle) {
                this.fireAncestors("$toggleKeyboard", this.toggle);
            }
            this.fireAncestors("$onSoftKey", {
                key: this.keyId || this.title,
                toggle: this.toggle
            });
        }
        return false;
    }
}

var base$f = theme => ({
    keySpacing: theme.spacer.md,
    screenW: theme.layout.screenW,
    marginX: theme.layout.marginX,
    inputSpacing: theme.spacer.md * 10 + theme.spacer.md,
    inputStyle: {
        radius: theme.radius.md
    }
});

var styles$f = Object.freeze({
    __proto__: null,
    base: base$f
});

var capitalize = string => string.charAt(0).toUpperCase() + string.slice(1);

class Keyboard extends Base$1 {
    static get __componentName() {
        return "Keyboard";
    }
    static get __themeStyle() {
        return styles$f;
    }
    static get properties() {
        return [ "formats", "centerKeyboard", "rowWrap", "centerKeys", "keyComponent" ];
    }
    _init() {
        this._setShouldUpdateThemeBound = this._setShouldUpdateTheme.bind(this);
        contextInstance.on("themeUpdate", this._setShouldUpdateThemeBound);
        super._init();
    }
    _setShouldUpdateTheme() {
        this.shouldUpdateTheme = true;
    }
    _detach() {
        super._detach();
        contextInstance.off("themeUpdate", this._setShouldUpdateThemeBound);
    }
    _focus() {
        super._focus();
        this.fireAncestors("$keyboardFocused", true);
    }
    _getFocused() {
        return this._currentKeyboard || this;
    }
    _update() {
        if (!this._currentFormat || this._shouldUpdateKeyboards) {
            this._currentFormat = this.defaultFormat;
        }
        if (this.centerKeyboard) {
            this.x = this.centeredXPos;
        } else if (this.x === this.centeredXPos && !this.centerKeyboard) {
            this.x = 0;
        } else {
            this.x == null && (this.x = 0);
        }
        this._shouldUpdateKeyboards && this._createKeyboardsFromFormats();
        this._formatKeys();
    }
    _createKeyboardsFromFormats() {
        this.childList.clear();
        Object.keys(this.formats).forEach((key => {
            var format = this.formats[key];
            if (format) {
                var keyboardData = this._formatKeyboardData(format);
                this._createKeyboard(key, this._createRows(keyboardData, key));
            }
        }));
        this._formatsChanged = false;
    }
    _createKeyboard(key) {
        var rows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        key = capitalize(key);
        if (rows.length === 1) {
            this.patch({
                [key]: rows[0]
            });
        } else {
            this.patch({
                [key]: {
                    type: Column,
                    plinko: true,
                    items: rows,
                    style: {
                        itemSpacing: this.style.keySpacing
                    },
                    autoResizeWidth: true,
                    autoResizeHeight: true,
                    neverScroll: true,
                    alpha: key === capitalize(this._currentFormat) ? 1 : .001
                }
            });
        }
    }
    _createRows() {
        var rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var keyboard = arguments.length > 1 ? arguments[1] : undefined;
        return rows.map((keys => {
            var _this$_currentKeyboar;
            return {
                type: Row,
                autoResizeHeight: true,
                autoResizeWidth: true,
                centerInParent: this.centerKeys,
                neverScroll: true,
                wrapSelected: this.rowWrap !== undefined ? this.rowWrap : true,
                style: {
                    itemSpacing: this.style.keySpacing
                },
                items: this._createKeys(keys, keyboard),
                selectedIndex: ((_this$_currentKeyboar = this._currentKeyboard) === null || _this$_currentKeyboar === void 0 || (_this$_currentKeyboar = _this$_currentKeyboar.selected) === null || _this$_currentKeyboar === void 0 ? void 0 : _this$_currentKeyboar.selectedIndex) || 0
            };
        }));
    }
    _createKeys() {
        var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var keyboard = arguments.length > 1 ? arguments[1] : undefined;
        return keys.map((keyProps => {
            if (!keyProps) {
                return {
                    type: this.keyComponent || Key,
                    keySpacing: this.style.keySpacing,
                    skipFocus: true,
                    alpha: .01
                };
            }
            var key = {
                type: this.keyComponent || Key,
                keySpacing: this.style.keySpacing
            };
            if (typeof keyProps === "object") {
                var _this$style$keyProps, _this$style$keyProps2;
                var keyName = keyProps.keyId || keyProps.title;
                var keyOverrides = ((_this$style$keyProps = this.style.keyProps) === null || _this$style$keyProps === void 0 || (_this$style$keyProps = _this$style$keyProps[keyboard]) === null || _this$style$keyProps === void 0 ? void 0 : _this$style$keyProps[keyName]) || ((_this$style$keyProps2 = this.style.keyProps) === null || _this$style$keyProps2 === void 0 ? void 0 : _this$style$keyProps2[keyName]) || {};
                var keyPatch = _objectSpread(_objectSpread(_objectSpread({}, key), keyProps), keyOverrides);
                if (keyOverrides !== null && keyOverrides !== void 0 && keyOverrides.icon) {
                    keyPatch.style = _objectSpread(_objectSpread({}, keyOverrides.style), {}, {
                        iconStyle: _objectSpread({}, keyOverrides.iconStyle)
                    });
                }
                return keyPatch;
            }
            return _objectSpread(_objectSpread({}, key), {}, {
                title: keyProps
            });
        }));
    }
    _formatKeyboardData() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        if (Array.isArray(data) && data.length) {
            if (!Array.isArray(data[0]) && !this.inline) {
                var keyRows = [];
                var idx, counter;
                for (idx = 0, counter = -1; idx < data.length; idx++) {
                    if (idx % this.columnCount === 0) {
                        counter++;
                        keyRows[counter] = [];
                    }
                    keyRows[counter].push(data[idx]);
                }
                return keyRows;
            } else if (this.inline) {
                return [ data ];
            }
            return data;
        }
    }
    _formatKeys() {
        Object.keys(this.formats).forEach((format => {
            var element = this.tag(capitalize(format));
            if (element) {
                element.patch({
                    alpha: format === this._currentFormat ? 1 : .001,
                    style: {
                        itemSpacing: this.style.keySpacing
                    }
                });
                element.items.forEach((row => {
                    row.patch({
                        style: {
                            itemSpacing: this.style.keySpacing
                        },
                        centerInParent: this.centerKeys,
                        wrapSelected: this.rowWrap !== undefined ? this.rowWrap : true
                    });
                }));
                element.queueRequestUpdate();
            }
        }));
    }
    $toggleKeyboard(next) {
        var nextKeyboard = capitalize(next);
        if (next !== this._currentFormat) {
            var nextKeyboardTag = this.tag(nextKeyboard);
            this.selectKeyOn(nextKeyboardTag);
            this._currentKeyboard.alpha = .001;
            nextKeyboardTag.alpha = 1;
            this._currentFormat = next;
        }
    }
    selectKeyOn(keyboard) {
        var {row: row, column: column} = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelectedKey();
        if (keyboard && keyboard.constructor) {
            var type = keyboard.constructor.name;
            if (type === "Row") {
                keyboard.selectedIndex = column;
            } else {
                keyboard.selectedIndex = row;
                keyboard.selected.selectedIndex = column;
            }
        }
    }
    getSelectedKey() {
        var row, column;
        var keyboard = this._currentKeyboard;
        var type = keyboard.constructor.name;
        if (type === "Row") {
            row = 0;
            column = keyboard.selectedIndex;
        } else {
            row = keyboard.selectedIndex;
            column = keyboard.selected.selectedIndex;
        }
        return {
            row: row,
            column: column
        };
    }
    $itemChanged() {
        this.w = this._currentKeyboard.w;
        this.fireAncestors("$itemChanged");
        this.signal("keyboardWidthChanged");
    }
    _setFormats() {
        var formats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this._formatsChanged = true;
        return formats;
    }
    get centeredXPos() {
        return (this.style.screenW - this.w) / 2 - this.style.marginX;
    }
    get _shouldUpdateKeyboards() {
        return this.shouldUpdateTheme || this._formatsChanged;
    }
    set defaultFormat(format) {
        this._defaultFormat = format;
    }
    get defaultFormat() {
        return this._defaultFormat || Object.keys(this.formats)[0];
    }
    get _currentKeyboard() {
        return this._currentFormat ? this.tag(capitalize(this._currentFormat)) : null;
    }
    set columnCount(columnCount) {
        this._columnCount = columnCount;
    }
    get columnCount() {
        if (this._columnCount) return this._columnCount;
        if (this.rowCount) return this.formats[this.defaultFormat.toLowerCase()].length / this.rowCount;
        if (this.inline) return this.formats[this.defaultFormat.toLowerCase()].length; else return 11;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        if (this._announce) {
            return this._announce;
        }
        return "Keyboard" + (this.title ? ", ".concat(this.title) : "");
    }
    set announceContext(announceContext) {
        super.announceContext = announceContext;
    }
    get announceContext() {
        return this._announceContext || [ "PAUSE-2", "Use arrow keys to choose characters, press center to select" ];
    }
}

class KeyboardEmail extends Keyboard {
    static get __componentName() {
        return "KeyboardEmail";
    }
    static get __themeStyle() {
        return styles$f;
    }
    _construct() {
        super._construct();
        this.formats = this.emailFormat;
    }
    get emailFormat() {
        return {
            uppercase: [ [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", {
                title: "Delete",
                size: "md",
                keyId: "delete",
                announce: "delete, button"
            } ], [ "Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", {
                title: "#@!",
                size: "md",
                toggle: "symbols",
                announce: "symbol mode, button",
                keyId: "symbols"
            } ], [ "A", "S", "D", "F", "G", "H", "J", "K", "L", "@", {
                title: "",
                size: "md",
                toggle: "accents",
                announce: "accents, button",
                keyId: "accents"
            } ], [ "Z", "X", "C", "V", "B", "N", "M", {
                title: ".",
                announce: "period, button"
            }, {
                title: "-",
                announce: "dash, button"
            }, {
                title: "_",
                announce: "underscore, button"
            }, {
                title: "shift",
                size: "md",
                toggle: "lowercase",
                announce: "shift off, button",
                keyId: "shift"
            } ], [ {
                title: ".com",
                announce: "dot, com",
                size: "md"
            }, {
                title: ".net",
                announce: "dot, net",
                size: "md"
            }, {
                title: ".edu",
                announce: "dot, edu",
                size: "md"
            }, {
                title: ".org",
                announce: "dot, org",
                size: "md"
            }, {
                title: ".co",
                announce: "dot, co",
                size: "md"
            }, {
                title: ".uk",
                announce: "dot, uk",
                size: "md"
            } ], [ {
                title: "Clear",
                size: "lg",
                keyId: "clear",
                announce: "clear, button"
            }, {
                title: "Space",
                size: "xl",
                keyId: "space",
                announce: "space, button"
            }, {
                title: "Done",
                size: "lg",
                keyId: "done",
                announce: "done, button"
            } ] ],
            lowercase: [ [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", {
                title: "Delete",
                size: "md",
                keyId: "delete",
                announce: "delete, button"
            } ], [ "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", {
                title: "#@!",
                size: "md",
                toggle: "symbols",
                announce: "symbol mode, button",
                keyId: "symbols"
            } ], [ "a", "s", "d", "f", "g", "h", "j", "k", "l", "@", {
                title: "",
                size: "md",
                toggle: "accents",
                announce: "accents, button",
                keyId: "accents"
            } ], [ "z", "x", "c", "v", "b", "n", "m", {
                title: "_",
                announce: "underscore, button"
            }, {
                title: ".",
                announce: "period, button"
            }, {
                title: "-",
                announce: "dash, button"
            }, {
                title: "shift",
                size: "md",
                toggle: "uppercase",
                announce: "shift on, button",
                keyId: "shift"
            } ], [ {
                title: ".com",
                announce: "dot, com",
                size: "md"
            }, {
                title: ".net",
                announce: "dot, net",
                size: "md"
            }, {
                title: ".edu",
                announce: "dot, edu",
                size: "md"
            }, {
                title: ".org",
                announce: "dot, org",
                size: "md"
            }, {
                title: ".co",
                announce: "dot, co",
                size: "md"
            }, {
                title: ".uk",
                announce: "dot, uk",
                size: "md"
            } ], [ {
                title: "Clear",
                size: "lg",
                keyId: "clear",
                announce: "clear, button"
            }, {
                title: "Space",
                size: "xl",
                keyId: "space",
                announce: "space, button"
            }, {
                title: "Done",
                size: "lg",
                keyId: "done",
                announce: "done, button"
            } ] ],
            accents: [ [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", {
                title: "Delete",
                size: "md",
                keyId: "delete",
                announce: "delete, button"
            } ], [ "", "", "", "", "", "", "", "", "", "", {
                title: "#@!",
                size: "md",
                toggle: "symbols",
                announce: "symbol mode, button",
                keyId: "symbols"
            } ], [ "", "", "", "", "", "", "", "", "", "@", {
                title: "abc",
                size: "md",
                toggle: "lowercase",
                announce: "alpha mode, button"
            } ], [ "", "", "", "", "", {
                title: "_",
                announce: "underscore, button"
            }, {
                title: ".",
                announce: "period, button"
            }, {
                title: "-",
                announce: "dash, button"
            }, {
                title: "shift",
                size: "xl",
                toggle: "accentsUpper",
                announce: "shift off, button",
                keyId: "shift"
            } ], [ {
                title: ".com",
                announce: "dot, com",
                size: "md"
            }, {
                title: ".net",
                announce: "dot, net",
                size: "md"
            }, {
                title: ".edu",
                announce: "dot, edu",
                size: "md"
            }, {
                title: ".org",
                announce: "dot, org",
                size: "md"
            }, {
                title: ".co",
                announce: "dot, co",
                size: "md"
            }, {
                title: ".uk",
                announce: "dot, uk",
                size: "md"
            } ], [ {
                title: "Clear",
                size: "lg",
                keyId: "clear",
                announce: "clear, button"
            }, {
                title: "Space",
                size: "xl",
                keyId: "space",
                announce: "space, button"
            }, {
                title: "Done",
                size: "lg",
                keyId: "done",
                announce: "done, button"
            } ] ],
            accentsUpper: [ [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", {
                title: "Delete",
                size: "md",
                keyId: "delete",
                announce: "delete, button"
            } ], [ "", "", "", "", "", "", "", "", "", "", {
                title: "#@!",
                size: "md",
                toggle: "symbols",
                announce: "symbol mode, button",
                keyId: "symbols"
            } ], [ "", "", "", "", "", "", "", "", "", "@", {
                title: "abc",
                size: "md",
                toggle: "lowercase",
                announce: "alpha mode, button"
            } ], [ "", "", "", "", "", {
                title: ".",
                announce: "period, button"
            }, {
                title: "-",
                announce: "dash, button"
            }, {
                title: "_",
                announce: "underscore, button"
            }, {
                title: "shift",
                size: "xl",
                toggle: "accents",
                announce: "shift off, button",
                keyId: "shift"
            } ], [ {
                title: ".com",
                announce: "dot, com",
                size: "md"
            }, {
                title: ".net",
                announce: "dot, net",
                size: "md"
            }, {
                title: ".edu",
                announce: "dot, edu",
                size: "md"
            }, {
                title: ".org",
                announce: "dot, org",
                size: "md"
            }, {
                title: ".co",
                announce: "dot, co",
                size: "md"
            }, {
                title: ".uk",
                announce: "dot, uk",
                size: "md"
            } ], [ {
                title: "Clear",
                size: "lg",
                keyId: "clear",
                announce: "clear, button"
            }, {
                title: "Space",
                size: "xl",
                keyId: "space",
                announce: "space, button"
            }, {
                title: "Done",
                size: "lg",
                keyId: "done",
                announce: "done, button"
            } ] ],
            symbols: [ [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", {
                title: "Delete",
                size: "md",
                keyId: "delete",
                announce: "delete, button"
            } ], [ {
                title: "!",
                announce: "exclamation, button"
            }, "@", "#", "$", "%", {
                title: "^",
                announce: "caret circumflex, button"
            }, "&", "*", {
                title: "(",
                announce: "open parenthesis, button"
            }, {
                title: ")",
                announce: "close parenthesis, button"
            }, {
                title: "abc",
                size: "md",
                toggle: "lowercase",
                announce: "alpha mode, button"
            } ], [ {
                title: "{",
                announce: "open brace, button"
            }, {
                title: "}",
                announce: "close brace, button"
            }, {
                title: "[",
                announce: "open bracket, button"
            }, {
                title: "]",
                announce: "close bracket, button"
            }, {
                title: ";",
                announce: "semicolon, button"
            }, {
                title: '"',
                announce: "doublequote, button"
            }, {
                title: ",",
                announce: "comma, button"
            }, {
                title: "|",
                announce: "vertical bar, button"
            }, {
                title: "\\",
                announce: "backslash, button"
            }, {
                title: "/",
                announce: "forwardslash, button"
            }, {
                title: "",
                size: "md",
                toggle: "accents",
                announce: "accents, button",
                keyId: "accents"
            } ], [ {
                title: "<",
                announce: "less than, button"
            }, {
                title: ">",
                announce: "greater than, button"
            }, {
                title: "?",
                announce: "question mark, button"
            }, {
                title: "=",
                announce: "equal sign, button"
            }, {
                title: "`",
                announce: "grave accent, button"
            }, {
                title: "~",
                announce: "tilde, button"
            }, {
                title: "_",
                announce: "underscore, button"
            }, {
                title: ":",
                announce: "colon, button"
            }, {
                title: "-",
                announce: "dash, button"
            }, {
                title: "+",
                announce: "plus sign, button"
            } ], [ {
                title: ".com",
                announce: "dot, com",
                size: "md"
            }, {
                title: ".net",
                announce: "dot, net",
                size: "md"
            }, {
                title: ".edu",
                announce: "dot, edu",
                size: "md"
            }, {
                title: ".org",
                announce: "dot, org",
                size: "md"
            }, {
                title: ".co",
                announce: "dot, co",
                size: "md"
            }, {
                title: ".uk",
                announce: "dot, uk",
                size: "md"
            } ], [ {
                title: "Clear",
                size: "lg",
                keyId: "clear",
                announce: "clear, button"
            }, {
                title: "Space",
                size: "xl",
                keyId: "space",
                announce: "space, button"
            }, {
                title: "Done",
                size: "lg",
                keyId: "done",
                announce: "done, button"
            } ] ]
        };
    }
}

class KeyboardFullScreen extends Keyboard {
    static get __componentName() {
        return "KeyboardFullScreen";
    }
    static get __themeStyle() {
        return styles$f;
    }
    _construct() {
        super._construct();
        this.formats = this.fullscreenFormat;
    }
    get fullscreenFormat() {
        return {
            letters: [ [ "", "", "", "", "", "", "", "", "", {
                title: "#@!",
                size: "lg",
                toggle: "symbols",
                announce: "symbol mode, button",
                keyId: "symbols"
            }, {
                title: "Space",
                size: "lg",
                keyId: "space",
                announce: "space, button"
            }, {
                title: "Delete",
                size: "md",
                keyId: "delete",
                announce: "delete, button"
            }, "", "", "", "", "", "", "", "", "" ], [ "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" ] ],
            symbols: [ [ "", "", "", "", "", "", "", "", "", {
                title: "ABC",
                size: "lg",
                toggle: "letters",
                announce: "caps on, button"
            }, {
                title: "Space",
                size: "lg",
                keyId: "space",
                announce: "space, button"
            }, {
                title: "Delete",
                size: "md",
                keyId: "delete",
                announce: "delete, button"
            }, "", "", "", "", "", "", "", "", "" ], [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", {
                title: "!",
                announce: "exclamation, button"
            }, "@", "#", "$", "%", {
                title: "^",
                announce: "caret circumflex, button"
            }, "&", "*", {
                title: "(",
                announce: "open parenthesis, button"
            }, {
                title: ")",
                announce: "close parenthesis, button"
            }, {
                title: "`",
                announce: "grave accent, button"
            }, "~", "_", ".", "-", "+" ] ]
        };
    }
}

class KeyboardNumbers extends Keyboard {
    static get __componentName() {
        return "KeyboardNumbers";
    }
    static get __themeStyle() {
        return styles$f;
    }
    _construct() {
        super._construct();
        this.formats = this.numbersFormat;
    }
    get numbersFormat() {
        return {
            numbers: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0" ],
            dialpad: [ [ "1", "2", "3" ], [ "4", "5", "6" ], [ "7", "8", "9" ], [ "0" ] ],
            dialpadExtended: [ [ "1", "2", "3" ], [ "4", "5", "6" ], [ "7", "8", "9" ], [ "0", {
                title: "Delete",
                size: "md",
                keyId: "delete",
                announce: "delete, button"
            } ] ]
        };
    }
}

class KeyboardQwerty extends Keyboard {
    static get __componentName() {
        return "KeyboardQwerty";
    }
    static get __themeStyle() {
        return styles$f;
    }
    _construct() {
        super._construct();
        this.formats = this.qwertyFormat;
    }
    get qwertyFormat() {
        return {
            uppercase: [ [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", {
                title: "Delete",
                size: "md",
                keyId: "delete",
                announce: "delete, button"
            } ], [ "Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", {
                title: "#@!",
                size: "md",
                toggle: "symbols",
                announce: "symbol mode, button",
                keyId: "symbols"
            } ], [ "A", "S", "D", "F", "G", "H", "J", "K", "L", "@", {
                title: "",
                size: "md",
                toggle: "accents",
                announce: "accents, button",
                keyId: "accents"
            } ], [ "Z", "X", "C", "V", "B", "N", "M", {
                title: "_",
                announce: "underscore, button"
            }, {
                title: ".",
                announce: "period, button"
            }, {
                title: "-",
                announce: "dash, button"
            }, {
                title: "shift",
                size: "md",
                toggle: "lowercase",
                announce: "shift off, button",
                keyId: "shift"
            } ], [ {
                title: "Clear",
                size: "lg",
                keyId: "clear",
                announce: "clear, button"
            }, {
                title: "Space",
                size: "xl",
                keyId: "space",
                announce: "space, button"
            }, {
                title: "Done",
                size: "lg",
                keyId: "done",
                announce: "done, button"
            } ] ],
            lowercase: [ [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", {
                title: "Delete",
                size: "md",
                keyId: "delete",
                announce: "delete, button"
            } ], [ "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", {
                title: "#@!",
                size: "md",
                toggle: "symbols",
                announce: "symbol mode, button",
                keyId: "symbols"
            } ], [ "a", "s", "d", "f", "g", "h", "j", "k", "l", "@", {
                title: "",
                size: "md",
                toggle: "accents",
                announce: "accents, button",
                keyId: "accents"
            } ], [ "z", "x", "c", "v", "b", "n", "m", {
                title: "_",
                announce: "underscore, button"
            }, {
                title: ".",
                announce: "period, button"
            }, {
                title: "-",
                announce: "dash, button"
            }, {
                title: "shift",
                size: "md",
                toggle: "uppercase",
                announce: "shift on, button",
                keyId: "shift"
            } ], [ {
                title: "Clear",
                size: "lg",
                keyId: "clear",
                announce: "clear, button"
            }, {
                title: "Space",
                size: "xl",
                keyId: "space",
                announce: "space, button"
            }, {
                title: "Done",
                size: "lg",
                keyId: "done",
                announce: "done, button"
            } ] ],
            accents: [ [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", {
                title: "Delete",
                size: "md",
                keyId: "delete",
                announce: "delete, button"
            } ], [ "", "", "", "", "", "", "", "", "", "", {
                title: "#@!",
                size: "md",
                toggle: "symbols",
                announce: "symbol mode, button",
                keyId: "symbols"
            } ], [ "", "", "", "", "", "", "", "", "", "@", {
                title: "abc",
                size: "md",
                toggle: "lowercase",
                announce: "alpha mode, button"
            } ], [ "", "", "", "", "", {
                title: "_",
                announce: "underscore, button"
            }, {
                title: ".",
                announce: "period, button"
            }, {
                title: "-",
                announce: "dash, button"
            }, {
                title: "shift",
                size: "xl",
                toggle: "accentsUpper",
                announce: "shift off, button",
                keyId: "shift"
            } ], [ {
                title: "Clear",
                size: "lg",
                keyId: "clear",
                announce: "clear, button"
            }, {
                title: "Space",
                size: "xl",
                keyId: "space",
                announce: "space, button"
            }, {
                title: "Done",
                size: "lg",
                keyId: "done",
                announce: "done, button"
            } ] ],
            accentsUpper: [ [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", {
                title: "Delete",
                size: "md",
                keyId: "delete",
                announce: "delete, button"
            } ], [ "", "", "", "", "", "", "", "", "", "", {
                title: "#@!",
                size: "md",
                toggle: "symbols",
                announce: "symbol mode, button",
                keyId: "symbols"
            } ], [ "", "", "", "", "", "", "", "", "", "@", {
                title: "abc",
                size: "md",
                toggle: "lowercase",
                announce: "alpha mode, button"
            } ], [ "", "", "", "", "", {
                title: ".",
                announce: "period, button"
            }, {
                title: "-",
                announce: "dash, button"
            }, {
                title: "_",
                announce: "underscore, button"
            }, {
                title: "shift",
                size: "xl",
                toggle: "accents",
                announce: "shift off, button",
                keyId: "shift"
            } ], [ {
                title: "Clear",
                size: "lg",
                keyId: "clear",
                announce: "clear, button"
            }, {
                title: "Space",
                size: "xl",
                keyId: "space",
                announce: "space, button"
            }, {
                title: "Done",
                size: "lg",
                keyId: "done",
                announce: "done, button"
            } ] ],
            symbols: [ [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", {
                title: "Delete",
                size: "md",
                keyId: "delete",
                announce: "delete, button"
            } ], [ {
                title: "!",
                announce: "exclamation, button"
            }, "@", "#", "$", "%", {
                title: "^",
                announce: "caret circumflex, button"
            }, "&", "*", {
                title: "(",
                announce: "open parenthesis, button"
            }, {
                title: ")",
                announce: "close parenthesis, button"
            }, {
                title: "abc",
                size: "md",
                toggle: "lowercase",
                announce: "alpha mode, button"
            } ], [ {
                title: "{",
                announce: "open brace, button"
            }, {
                title: "}",
                announce: "close brace, button"
            }, {
                title: "[",
                announce: "open bracket, button"
            }, {
                title: "]",
                announce: "close bracket, button"
            }, {
                title: ";",
                announce: "semicolon, button"
            }, {
                title: '"',
                announce: "doublequote, button"
            }, {
                title: ",",
                announce: "comma, button"
            }, {
                title: "|",
                announce: "vertical bar, button"
            }, {
                title: "\\",
                announce: "backslash, button"
            }, {
                title: "/",
                announce: "forwardslash, button"
            }, {
                title: "",
                size: "md",
                toggle: "accents",
                announce: "accents, button",
                keyId: "accents"
            } ], [ {
                title: "<",
                announce: "less than, button"
            }, {
                title: ">",
                announce: "greater than, button"
            }, {
                title: "?",
                announce: "question mark, button"
            }, {
                title: "=",
                announce: "equal sign, button"
            }, {
                title: "`",
                announce: "grave accent, button"
            }, {
                title: "~",
                announce: "tilde, button"
            }, {
                title: "_",
                announce: "underscore, button"
            }, {
                title: ":",
                announce: "colon, button"
            }, {
                title: "-",
                announce: "dash, button"
            }, {
                title: "+",
                announce: "plus sign, button"
            } ], [ {
                title: "Clear",
                size: "lg",
                keyId: "clear",
                announce: "clear, button"
            }, {
                title: "Space",
                size: "xl",
                keyId: "space",
                announce: "space, button"
            }, {
                title: "Done",
                size: "lg",
                keyId: "done",
                announce: "done, button"
            } ] ]
        };
    }
}

class KeyboardInput extends Base$1 {
    static get __componentName() {
        return "KeyboardInput";
    }
    static get properties() {
        return [ "centerKeyboard", "defaultFormat", "input", "keyboardType" ];
    }
    static get __themeStyle() {
        return styles$f;
    }
    static _template() {
        return {
            Wrapper: {
                type: Column,
                neverScroll: true,
                w: this.w,
                items: [ {
                    type: Input,
                    ref: "Input"
                }, {
                    type: Keyboard,
                    ref: "Keyboard",
                    passSignals: {
                        keyboardWidthChanged: true
                    }
                } ],
                selectedIndex: 1,
                signals: {
                    keyboardWidthChanged: "_updateWidth"
                }
            }
        };
    }
    static get tags() {
        return [ "Wrapper", {
            name: "Input",
            path: "Wrapper.Input"
        }, {
            name: "Keyboard",
            path: "Wrapper.Keyboard"
        } ];
    }
    _update() {
        this._Wrapper.style.itemSpacing = this.style.inputSpacing;
        this._updateKeyboardType();
        this._updateInput();
        this._updateKeyboard();
        this._updateCenterKeyboard();
    }
    _updateKeyboardType() {
        if (this._Keyboard.constructor !== this.keyboardType) {
            this._Wrapper._resetItems();
            this._Wrapper.items = [ {
                type: Input,
                ref: "Input"
            }, {
                type: this.keyboardType,
                ref: "Keyboard",
                passSignals: {
                    keyboardWidthChanged: true
                }
            } ];
        }
    }
    _updateInput() {
        this._Input.patch(_objectSpread(_objectSpread({}, this.input), {}, {
            centerInParent: this.centerKeyboard,
            w: this._Keyboard.w,
            style: _objectSpread({}, this.style.inputStyle),
            listening: this._isFocusedMode
        }));
    }
    _updateKeyboard() {
        this._Keyboard.patch({
            defaultFormat: this.defaultFormat || "lowercase",
            centerKeyboard: this.centerKeyboard
        });
    }
    _updateWidth() {
        this._Input.w = this.w = this._Keyboard.w;
        this.fireAncestors("$itemChanged");
    }
    _updateCenterKeyboard() {
        if (this.centerKeyboard) {
            this.x = (this.style.screenW - this.w) / 2 - this.style.marginX;
        } else {
            this.x = 0;
        }
    }
    $onSoftKey(_ref22) {
        var {key: key = "", toggle: toggle} = _ref22;
        if (toggle) {
            return;
        }
        switch (key.toLowerCase()) {
          case "delete":
            this._Input.backspace();
            break;

          case "done":
            break;

          case "space":
            this._Input.insert(" ");
            break;

          case "clear":
            this._Input.clear();
            break;

          default:
            this._Input.insert(key);
        }
    }
    $keyboardFocused(focus) {
        if (focus) {
            this._Input.listening = true;
        } else {
            this._Input.listening = false;
        }
    }
    _getFocused() {
        return this._Wrapper || this;
    }
}

class KeyboardSearch extends Keyboard {
    static get __componentName() {
        return "KeyboardSearch";
    }
    static get __themeStyle() {
        return styles$f;
    }
    _construct() {
        super._construct();
        this.formats = this.searchFormat;
    }
    get searchFormat() {
        return {
            uppercase: [ [ "A", "B", "C", "D", "E", "F" ], [ "G", "H", "I", "J", "K", "L" ], [ "M", "N", "O", "P", "Q", "R" ], [ "S", "T", "U", "V", "W", "X" ], [ "Y", "Z", {
                title: "1",
                keyId: "number"
            }, {
                title: "2",
                keyId: "number"
            }, {
                title: "3",
                keyId: "number"
            }, {
                title: "4",
                keyId: "number"
            } ], [ {
                title: "5",
                keyId: "number"
            }, {
                title: "6",
                keyId: "number"
            }, {
                title: "7",
                keyId: "number"
            }, {
                title: "8",
                keyId: "number"
            }, {
                title: "9",
                keyId: "number"
            }, {
                title: "0",
                keyId: "number"
            } ], [ {
                title: "Space",
                size: "xl",
                keyId: "space",
                announce: "space, button"
            }, {
                title: "Delete",
                size: "md",
                keyId: "delete",
                announce: "delete, button"
            } ] ]
        };
    }
}

var base$e = theme => {
    var size = theme.spacer.lg;
    return {
        width: size,
        height: size,
        radius: size / 2
    };
};

var tone$9 = theme => ({
    neutral: {
        circleColor: theme.color.interactiveNeutralFocus,
        mode: {
            disabled: {
                circleColor: theme.color.fillNeutralDisabled
            }
        }
    },
    inverse: {
        circleColor: theme.color.interactiveInverseFocus,
        mode: {
            disabled: {
                circleColor: theme.color.fillInverseDisabled
            }
        }
    },
    brand: {
        circleColor: theme.color.interactiveBrandFocus,
        mode: {
            disabled: {
                circleColor: theme.color.fillInverseDisabled
            }
        }
    }
});

var styles$e = Object.freeze({
    __proto__: null,
    base: base$e,
    tone: tone$9
});

class Knob extends Base$1 {
    static get __componentName() {
        return "Knob";
    }
    static get __themeStyle() {
        return styles$e;
    }
    static _template() {
        return {
            mount: .5
        };
    }
    _update() {
        this._updateLayout();
    }
    _updateLayout() {
        this.patch({
            texture: lng.Tools.getRoundRect(this.w, this.h, getMaxRoundRadius(this.style.radius, this.w, this.h), null, null, true, this.style.circleColor)
        });
    }
}

var base$d = theme => ({
    alpha: theme.alpha.primary,
    descriptionTextStyle: _objectSpread(_objectSpread({}, theme.typography.body3), {}, {
        maxLines: 1,
        textColor: theme.color.textNeutralSecondary
    }),
    height: theme.spacer.xxl * 3,
    logoStyle: {
        width: theme.spacer.xxl * 2,
        height: theme.spacer.xxl * 2,
        radius: theme.radius.sm
    },
    paddingX: theme.spacer.xl,
    contentSpacing: theme.spacer.lg,
    titleTextStyle: _objectSpread(_objectSpread({}, theme.typography.headline3), {}, {
        maxLines: 1,
        textColor: theme.color.textNeutral
    }),
    width: utils$1.getWidthByColumnSpan(theme, 3)
});

var mode$5 = theme => ({
    disabled: {
        alpha: theme.alpha.inactive,
        descriptionTextStyle: {
            textColor: theme.color.textNeutralDisabled
        },
        titleTextStyle: {
            textColor: theme.color.textNeutralDisabled
        }
    },
    focused: {
        descriptionTextStyle: {
            textColor: theme.color.textInverseSecondary
        },
        titleTextStyle: {
            textColor: theme.color.textInverse
        }
    }
});

var tone$8 = theme => ({
    inverse: {
        mode: {
            focused: {
                descriptionTextStyle: {
                    textColor: theme.color.textNeutral
                },
                titleTextStyle: {
                    textColor: theme.color.textNeutral
                }
            }
        }
    }
});

var styles$d = Object.freeze({
    __proto__: null,
    base: base$d,
    mode: mode$5,
    tone: tone$8
});

class ListItem extends Button {
    static get __componentName() {
        return "ListItem";
    }
    static get __themeStyle() {
        return styles$d;
    }
    static _template() {
        return _objectSpread(_objectSpread({}, super._template()), {}, {
            justify: "left",
            fixed: true,
            Content: _objectSpread(_objectSpread({}, super._template().Content), {}, {
                TextWrapper: {
                    mountY: .5,
                    flex: {
                        direction: "column"
                    },
                    Title: {
                        type: TextBox,
                        signals: {
                            textBoxChanged: "_onTextBoxChanged"
                        }
                    }
                }
            })
        });
    }
    static get properties() {
        return [ ...super.properties, "description", "prefixLogo", "suffixLogo", "shouldCollapse" ];
    }
    static get aliasStyles() {
        return [ {
            prev: "titlePadding",
            curr: "contentSpacing"
        } ];
    }
    static get tags() {
        return [ ...super.tags, {
            name: "Description",
            path: "Content.TextWrapper.Description"
        } ];
    }
    _onTextBoxChanged() {
        this._updateTitle();
        this._updateDescription();
        this._updateTruncation();
    }
    _update() {
        this._updatePrefixLogo();
        this._updateSuffixLogo();
        super._update();
        this._updateDescription();
    }
    _updateTitle() {
        this._TextWrapper.patch({
            Title: {
                content: this.title,
                style: {
                    textStyle: this.style.titleTextStyle
                }
            }
        });
    }
    _updateDescription() {
        if (this._hasDescription) {
            var descriptionPatch = {
                content: this.description,
                style: {
                    textStyle: _objectSpread(_objectSpread({}, this.style.descriptionTextStyle), {}, {
                        wordWrap: true,
                        wordWrapWidth: this._fixedWordWrapWidth
                    })
                },
                visible: !this._collapse
            };
            if (!this._Description) {
                descriptionPatch = _objectSpread({
                    type: TextBox,
                    signals: {
                        textBoxChanged: "_onTextBoxChanged"
                    }
                }, descriptionPatch);
            }
            this._TextWrapper.patch({
                Description: descriptionPatch
            });
        } else {
            this._TextWrapper.patch({
                Description: undefined
            });
        }
    }
    _updateTruncation() {
        if (this._Title) {
            this._Title.patch({
                style: {
                    textStyle: _objectSpread(_objectSpread({}, this.style.titleTextStyle), {}, {
                        wordWrap: this.fixed,
                        wordWrapWidth: this.fixed ? this._fixedWordWrapWidth : 0
                    })
                }
            });
        }
    }
    _updatePrefixLogo() {
        if (this._hasPrefixLogo) {
            this._prefix = this._addLogoProps(this._prefixLogo);
        }
    }
    _updateSuffixLogo() {
        if (this._hasSuffixLogo) {
            this._suffix = this._addLogoProps(this._suffixLogo);
        }
    }
    _addLogoProps(icon) {
        return {
            type: Icon,
            icon: icon,
            style: _objectSpread({
                color: undefined
            }, this.style.logoStyle)
        };
    }
    get _hasPrefixLogo() {
        return this.prefixLogo;
    }
    get _hasSuffixLogo() {
        return this.suffixLogo;
    }
    get _rowProps() {
        return _objectSpread(_objectSpread({}, super._rowProps), {}, {
            autoResizeHeight: true
        });
    }
    get _buttonProps() {
        return _objectSpread(_objectSpread({}, super._buttonProps), {}, {
            alpha: this.style.alpha
        });
    }
    get _hasDescription() {
        return !!this.description;
    }
    get _suffixX() {
        return this.w - this._paddingRight - this._suffixW - this.style.paddingX;
    }
    get _collapse() {
        return this.shouldCollapse && !this._isFocusedMode;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        if (this._announce) {
            return this._announce;
        }
        return this.title + this.description + ", List Item";
    }
}

var base$c = () => ({
    showArrows: false,
    showKnob: false
});

var mode$4 = () => ({
    focused: {
        showArrows: true
    }
});

var tone$7 = theme => ({
    neutral: {
        mode: {
            focused: {
                arrowColor: theme.color.fillInverse,
                progressBar: {
                    barColor: theme.color.fillInverseTertiary,
                    progressColor: theme.color.fillInverse
                }
            }
        }
    },
    inverse: {
        mode: {
            focused: {
                arrowColor: theme.color.fillNeutral,
                progressBar: {
                    barColor: theme.color.fillNeutralTertiary,
                    progressColor: theme.color.fillNeutral
                }
            }
        }
    },
    brand: {
        mode: {
            focused: {
                arrowColor: theme.color.fillInverse,
                progressBar: {
                    barColor: theme.color.fillBrandTertiary,
                    progressColor: theme.color.fillBrand
                }
            }
        }
    }
});

var styles$c = Object.freeze({
    __proto__: null,
    base: base$c,
    mode: mode$4,
    tone: tone$7
});

var base$b = theme => {
    var size = theme.spacer.lg;
    return {
        arrowAlphaValue: theme.alpha.primary,
        arrowAlphaValueLimit: theme.alpha.secondary,
        arrowHeight: theme.spacer.xxl,
        arrowSpacing: theme.spacer.md,
        arrowWidth: theme.spacer.xxl,
        arrowColor: theme.color.fillNeutral,
        containerHeight: theme.spacer.lg + theme.spacer.xs,
        iconLeftSrc: theme.asset.arrowLeft,
        iconRightSrc: theme.asset.arrowRight,
        minWidth: getWidthByColumnSpan(theme, 2),
        progressBar: {},
        width: size,
        height: size,
        radius: size / 2,
        showArrows: true,
        showKnob: true,
        circleAnimation: {}
    };
};

var mode$3 = () => ({
    disabled: {
        arrowAlphaValue: 0
    }
});

var tone$6 = theme => ({
    neutral: {
        arrowColor: theme.color.fillNeutral,
        circleColor: theme.color.interactiveNeutralFocus
    },
    inverse: {
        arrowColor: theme.color.fillInverse,
        circleColor: theme.color.interactiveInverseFocus
    },
    brand: {
        arrowColor: theme.color.fillNeutral,
        circleColor: theme.color.interactiveNeutralFocus
    }
});

var styles$b = Object.freeze({
    __proto__: null,
    base: base$b,
    mode: mode$3,
    tone: tone$6
});

class Slider extends Base$1 {
    static get __componentName() {
        return "Slider";
    }
    static get __themeStyle() {
        return styles$b;
    }
    static _template() {
        return {
            Container: {
                mountY: .5,
                y: h => h / 2,
                Bar: {
                    mountY: .5,
                    SliderBar: {
                        type: ProgressBar,
                        progress: .5,
                        mountY: .5,
                        announce: ""
                    },
                    Circle: {
                        type: Knob,
                        zIndex: 5
                    }
                },
                LeftArrow: {
                    type: Icon,
                    mountY: .5,
                    y: h => h / 2
                },
                RightArrow: {
                    type: Icon,
                    mountY: .5,
                    y: h => h / 2
                }
            }
        };
    }
    static get properties() {
        return [ "max", "min", "step", "value", "vertical" ];
    }
    static get tags() {
        return [ "Container", {
            name: "Bar",
            path: "Container.Bar"
        }, {
            name: "SliderBar",
            path: "Container.Bar.SliderBar"
        }, {
            name: "Circle",
            path: "Container.Bar.Circle"
        }, {
            name: "LeftArrow",
            path: "Container.LeftArrow"
        }, {
            name: "RightArrow",
            path: "Container.RightArrow"
        } ];
    }
    _construct() {
        super._construct();
        this._min = 0;
        this._max = 100;
        this._step = 1;
        this._value = 0;
        this._vertical = false;
    }
    _update() {
        this._updateDirection();
        this._updateSliderLayout();
        this._updatePositions();
        this._updateArrowAlpha();
        this._updateArrows();
        if (this._valueChanged) {
            this.signal("onChange", this.value, this);
            this.fireAncestors("$announce", this.announce);
            this._valueChanged = false;
        }
        this._checkAndSignalSizeChange();
    }
    _handleLeft() {
        if (this._isDisabledMode) {
            return false;
        }
        this._decrementValue();
        if (typeof this.onLeft === "function") {
            return this.onLeft(this);
        }
        return true;
    }
    _handleRight() {
        if (this._isDisabledMode) {
            return false;
        }
        this._incrementValue();
        if (typeof this.onRight === "function") {
            return this.onRight(this);
        }
        return true;
    }
    _updateDirection() {
        this.patch({
            pivotX: 0,
            rotation: this.vertical ? degreesToRadians(90) : 0,
            mountY: this.vertical ? .5 : 0
        });
    }
    _updateSliderLayout() {
        var w = this.w || this.style.minWidth;
        this._Container.patch({
            h: this.style.containerHeight,
            w: w,
            Bar: {
                x: this._calculatedSliderX,
                SliderBar: {
                    y: this.style.containerHeight / 2,
                    w: this._calculatedSliderWidth,
                    style: _objectSpread({
                        duration: 0
                    }, this.style.progressBar)
                }
            }
        });
        this.h = Math.max(this.style.containerHeight, this.style.arrowHeight);
    }
    _checkAndSignalSizeChange() {
        if (this.h !== this.prevH || this._Container.w !== this.prevW || this.rotation !== this.prevRotation) {
            this.signal("onSizeChange", this);
        }
        this.prevH = this.h;
        this.prevW = this._Container.w;
        this.prevRotation = this.rotation;
    }
    _updatePositions() {
        this._updateSliderProgress();
        this._updateCirclePosition();
    }
    _updateSliderProgress() {
        var progress = this.value < this.min ? this.min / this.max : this.value / this.max;
        if (this.value > this.max || this.value - this.step > this.max) {
            progress = this._calculatedSliderWidth;
        } else if (this.min < 0 || this.max < 0) {
            progress = (this.value - this.min) / (this.max - this.min);
        }
        this._SliderBar.progress = progress;
    }
    _updateCirclePosition() {
        var xCirclePosition;
        if (this.value < this.min || this.value + this.step < this.min) {
            xCirclePosition = this.min / this.max * this._calculatedSliderWidth;
        } else if (this.value > this.max || this.value - this.step > this.max) {
            xCirclePosition = this._calculatedSliderWidth;
        } else {
            if (this.min < 0 || this.max < 0) {
                xCirclePosition = (this.value - this.min) / (this.max - this.min) * this._calculatedSliderWidth;
            } else {
                xCirclePosition = this.value / this.max * this._calculatedSliderWidth;
            }
        }
        if (this._Circle) {
            this._Circle.patch({
                mode: this.mode,
                style: {
                    radius: this.style.radius,
                    w: this.style.w,
                    h: this.style.h,
                    circleColor: this.style.circleColor
                },
                y: this._SliderBar.y + 1,
                alpha: this._isFocusedMode && this.style.showKnob ? 1 : 0
            });
            if (this.style.circleAnimation && Object.keys(this.style.circleAnimation).length) {
                this._Circle.smooth = {
                    x: [ xCirclePosition, this.style.circleAnimation ]
                };
            } else {
                this._Circle.x = xCirclePosition;
            }
        }
    }
    _updateArrowAlpha() {
        var leftAlpha;
        var rightAlpha;
        var offAlpha = .001;
        var alpha = this.style.showArrows ? this.style.arrowAlphaValue : offAlpha;
        var alphaLimit = this.style.showArrows ? this.style.arrowAlphaValueLimit : offAlpha;
        leftAlpha = rightAlpha = alpha;
        if (!this._isDisabledMode && this.value <= this.min) {
            leftAlpha = alphaLimit;
            rightAlpha = alpha;
        } else if (!this._isDisabledMode && this.value >= this.max) {
            leftAlpha = alpha;
            rightAlpha = alphaLimit;
        }
        this._LeftArrow.smooth = {
            alpha: leftAlpha
        };
        this._RightArrow.smooth = {
            alpha: rightAlpha
        };
    }
    _updateArrows() {
        var arrowProps = {
            w: this.style.arrowWidth,
            h: this.style.arrowHeight,
            style: {
                color: this.style.arrowColor
            }
        };
        this._LeftArrow.patch(_objectSpread(_objectSpread({}, arrowProps), {}, {
            icon: this.style.iconLeftSrc
        }));
        this._RightArrow.patch(_objectSpread(_objectSpread({}, arrowProps), {}, {
            icon: this.style.iconRightSrc
        }));
        this._RightArrow.smooth = {
            x: this.style.arrowSpacing + this._calculatedSliderWidth + this._Bar.x
        };
    }
    _decrementValue() {
        var value = this.value - this.step;
        this.value = value >= this.min ? value : this.min;
        this._updatePositions();
    }
    _incrementValue() {
        var value = this.value + this.step;
        this.value = value <= this.max ? value : this.max;
        this._updatePositions();
    }
    _handleUp() {
        return false;
    }
    _handleDown() {
        return false;
    }
    get _calculatedSliderX() {
        return this.style.showArrows ? this.style.arrowSpacing + this.style.arrowWidth : 0;
    }
    get _calculatedSliderWidth() {
        var totalArrowSize = this.style.showArrows ? this.style.arrowSpacing * 2 + this.style.arrowWidth * 2 : 0;
        return this.w < totalArrowSize + this._circleW ? this.style.minWidth - totalArrowSize : this.w - totalArrowSize;
    }
    get _circleW() {
        return this._Circle ? this._Circle.w : 0;
    }
    _setVertical(vertical) {
        this._setState(vertical ? "VerticalSlider" : "");
        return vertical;
    }
    _setValue(value) {
        this._valueChanged = value !== this._value;
        return value;
    }
    _setMin(min) {
        var value = this.value;
        this.value = min > value ? min : value;
        this._valueChanged = value !== this.value;
        return min;
    }
    _setMax(max) {
        var value = this.value;
        this.value = max < value ? max : value;
        this._valueChanged = value !== this.value;
        return max;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        if (this._announce !== undefined && this._announce !== null) {
            return this._announce;
        }
        return this.value.toString();
    }
    static _states() {
        return [ class VerticalSlider extends(this){
            _handleLeft() {
                return false;
            }
            _handleRight() {
                return false;
            }
            _handleUp() {
                if (this._isDisabledMode) {
                    return false;
                }
                this._decrementValue();
                if (typeof this.onUp === "function") {
                    return this.onUp(this);
                }
                return true;
            }
            _handleDown() {
                if (this._isDisabledMode) {
                    return false;
                }
                this._incrementValue();
                if (typeof this.onDown === "function") {
                    return this.onDown(this);
                }
                return true;
            }
        } ];
    }
}

class NestedSlider extends Slider {
    static get __componentName() {
        return "NestedSlider";
    }
    static get __themeStyle() {
        return styles$c;
    }
}

var base$a = theme => ({
    paddingY: theme.spacer.md + theme.spacer.xs,
    valueTextStyle: _objectSpread(_objectSpread({}, theme.typography.headline3), {}, {
        maxLines: 1,
        textColor: theme.color.textNeutralSecondary
    })
});

var mode$2 = theme => ({
    disabled: {
        valueTextStyle: {
            textColor: theme.color.textNeutralDisabled
        }
    },
    focused: {
        valueTextStyle: {
            textColor: theme.color.textInverseSecondary
        }
    }
});

var tone$5 = theme => ({
    neutral: {
        mode: {
            focused: {
                valueTextStyle: {
                    textColor: theme.color.textInverseSecondary
                }
            }
        }
    },
    inverse: {
        mode: {
            focused: {
                valueTextStyle: {
                    textColor: theme.color.textNeutralSecondary
                }
            }
        }
    },
    brand: {
        mode: {
            focused: {
                valueTextStyle: {
                    textColor: theme.color.textInverseSecondary
                }
            }
        }
    }
});

var styles$a = Object.freeze({
    __proto__: null,
    base: base$a,
    mode: mode$2,
    tone: tone$5
});

class ListItemSlider extends ListItem {
    static get __componentName() {
        return "ListItemSlider";
    }
    static get __themeStyle() {
        return styles$a;
    }
    static _template() {
        var template = super._template;
        return _objectSpread(_objectSpread({}, template()), {}, {
            Content: _objectSpread(_objectSpread({}, template().Content), {}, {
                flex: {
                    direction: "column"
                },
                TextWrapper: _objectSpread(_objectSpread({}, template().Content.TextWrapper), {}, {
                    mountY: 0,
                    flex: undefined
                }),
                Slider: {
                    type: NestedSlider,
                    mountX: .5,
                    signals: {
                        onChange: "_onSliderChanged"
                    }
                }
            })
        });
    }
    static get properties() {
        return [ ...super.properties, "slider", "value", "max", "min" ];
    }
    static get aliasStyles() {
        return [ {
            prev: "titlePadding",
            curr: "contentSpacing"
        } ];
    }
    static get tags() {
        return [ ...super.tags, {
            name: "Slider",
            path: "Content.Slider"
        }, {
            name: "Value",
            path: "Content.TextWrapper.Value"
        } ];
    }
    _construct() {
        super._construct();
        this.value = 50;
        this.max = 100;
        this.min = 0;
    }
    _update() {
        super._update();
        this._updateSliderPosition();
        this._updateValue();
    }
    _onTextBoxChanged() {
        super._onTextBoxChanged();
        this._TextWrapper.h = Math.max(this._Title ? this._Title.h : 0, this._Value ? this._Value.h : 0);
    }
    _updateValue() {
        if (this._hasValue) {
            var valuePatch = {
                content: this.value.toString(),
                style: {
                    textStyle: _objectSpread({}, this.style.valueTextStyle)
                },
                mountX: 1,
                x: this.w - this._paddingX
            };
            if (!this._Value) {
                valuePatch = _objectSpread({
                    type: TextBox,
                    signals: {
                        textBoxChanged: "_onTextBoxChanged"
                    }
                }, valuePatch);
            }
            this._TextWrapper.patch({
                Value: valuePatch
            });
        } else {
            this._TextWrapper.patch({
                Value: undefined
            });
        }
    }
    _updateSliderPosition() {
        var w = this.w - this._paddingLeft - this._paddingRight;
        var sliderProps = _objectSpread(_objectSpread({
            mode: this.mode,
            tone: this.tone,
            w: w,
            x: w / 2,
            visible: !this._collapse,
            alpha: this.style.alpha
        }, this.slider), {}, {
            value: this.value,
            max: this.max,
            min: this.min
        });
        this._Slider.patch(sliderProps);
    }
    get _hasValue() {
        return this.value != undefined || this.value != null;
    }
    get _fixedWordWrapWidth() {
        var titleWrapWidth = this.w - this._paddingLeft - this._paddingRight - this._paddingX;
        return titleWrapWidth;
    }
    _onSliderChanged(value) {
        this.value = value;
        this._updateValue();
        this.signal("onSliderChange", value, this);
    }
    _handleLeft() {
        if (typeof this.onLeft === "function") {
            return this.onLeft(this);
        } else if (this._Slider && !this._isDisabledMode) {
            return this._Slider._handleLeft();
        }
        return false;
    }
    _handleRight() {
        if (typeof this.onRight === "function") {
            return this.onRight(this);
        } else if (this._Slider && !this._isDisabledMode) {
            return this._Slider._handleRight();
        }
        return false;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        if (this._announce) {
            return this._announce;
        }
        return this.title + this.value + ", List Item Slider";
    }
}

var base$9 = theme => ({
    arrowAlphaValue: theme.alpha.primary,
    arrowAlphaValueLimit: theme.alpha.secondary,
    arrowWidth: theme.spacer.xxl,
    arrowHeight: theme.spacer.xxl,
    iconLeftSrc: theme.asset.arrowLeft,
    iconRightSrc: theme.asset.arrowRight
});

var tone$4 = theme => ({
    neutral: {
        mode: {
            focused: {
                arrowColor: theme.color.fillInverse
            }
        }
    },
    inverse: {
        mode: {
            focused: {
                arrowColor: theme.color.fillNeutral
            }
        }
    },
    brand: {
        mode: {
            focused: {
                arrowColor: theme.color.fillInverse
            }
        }
    }
});

var styles$9 = Object.freeze({
    __proto__: null,
    base: base$9,
    tone: tone$4
});

class ListItemPicker extends ListItem {
    static get __componentName() {
        return "ListItemPicker";
    }
    static get __themeStyle() {
        return styles$9;
    }
    static get properties() {
        return [ ...super.properties, "options", "selectedIndex" ];
    }
    static get tags() {
        return [ ...super.tags, "LeftArrow", "RightArrow", {
            name: "Picker",
            path: "Content.TextWrapper.Picker"
        } ];
    }
    static get aliasStyles() {
        return [ {
            prev: "titlePadding",
            curr: "contentSpacing"
        } ];
    }
    _onTextBoxChanged() {
        super._onTextBoxChanged();
        this._alignPicker();
    }
    _construct() {
        super._construct();
        this._options = [];
        this._selectedIndex = 0;
    }
    _update() {
        super._update();
        this._updatePicker();
        this._updateArrows();
        this._updateArrowsAlpha();
        this._updateAlignment();
    }
    _updateAlignment() {
        if (this._isFocusedMode) {
            this.patch({
                justify: "center"
            });
        } else {
            this.patch({
                justify: "left"
            });
        }
    }
    _updateArrows() {
        if (!this._isFocusedMode) {
            var offAlpha = .001;
            if (this._LeftArrow) {
                this._LeftArrow.alpha = offAlpha;
            }
            if (this._RightArrow) {
                this._RightArrow.alpha = offAlpha;
            }
            return;
        }
        var arrowProps = {
            w: this.style.arrowWidth,
            h: this.style.arrowHeight,
            style: {
                color: this.style.arrowColor
            },
            alpha: this.style.arrowAlphaValue
        };
        if (!this._LeftArrow) {
            this.patch({
                LeftArrow: {
                    type: Icon,
                    mountY: .5,
                    y: h => h / 2
                }
            });
        }
        this._LeftArrow.patch(_objectSpread(_objectSpread({}, arrowProps), {}, {
            icon: this.style.iconLeftSrc
        }));
        this._LeftArrow.smooth = {
            x: this.style.paddingX
        };
        if (!this._RightArrow) {
            this.patch({
                RightArrow: {
                    type: Icon,
                    mountY: .5,
                    mountX: 1,
                    y: h => h / 2
                }
            });
        }
        this._RightArrow.patch(_objectSpread(_objectSpread({}, arrowProps), {}, {
            icon: this.style.iconRightSrc
        }));
        this._RightArrow.smooth = {
            x: this.w - this.style.paddingX
        };
    }
    _updatePicker() {
        var w = this.w - this._paddingX - this.style.arrowWidth * 2;
        if (!this._Picker) {
            this._TextWrapper.patch({
                Picker: {
                    type: Row,
                    clipping: true,
                    alwaysScroll: true,
                    signals: {
                        selectedChange: "_updateArrowsAlpha"
                    }
                }
            });
        }
        this._Picker.patch({
            visible: !this._collapse,
            h: this.style.descriptionTextStyle.lineHeight,
            w: w,
            items: this.options.map((option => ({
                type: Marquee,
                h: this.style.descriptionTextStyle.lineHeight,
                w: w,
                centerAlign: this._isFocusedMode,
                title: _objectSpread(_objectSpread({}, this.style.descriptionTextStyle), {}, {
                    text: option
                })
            }))),
            selectedIndex: this.selectedIndex
        });
        this._alignPicker();
    }
    _alignPicker() {
        this._Picker.patch({
            mountX: this._isFocusedMode ? .5 : 0,
            x: this._isFocusedMode ? this._Title.w / 2 : 0
        });
    }
    _updateArrowsAlpha() {
        if (this._Picker) {
            this._selectedIndex = this._Picker.selectedIndex;
        }
        var alpha = this._isFocusedMode ? this.style.arrowAlphaValue : 0;
        if (this._RightArrow) {
            this._RightArrow.alpha = this.selectedIndex === this.options.length - 1 && this._isFocusedMode ? this.style.arrowAlphaValueLimit : alpha;
        }
        if (this._LeftArrow) {
            this._LeftArrow.alpha = this.selectedIndex === 0 && this._isFocusedMode ? this.style.arrowAlphaValueLimit : alpha;
        }
        this.fireAncestors("$announce", this.announce);
    }
    get _fixedWordWrapWidth() {
        var wordWrapWidthFocused = this.w - this._paddingX - this.style.arrowWidth * 2 - 2 * this.style.contentSpacing;
        var wordWrapWidth = this.w - this._paddingLeft - this._paddingRight;
        return this._isFocusedMode ? wordWrapWidthFocused : wordWrapWidth;
    }
    get _collapse() {
        return this.shouldCollapse && !this._isFocusedMode;
    }
    get selectedOption() {
        return this._Picker.selected;
    }
    _handleLeft() {
        if (typeof this.onLeft === "function") {
            return this.onLeft(this);
        }
        this._Picker.selectPrevious();
        return true;
    }
    _handleRight() {
        if (typeof this.onRight === "function") {
            return this.onRight(this);
        }
        this._Picker.selectNext();
        return true;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        if (this._announce) {
            return this._announce;
        }
        return this.title + this.options[this.selectedIndex] + ", List Item";
    }
}

class MetadataCard extends MetadataBase$1 {
    static get __componentName() {
        return "MetadataCard";
    }
}

var base$8 = theme => ({
    textStyle: theme.typography.body2,
    fadeHeight: 100,
    scroll: {
        timingFunction: "linear",
        duration: theme.animation.duration.xfast
    },
    contentMarginTop: theme.spacer.md,
    contentMarginLeft: theme.spacer.xl,
    sliderMarginLeft: theme.spacer.lg + theme.spacer.xxs
});

var styles$8 = Object.freeze({
    __proto__: null,
    base: base$8
});

var base$7 = theme => {
    var {scroll: scroll} = base$8(theme);
    return {
        progressBar: {
            animation: scroll
        },
        circleAnimation: scroll
    };
};

var styles$7 = Object.freeze({
    __proto__: null,
    base: base$7
});

class ScrollSlider extends Slider {
    static get __componentName() {
        return "ScrollSlider";
    }
    static get __themeStyle() {
        return styles$7;
    }
}

class ScrollWrapper extends Base$1 {
    static get __themeStyle() {
        return styles$8;
    }
    static _template() {
        return {
            clipping: true,
            FadeContainer: {
                ScrollContainer: {
                    w: _w => _w,
                    wordWrap: true
                }
            },
            Slider: {
                type: ScrollSlider,
                vertical: true,
                signals: {
                    onSizeChange: "_updateScrollContainerSize"
                },
                announce: " "
            }
        };
    }
    static get __componentName() {
        return "ScrollWrapper";
    }
    static get properties() {
        return [ "autoScroll", "autoScrollDelay", "autoScrollSpeed", "content", "fadeContent", "scrollDuration", "scrollStep", "showScrollBar", "shouldWrap", "flexDirection" ];
    }
    static get tags() {
        return [ "FadeContainer", "Slider", {
            name: "ScrollContainer",
            path: "FadeContainer.ScrollContainer"
        }, {
            name: "ScrollableText",
            path: "ScrollContainer.ScrollableText"
        } ];
    }
    _construct() {
        super._construct();
        this._scrollStep = 10;
        this._shouldWrap = false;
        this._flexDirection = "column";
        this._fadeContent = true;
        this._sliderWidth = 0;
    }
    _afterTextBoxUpdate(textBox) {
        if (this._prevW !== textBox.finalW || this._prevH !== textBox.finalH) {
            this._prevW = textBox.finalW;
            this._prevH = textBox.finalH;
            this._updateScrollWrapperLayout();
            this._updateAlpha();
        }
    }
    _resetFlexContainer() {
        this._FadeContainer.patch({
            ScrollContainer: undefined
        });
        this._FadeContainer.patch({
            ScrollContainer: {
                w: _w2 => _w2,
                wordWrap: true
            }
        });
    }
    _update() {
        if (this._contentChanged) {
            this._resetFlexContainer();
            this._updateAutoScroll();
        }
        this._updateScrollContainer();
        this._updateScrollWrapperLayout();
        this._updateAlpha();
    }
    _updateAutoScroll() {
        this.resetScroll();
        this._setupAutoScroll();
        this._contentChanged = false;
    }
    _updateScrollWrapperLayout() {
        this._ScrollContainer.patch({
            w: this._contentWidth
        });
        this._updateFadeContainer();
        this._updateSlider();
    }
    _updateAlpha() {
        this._Slider.smooth = {
            alpha: this.showScrollBar && this._isFocusedMode ? 1 : 0
        };
    }
    _updateFadeContainer() {
        var isScrollable = this._ScrollContainer.finalH > this.h;
        var shouldFade = this.fadeContent && isScrollable && !this._isEndContentVisible;
        this._FadeContainer.patch({
            h: this.h,
            w: this._contentWidth,
            y: this.style.contentMarginTop,
            x: this.style.contentMarginLeft,
            rtt: true,
            shader: shouldFade ? {
                type: lng.shaders.FadeOut,
                bottom: this.style.fadeHeight
            } : undefined
        });
    }
    _scrollContainerLoaded(_ref23) {
        var {h: h} = _ref23;
        this._ScrollContainer.h = h;
        this._updateScrollWrapperLayout();
    }
    _updateScrollContainer() {
        if (!this.content) return;
        if (typeof this.content === "string") {
            this._ScrollContainer.patch({
                flex: {
                    direction: "column"
                },
                ScrollableText: {
                    h: 0,
                    w: this._contentWidth,
                    type: TextBox,
                    content: this.content,
                    style: {
                        textStyle: _objectSpread(_objectSpread({}, this.style.textStyle), {}, {
                            wordWrap: true,
                            wordWrapWidth: this._contentWidth
                        })
                    },
                    signals: {
                        textBoxChanged: "_scrollContainerLoaded"
                    },
                    onAfterUpdate: this._afterTextBoxUpdate.bind(this)
                }
            });
        } else if (Array.isArray(this.content)) {
            var content = {};
            this.content.forEach(((item, index) => {
                var id = "ScrollText".concat(index);
                content[id] = _objectSpread({
                    w: this._contentWidth
                }, item);
                if (item.text) {
                    content[id] = {
                        type: TextBox,
                        content: item.text,
                        style: {
                            textStyle: _objectSpread(_objectSpread(_objectSpread({}, this.style.textStyle), item.style), {}, {
                                wordWrap: true,
                                wordWrapWidth: this._contentWidth
                            })
                        },
                        onAfterUpdate: this._afterTextBoxUpdate.bind(this)
                    };
                }
            }));
            this._ScrollContainer.patch(_objectSpread({
                flex: {
                    direction: this.flexDirection,
                    wrap: this.shouldWrap
                }
            }, content));
        }
    }
    _scrollDown() {
        var hasContentToScrollTo = this._scrollContainerY + this._ScrollContainer.finalH > this.renderHeight;
        if (hasContentToScrollTo) {
            var targetY = this._scrollContainerY - this.scrollStep;
            var canScrollByStepLength = targetY + this._ScrollContainer.finalH > this.renderHeight;
            var scrollEndY = this.renderHeight - this._ScrollContainer.finalH - this.style.contentMarginTop;
            this._ScrollContainer.patch({
                smooth: {
                    y: [ canScrollByStepLength ? targetY : scrollEndY, this._scrollAnimation ]
                }
            });
            var hasScrolledToEnd = this._scrollContainerY + this._ScrollContainer.finalH <= this.h;
            if (hasScrolledToEnd) {
                this._isEndContentVisible = true;
                this._autoScrollComplete = true;
                this.fireAncestors("$scrollChanged", "endDown", this);
                this._updateFadeContainer();
            }
        } else {
            return false;
        }
    }
    _scrollUp() {
        var canScrollUp = this._scrollContainerY < 0;
        if (canScrollUp) {
            var targetY = this._scrollContainerY + this.scrollStep;
            var canScrollByStepLength = targetY < 0;
            this._ScrollContainer.patch({
                smooth: {
                    y: [ canScrollByStepLength ? targetY : 0, this._scrollAnimation ]
                }
            });
            var isScrollable = this._scrollContainerY + this._ScrollContainer.finalH > this.renderHeight;
            if (isScrollable) {
                this._autoScrollComplete = false;
            }
            if (this._scrollContainerY >= 0) {
                this.fireAncestors("$scrollChanged", "endUp", this);
            }
            if (this._isEndContentVisible) {
                this._isEndContentVisible = false;
                this._updateFadeContainer();
            }
        } else {
            return false;
        }
    }
    resetScroll() {
        this._ScrollContainer.y = 0;
        this._Slider.value = 0;
        this._ScrollContainer.transition("y").finish();
        delete this._ScrollContainer._transitions;
        this._autoScrollComplete = false;
    }
    _setAutoScroll(val) {
        if (this._autoScroll !== val) {
            this._autoScroll = val;
        }
        this._setupAutoScroll();
        return val;
    }
    _setupAutoScroll() {
        clearTimeout(this._startAutoScroll);
        clearTimeout(this._performAutoScrollTimer);
        if (this.autoScroll) {
            this._startAutoScroll = setTimeout((() => this._performAutoScroll()), isNaN(this.autoScrollDelay) ? 2e3 : this.autoScrollDelay);
        }
    }
    _performAutoScroll() {
        if (this.autoScroll && !this._autoScrollComplete) {
            this._Slider._handleDown();
            this._performAutoScrollTimer = setTimeout((() => this._performAutoScroll()), isNaN(this.autoScrollSpeed) ? 200 : this.autoScrollSpeed);
        }
    }
    _setContent(content) {
        if (content !== this._content && this.enabled) {
            this._contentChanged = true;
        }
        return content;
    }
    _updateScrollContainerSize(slider) {
        if (this._sliderWidth !== slider._Container.h) {
            this._sliderWidth = slider._Container.h;
            this._updateScrollContainer();
        }
    }
    _updateSlider() {
        var scrollHeight = Math.max(this._ScrollContainer.finalH - this.renderHeight, 0);
        var contentScrollSteps = scrollHeight > 0 ? Math.ceil(scrollHeight / this.scrollStep) : 1;
        var sliderMax = this.renderHeight;
        var sliderStep = contentScrollSteps > 0 ? sliderMax / contentScrollSteps : sliderMax;
        if (this._Slider) {
            this._Slider.patch({
                x: this.w - this._sliderWidth,
                w: sliderMax,
                min: 0,
                max: sliderMax,
                step: sliderStep,
                onUp: this._scrollUp.bind(this),
                onDown: this._scrollDown.bind(this)
            });
        }
    }
    get _contentWidth() {
        return this.w - this.style.contentMarginLeft - this.style.sliderMarginLeft - this._sliderWidth;
    }
    get _scrollContainerY() {
        return this._ScrollContainer.transition("y").targetValue;
    }
    get _scrollAnimation() {
        var duration = isNaN(this.scrollDuration) ? this.style.scroll.duration : this.scrollDuration;
        return _objectSpread(_objectSpread({}, this.style.scroll), {}, {
            duration: duration
        });
    }
    _getFocused() {
        return this._Slider;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        if (this._announce) {
            return this._announce;
        }
        if (Array.isArray(this.content)) {
            if (this._ScrollContainer && this._ScrollContainer.children && this._ScrollContainer.children.length) {
                return this._ScrollContainer.children.map((item => item.announce));
            } else {
                return this.content.map((item => item.announce || item.text));
            }
        }
        return this.content;
    }
}

var base$6 = theme => ({
    alpha: theme.alpha.none,
    animation: theme.animation.standardEntrance,
    blur: theme.spacer.xxl,
    color: theme.color.shadowNeutralFocus,
    offsetX: 0,
    offsetY: theme.spacer.lg,
    radius: theme.radius.md,
    spread: theme.spacer.md * -1,
    maxOffsetY: theme.spacer.xxl,
    maxOffsetX: 0
});

var mode$1 = theme => ({
    focused: {
        alpha: theme.alpha.secondary,
        offsetY: theme.spacer.xxl
    }
});

var tone$3 = theme => ({
    neutral: {
        color: theme.color.shadowNeutralFocus
    },
    inverse: {
        color: theme.color.shadowInverseFocus
    },
    brand: {
        color: theme.color.shadowBrandFocus
    }
});

var styles$6 = Object.freeze({
    __proto__: null,
    base: base$6,
    mode: mode$1,
    tone: tone$3
});

class Shadow extends Base$1 {
    static get __componentName() {
        return "Shadow";
    }
    static get __themeStyle() {
        return styles$6;
    }
    static get properties() {
        return [ "maskShadow" ];
    }
    static get tags() {
        return [ "Frame", {
            name: "Shadow",
            path: "Frame.Shadow"
        } ];
    }
    _updateFocusStyle() {
        if (!this._Shadow) return;
        this.applySmooth(this._Shadow, {
            alpha: this.style.alpha,
            y: this.style.offsetY,
            x: this.style.offsetX
        }, {
            alpha: [ this.style.alpha, this.style.animation ],
            y: [ this.style.offsetY, this.style.animation ],
            x: [ this.style.offsetX, this.style.animation ]
        });
    }
    _update() {
        var shadowSize = this.style.spread + this.style.blur * 2;
        var holepunchError = 4;
        var extraBoundsY = this.style.maxOffsetY;
        var extraBoundsX = this.style.maxOffsetX;
        var radius = getMaxRoundRadius(this.style.radius, this.w, this.h);
        this.patch({
            Frame: {
                w: this.w + shadowSize * 2 + extraBoundsX,
                h: this.h + shadowSize * 2 + extraBoundsY,
                x: (this.w + extraBoundsX) / 2,
                y: (this.h + extraBoundsY) / 2,
                mount: .5,
                rtt: this.maskShadow,
                shader: this.maskShadow ? {
                    type: lng.shaders.Hole,
                    w: this.w - holepunchError,
                    h: this.h - holepunchError,
                    x: shadowSize + holepunchError / 2,
                    y: shadowSize + holepunchError / 2,
                    radius: radius
                } : undefined,
                Shadow: {
                    color: this.style.color,
                    texture: lng.Tools.getShadowRect(this.w + this.style.spread * 2, this.h + this.style.spread * 2, radius, this.style.blur)
                }
            }
        });
        if (this.shouldSmooth === undefined) {
            this.shouldSmooth = true;
        }
        this._updateFocusStyle();
    }
}

var base$5 = theme => {
    var size = theme.spacer.xxl;
    return {
        width: size,
        height: size,
        radius: size / 2
    };
};

var styles$5 = Object.freeze({
    __proto__: null,
    base: base$5
});

class SliderLarge extends Slider {
    static get __componentName() {
        return "SliderLarge";
    }
    static get __themeStyle() {
        return styles$5;
    }
}

class ContentSwitcher extends Base$1 {
    static get __componentName() {
        return "ContentSwitcher";
    }
    static get properties() {
        return [ "selectedIndex" ];
    }
    _construct() {
        super._construct();
        this._selectedIndex = 0;
        this._contentItems = [];
    }
    _update() {
        super._update();
        this._updateSelected();
    }
    _updateSelected() {
        if (this._preveSelectedIndex !== this.selectedIndex) {
            if (this._preveSelectedIndex !== undefined) {
                var prevContent = this.tag("Content".concat(this._preveSelectedIndex));
                prevContent.smooth = {
                    alpha: 0
                };
                if (this._hasContent) {
                    prevContent._getTransition("alpha").once("finish", (() => {
                        this._fadeInContent();
                    }));
                } else if (this.selectedIndex !== undefined) {
                    this._fadeInContent();
                }
            } else if (this._hasContent) {
                this._fadeInContent();
            }
            this._preveSelectedIndex = this.selectedIndex;
        }
    }
    _fadeInContent() {
        this._selectedContent.smooth = {
            alpha: 1
        };
        this._selectedContent._getTransition("alpha").once("finish", (() => {
            this.h = this._selectedContent.h;
            this.signal("contentHeightChange", this.h);
        }));
    }
    _updateContent() {
        var allContent = this.contentItems.reduce(((acc, item, idx) => {
            var component;
            var tagName = "Content".concat(idx);
            if (typeof item === "function") {
                var componentLoader = item();
                if (componentLoader.then) {
                    this._loadAsyncComponent(componentLoader, idx);
                } else {
                    component = componentLoader;
                }
            } else {
                component = item;
            }
            if (component) {
                acc[tagName] = _objectSpread(_objectSpread({}, component), {}, {
                    alpha: 0
                });
            }
            return acc;
        }), {});
        this.patch(allContent);
    }
    _loadAsyncComponent(componentLoader, idx) {
        componentLoader.then((component => {
            var tagName = "Content".concat(idx);
            this.patch({
                [tagName]: _objectSpread(_objectSpread({}, component), {}, {
                    alpha: 0
                })
            });
        }));
    }
    set contentItems(contentItems) {
        if (!stringifyCompare(contentItems, this._contentItems)) {
            this._contentItems = contentItems;
            this._updateContent();
        }
    }
    get contentItems() {
        return this._contentItems;
    }
    get _hasContent() {
        return this._selectedContent && this._selectedContent.children.length > 0;
    }
    get _selectedContent() {
        return this.tag("Content".concat(this.selectedIndex));
    }
    _getFocused() {
        if (this._hasContent) {
            return this._selectedContent;
        }
    }
}

var base$4 = theme => ({
    tabSpacing: theme.spacer.lg,
    tabsMarginBottom: theme.spacer.xxl
});

var styles$4 = Object.freeze({
    __proto__: null,
    base: base$4
});

class TabBar extends Base$1 {
    static _template() {
        return {
            Tabs: {
                type: Row,
                autoResizeHeight: true,
                signals: {
                    selectedChange: "_selectedTabChange"
                }
            },
            TabContent: {
                type: ContentSwitcher,
                signals: {
                    contentHeightChange: "_updateTabBarHeight"
                }
            }
        };
    }
    static get __themeStyle() {
        return styles$4;
    }
    static get __componentName() {
        return "TabBar";
    }
    static get properties() {
        return [ "alphaSelectedTab", "collapse", "reset", "tabs", "retainSelection", ...Row.properties ];
    }
    static get tags() {
        return [ "Tabs", "TabContent" ];
    }
    _construct() {
        super._construct();
        this._tabContent = [];
        this._isTabsFocused = true;
    }
    _selectedTabChange(selected, prevSelected) {
        this.fireAncestors("$tabChanged", selected, prevSelected, this);
        if (typeof this._tabContent === "object" && typeof this._tabContent.then === "function") {
            return this._tabContent.then(this.queueRequestUpdate);
        }
        return this.queueRequestUpdate();
    }
    _update() {
        this._updateTabsLayout();
        this._updateTabs();
        this._updateTabContent();
        this._updateTabBarHeight();
    }
    _updateTabsLayout() {
        var defaultLayout = {
            style: {
                itemSpacing: this.style.tabSpacing
            }
        };
        var tabsRowPatch = Row.properties.reduce(((patchObj, prop) => {
            if (this[prop] != undefined) {
                patchObj[prop] = this[prop];
            }
            return patchObj;
        }), defaultLayout);
        this._Tabs.patch(tabsRowPatch);
    }
    _updateTabs() {
        this._Tabs.wrapSelected = this.wrapSelected;
        this._Tabs.items.forEach((tab => {
            var isSelectedTab = tab === this._Tabs.selected;
            if (this._isUnfocusedMode) {
                tab.mode = isSelectedTab && this.retainSelection ? "selected" : "unfocused";
            } else if (this._isFocusedMode) {
                if (this._isTabsFocused) {
                    tab.mode = isSelectedTab ? "focused" : "unfocused";
                } else {
                    tab.mode = isSelectedTab ? "selected" : "unfocused";
                }
            }
        }));
        if (this.alphaSelectedTab) {
            this._updateTabAlphas();
        }
    }
    _updateTabAlphas() {
        if (this._isTabsFocused) {
            this._Tabs.items.forEach((tab => {
                tab.patch({
                    alpha: 1
                });
            }));
        } else {
            this._Tabs.items.forEach((tab => {
                tab.patch({
                    alpha: tab === this._Tabs.selected ? 1 : .3
                });
            }));
        }
    }
    _updateTabContent() {
        var margin = this.style.tabsMarginBottom;
        this._TabContent.patch({
            y: this._Tabs.h + margin,
            contentItems: this._tabContent,
            selectedIndex: this._isFocusedMode ? this._Tabs.selectedIndex : undefined
        });
    }
    $itemChanged() {
        this._updateTabBarHeight();
        this._updateTabContent();
    }
    _updateTabBarHeight() {
        var h;
        if (this.collapse) {
            h = this._isFocusedMode && this._tabContent.filter((content => Object.keys(content).length)).length ? this._expandedHeight : this._collapsedHeight;
        } else {
            h = this._expandedHeight;
        }
        this._TabContent.smooth = {
            alpha: !this.collapse || this._isFocusedMode ? 1 : .001
        };
        if (this.h !== h) {
            this.h = h;
            this.fireAncestors("$itemChanged");
        }
    }
    selectTabs() {
        if (!this._isTabsFocused) {
            this._isTabsFocused = true;
            this._updateTabs();
            this._updateTabBarHeight();
        }
    }
    resetTabs() {
        this._Tabs.selectedIndex = 0;
    }
    _handleDown() {
        if (this._isTabsFocused && this._TabContent._hasContent) {
            this._isTabsFocused = false;
            this._updateTabs();
            this._updateTabBarHeight();
        }
        return false;
    }
    _handleUp() {
        this.selectTabs();
        return false;
    }
    _setTabs(tabs) {
        this._tabContent = [];
        this._tabContent = tabs.map((tab => tab.tabContent || {}));
        this._Tabs.items = tabs;
        return tabs;
    }
    _getTabs() {
        return this._Tabs.items;
    }
    get selected() {
        return this._Tabs.selected;
    }
    get selectedIndex() {
        return this._Tabs.selectedIndex;
    }
    set selectedIndex(index) {
        this._Tabs.selectedIndex = index;
    }
    get _collapsedHeight() {
        return this._Tabs.h;
    }
    get _expandedHeight() {
        return this._Tabs.h + this.style.tabsMarginBottom + this._TabContent.h;
    }
    _getFocused() {
        return this._isTabsFocused ? this._Tabs : this._TabContent;
    }
    _unfocus() {
        super._unfocus();
        if (this.reset) {
            this.resetTabs();
        }
    }
}

var base$3 = theme => ({
    radius: theme.radius.xl,
    paddingX: theme.spacer.xxxl + theme.spacer.xxs,
    paddingY: theme.spacer.md + theme.spacer.xs,
    paddingXNoTitle: theme.spacer.xl,
    iconSize: theme.spacer.xxxl,
    iconMarginRight: theme.spacer.md,
    textStyle: _objectSpread(_objectSpread({}, theme.typography.headline3), {}, {
        textColor: theme.color.textNeutral
    }),
    backgroundColor: theme.color.fillTransparent,
    contentColor: theme.color.fillNeutral
});

var mode = theme => ({
    focused: {
        backgroundColor: theme.color.interactiveNeutralFocus,
        contentColor: theme.color.fillInverse,
        textStyle: {
            textColor: theme.color.textInverse
        }
    },
    selected: {
        backgroundColor: theme.color.interactiveNeutralFocusSoft,
        contentColor: theme.color.fillNeutral,
        textStyle: {
            textColor: theme.color.textNeutral
        }
    },
    disabled: {
        backgroundColor: theme.color.fillTransparent,
        contentColor: theme.color.fillNeutralDisabled,
        textStyle: {
            textColor: theme.color.textNeutralDisabled
        }
    }
});

var tone$2 = theme => ({
    neutral: {},
    inverse: {
        mode: {
            focused: {
                contentColor: theme.color.fillNeutral,
                textStyle: {
                    textColor: theme.color.textNeutral
                }
            }
        }
    },
    brand: {
        mode: {
            focused: {
                contentColor: theme.color.fillNeutral,
                textStyle: {
                    textColor: theme.color.textNeutral
                }
            }
        }
    }
});

var styles$3 = Object.freeze({
    __proto__: null,
    base: base$3,
    mode: mode,
    tone: tone$2
});

class Tab extends Surface {
    static _template() {
        return _objectSpread(_objectSpread({}, super._template()), {}, {
            Content: {
                mount: .5,
                x: w => w / 2,
                y: h => h / 2,
                Text: {
                    type: TextBox,
                    mountY: .5,
                    signals: {
                        textBoxChanged: "_onTextBoxChanged"
                    }
                }
            }
        });
    }
    static get __themeStyle() {
        return styles$3;
    }
    static get __componentName() {
        return "Tab";
    }
    static get properties() {
        return [ "icon", "title" ];
    }
    static get tags() {
        return [ ...super.tags, "Content", {
            name: "Icon",
            path: "Content.Icon"
        }, {
            name: "Text",
            path: "Content.Text"
        } ];
    }
    static get aliasStyles() {
        return [ {
            prev: "noTitlePaddingX",
            curr: "paddingXNoTitle"
        } ];
    }
    _onTextBoxChanged() {
        this._updateContent();
        this._updateTabSize();
    }
    _update() {
        super._update();
        this._updateIcon();
        this._updateText();
        this._updateContent();
        this._updateTabSize();
    }
    _updateIcon() {
        if (!this.icon) {
            this._Content.patch({
                Icon: undefined
            });
            return;
        }
        var iconPatch = {
            icon: this.icon,
            w: this.style.iconSize,
            h: this.style.iconSize,
            y: this._Content.h / 2,
            style: {
                color: this.style.contentColor
            }
        };
        if (this.title) {
            iconPatch.x = 0;
            iconPatch.mountX = 0;
        } else {
            iconPatch.x = this._Content.w / 2;
            iconPatch.mountX = .5;
        }
        if (this._Icon) {
            this._Icon.patch(iconPatch);
        } else {
            this._Content.patch({
                Icon: _objectSpread({
                    type: Icon,
                    mountY: .5
                }, iconPatch)
            });
        }
    }
    _updateText() {
        var textPatch = {
            content: this.title,
            style: {
                textStyle: this.style.textStyle
            },
            y: this._Content.h / 2
        };
        if (this.icon) {
            textPatch.x = this._iconW + this.style.iconMarginRight;
            textPatch.mountX = 0;
        } else {
            textPatch.x = this._Content.w / 2;
            textPatch.mountX = .5;
        }
        this._Text.patch(textPatch);
    }
    _updateContent() {
        this._Content.patch({
            w: this._iconW + (this.title ? this.style.iconMarginRight : 0) + this._textW,
            h: Math.max(this._iconH, this._Text.h)
        });
    }
    _updateTabSize() {
        if (this.title || this.icon) {
            this.patch({
                w: this._paddingX * 2 + this._Content.w,
                h: this.style.paddingY * 2 + this._Content.h
            });
        } else {
            this.patch({
                w: 0,
                h: 0
            });
        }
    }
    get _textW() {
        return this.title ? this._Text.w : 0;
    }
    get _iconW() {
        return this.icon && this._Icon !== undefined ? this._Icon.w : 0;
    }
    get _iconH() {
        return this.icon && this._Icon !== undefined ? this._Icon.h : 0;
    }
    get _paddingX() {
        return this.title ? this.style.paddingX : this.style.paddingXNoTitle;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || this._Text && this._Text.announce;
    }
}

var base$2 = theme => {
    var knobSize = theme.spacer.xl;
    var knobPadding = theme.spacer.xs;
    var strokeWidth = theme.stroke.sm;
    return {
        height: knobSize + (knobPadding + strokeWidth) * 2,
        knobWidth: knobSize,
        knobHeight: knobSize,
        knobRadius: knobSize / 2,
        knobPadding: knobPadding,
        strokeWidth: strokeWidth,
        width: (strokeWidth + knobPadding * 2 + knobSize) * 2
    };
};

var tone$1 = theme => ({
    neutral: {
        strokeColor: theme.color.fillNeutral,
        backgroundColor: theme.color.fillInverseTertiary,
        backgroundColorChecked: theme.color.fillNeutral,
        knobColor: theme.color.fillNeutral,
        knobColorChecked: theme.color.fillInverse,
        mode: {
            disabled: {
                strokeColor: theme.color.fillNeutralDisabled,
                backgroundColor: theme.color.fillInverseDisabled,
                backgroundColorChecked: theme.color.fillNeutralDisabled,
                knobColor: theme.color.fillNeutralDisabled,
                knobColorChecked: theme.color.fillInverseDisabled
            }
        }
    },
    inverse: {
        strokeColor: theme.color.fillInverse,
        backgroundColor: theme.color.fillNeutralTertiary,
        backgroundColorChecked: theme.color.fillInverse,
        knobColor: theme.color.fillInverse,
        knobColorChecked: theme.color.fillNeutral,
        mode: {
            disabled: {
                strokeColor: theme.color.fillInverseDisabled,
                backgroundColor: theme.color.fillNeutralDisabled,
                backgroundColorChecked: theme.color.fillInverseDisabled,
                knobColor: theme.color.fillInverseDisabled,
                knobColorChecked: theme.color.fillNeutralDisabled
            }
        }
    },
    brand: {
        strokeColor: theme.color.fillBrand,
        backgroundColor: theme.color.fillBrandTertiary,
        backgroundColorChecked: theme.color.fillBrand,
        knobColor: theme.color.fillBrand,
        knobColorChecked: theme.color.fillInverse,
        mode: {
            disabled: {
                strokeColor: theme.color.fillNeutralDisabled,
                backgroundColor: theme.color.fillInverseDisabled,
                backgroundColorChecked: theme.color.fillNeutralDisabled,
                knobColor: theme.color.fillNeutralDisabled,
                knobColorChecked: theme.color.fillInverseDisabled
            }
        }
    }
});

var styles$2 = Object.freeze({
    __proto__: null,
    base: base$2,
    tone: tone$1
});

class Toggle extends Base$1 {
    static get __componentName() {
        return "Toggle";
    }
    static get __themeStyle() {
        return styles$2;
    }
    static _template() {
        return {
            Container: {
                Stroke: {},
                Knob: {}
            }
        };
    }
    static get tags() {
        return [ "Container", {
            name: "Knob",
            path: "Container.Knob"
        }, {
            name: "Stroke",
            path: "Container.Stroke"
        } ];
    }
    static get properties() {
        return [ "checked" ];
    }
    static get aliasStyles() {
        return [ {
            prev: "strokeWeight",
            curr: "strokeWidth"
        } ];
    }
    _construct() {
        super._construct && super._construct();
        this._checked = false;
    }
    _update() {
        this._updateKnobPosition();
        this._updateColors();
        this._updateContainer();
        this._updateStroke();
        this._updateKnob();
        if (this._checkedChanged) {
            this.fireAncestors("$announce", this.announce);
            this._checkedChanged = false;
        }
    }
    _updateKnobPosition() {
        var {knobPadding: knobPadding, knobWidth: knobWidth, strokeWidth: strokeWidth} = this.style;
        this.applySmooth(this._Knob, {
            x: this.checked ? this.w - strokeWidth - knobPadding - knobWidth : strokeWidth + knobPadding
        });
    }
    _updateColors() {
        var {backgroundColor: backgroundColor, backgroundColorChecked: backgroundColorChecked, knobColor: knobColor, knobColorChecked: knobColorChecked} = this.style;
        var currentKnobColor = this.checked ? knobColorChecked : knobColor;
        var containerColor = this.checked ? backgroundColorChecked : backgroundColor;
        this.applySmooth(this._Knob, {
            color: currentKnobColor
        });
        this.applySmooth(this._Container, {
            color: containerColor
        });
    }
    _updateContainer() {
        var {knobRadius: knobRadius, knobPadding: knobPadding, strokeRadius: strokeRadius, strokeWidth: strokeWidth} = this.style;
        var radius = strokeRadius !== undefined ? strokeRadius === 0 ? strokeRadius : Math.max(0, strokeRadius - strokeWidth) : Math.max(0, knobRadius + knobPadding + strokeWidth);
        this._Container.patch({
            w: this.w,
            h: this.h,
            texture: lng.Tools.getRoundRect(this.w - strokeWidth * 2 - 2, this.h - strokeWidth * 2 - 2, getMaxRoundRadius(radius, this.w, this.h), strokeWidth, 0, true, false)
        });
    }
    _updateStroke() {
        var {knobRadius: knobRadius, knobPadding: knobPadding, strokeColor: strokeColor, strokeRadius: strokeRadius, strokeWidth: strokeWidth} = this.style;
        this._Stroke.patch({
            w: this.w,
            h: this.h,
            texture: lng.Tools.getRoundRect(this.w - 2, this.h - 2, strokeRadius !== undefined ? getMaxRoundRadius(strokeRadius, this.w, this.h) : getMaxRoundRadius(knobRadius, this.w - knobPadding * 2 - 2, this.h - knobPadding * 2 - 2) + knobPadding + strokeWidth, strokeWidth, strokeColor, false, false)
        });
    }
    _updateKnob() {
        var {knobHeight: knobHeight, knobWidth: knobWidth, knobRadius: knobRadius} = this.style;
        this._Knob.patch({
            zIndex: 2,
            y: (this.h - knobHeight) / 2,
            texture: lng.Tools.getRoundRect(knobWidth - 2, knobHeight - 2, getMaxRoundRadius(knobRadius, knobWidth - 2, knobHeight - 2), 0, 0, true, false)
        });
    }
    _setChecked(checked) {
        this._checkedChanged = checked !== this._checked;
        return checked;
    }
    toggle() {
        if (!this._isDisabledMode) {
            this.checked = !this.checked;
        }
        return this;
    }
    _handleEnter() {
        if (typeof this.onEnter === "function") {
            return this.onEnter(this);
        } else {
            this.toggle();
        }
        return false;
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || (this.checked ? "Checked" : "Unchecked");
    }
}

var base$1 = theme => {
    var knobSize = theme.spacer.lg;
    var knobPadding = theme.spacer.xxs;
    var strokeWidth = theme.stroke.sm;
    return {
        height: knobSize + (knobPadding + strokeWidth) * 2,
        knobWidth: knobSize,
        knobHeight: knobSize,
        knobRadius: knobSize / 2,
        knobPadding: knobPadding,
        strokeWidth: strokeWidth,
        width: (strokeWidth + knobPadding * 2 + knobSize) * 2
    };
};

var styles$1 = Object.freeze({
    __proto__: null,
    base: base$1
});

class ToggleSmall extends Toggle {
    static get __componentName() {
        return "ToggleSmall";
    }
    static get __themeStyle() {
        return styles$1;
    }
}

class Bubble extends lng.Texture {
    constructor(stage) {
        super(stage);
        this._w = 0;
        this._h = 0;
        this._radius = 0;
        this._pointerWidth = 0;
        this._pointerHeight = 0;
        this._strokeWidth = 0;
        this._color = "white";
    }
    set w(w) {
        this._w = w;
        this._changed();
    }
    get w() {
        return this._w;
    }
    set h(h) {
        this._h = h;
        this._changed();
    }
    get h() {
        return this._h;
    }
    set radius(radius) {
        if (Array.isArray(radius)) {
            this._radius = new Array(4).fill().map(((_, index) => radius[index] || 0));
        } else {
            this._radius = radius;
        }
        this._changed();
    }
    get radius() {
        return this._radius;
    }
    set pointerWidth(pointerWidth) {
        this._pointerWidth = pointerWidth;
        this._changed();
    }
    get pointerWidth() {
        return this._pointerWidth;
    }
    set pointerHeight(pointerHeight) {
        this._pointerHeight = pointerHeight;
        this._changed();
    }
    get pointerHeight() {
        return this._pointerHeight;
    }
    set strokeWidth(strokeWidth) {
        this._strokeWidth = strokeWidth;
        this._changed();
    }
    get strokeWidth() {
        return this._strokeWidth;
    }
    set color(color) {
        this._color = lng.StageUtils.getRgbaString(color);
        this._changed();
    }
    get color() {
        return this._color;
    }
    createBubble(_ref24) {
        var {stage: stage, w: w = 0, h: h = 0, radius: radius = 0, pointerWidth: pointerWidth = 0, pointerHeight: pointerHeight = 0, strokeWidth: strokeWidth = 1, color: color = "white"} = _ref24;
        var canvas = stage.platform.getDrawingCanvas();
        var ctx = canvas.getContext("2d");
        canvas.width = w + strokeWidth + 4;
        canvas.height = h + strokeWidth + 4;
        ctx.imageSmoothingEnabled = true;
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        ctx.lineWidth = strokeWidth;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        var initialCoord = .5 * strokeWidth + 1;
        var leftX = initialCoord;
        var rightX = leftX + w;
        var topY = initialCoord;
        var bottomY = topY + h;
        var bottomBubbleY = bottomY - pointerHeight;
        var isRadiusAnArray = Array.isArray(radius);
        ctx.beginPath();
        ctx.moveTo(leftX + (isRadiusAnArray ? radius[0] : radius), topY);
        ctx.lineTo(rightX - (isRadiusAnArray ? radius[0] : radius), topY);
        ctx.arcTo(rightX, topY, rightX, topY + (isRadiusAnArray ? radius[1] : radius), isRadiusAnArray ? radius[1] : radius);
        ctx.lineTo(rightX, bottomBubbleY - (isRadiusAnArray ? radius[2] : radius));
        ctx.arcTo(rightX, bottomBubbleY, rightX - (isRadiusAnArray ? radius[2] : radius), bottomBubbleY, isRadiusAnArray ? radius[2] : radius);
        ctx.lineTo(w / 2 + pointerWidth / 2, bottomBubbleY);
        ctx.arcTo(w / 2, bottomY, w / 2 - pointerWidth / 2, bottomBubbleY, 2);
        ctx.lineTo(w / 2 - pointerWidth / 2, bottomBubbleY);
        ctx.lineTo(leftX + (isRadiusAnArray ? radius[3] : radius), bottomBubbleY);
        ctx.arcTo(leftX, bottomBubbleY, leftX, bottomBubbleY - (isRadiusAnArray ? radius[3] : radius), isRadiusAnArray ? radius[3] : radius);
        ctx.lineTo(leftX, topY + (isRadiusAnArray ? radius[0] : radius));
        ctx.arcTo(leftX, topY, leftX + (isRadiusAnArray ? radius[0] : radius), topY, isRadiusAnArray ? radius[0] : radius);
        ctx.stroke();
        ctx.fill();
        return canvas;
    }
    _getLookupId() {
        var {w: w, h: h, radius: radius, pointerWidth: pointerWidth, pointerHeight: pointerHeight, color: color} = this;
        return "__bubble_".concat(w, "x").concat(h, "_radius-").concat(radius, "_pointer-").concat(pointerWidth, "x").concat(pointerHeight, "_fill-").concat(color);
    }
    _getSourceLoader() {
        return cb => {
            cb(null, {
                source: this.createBubble(this)
            });
        };
    }
}

var base = theme => ({
    marginBottom: theme.spacer.xl,
    paddingX: theme.spacer.lg,
    paddingY: theme.spacer.md,
    pointerWidth: theme.spacer.xxl,
    pointerHeight: theme.spacer.lg,
    radius: theme.radius.sm,
    textStyle: _objectSpread(_objectSpread({}, theme.typography.body3), {}, {
        textColor: theme.color.textInverse
    }),
    transition: theme.animation.utility
});

var tone = theme => ({
    neutral: {
        backgroundColor: theme.color.fillNeutral,
        textStyle: {
            textColor: theme.color.textInverse
        }
    },
    inverse: {
        backgroundColor: theme.color.fillInverse,
        textStyle: {
            textColor: theme.color.textNeutral
        }
    },
    brand: {
        backgroundColor: theme.color.fillBrand,
        textStyle: {
            textColor: theme.color.textNeutral
        }
    }
});

var styles = Object.freeze({
    __proto__: null,
    base: base,
    tone: tone
});

class Tooltip extends Base$1 {
    static get __componentName() {
        return "Tooltip";
    }
    static get __themeStyle() {
        return styles;
    }
    static _template() {
        return {
            alpha: 0,
            scale: .5,
            mountX: .5,
            x: w => w / 2,
            Background: {
                Text: {
                    type: TextBox,
                    signals: {
                        textBoxChanged: "_textLoaded"
                    }
                }
            }
        };
    }
    static get properties() {
        return [ "title", "delayVisible", "timeVisible" ];
    }
    static get tags() {
        return [ "Background", {
            name: "Text",
            path: "Background.Text"
        } ];
    }
    static get aliasStyles() {
        return [ {
            prev: "pointerH",
            curr: "pointerHeight"
        }, {
            prev: "pointerW",
            curr: "pointerWidth"
        } ];
    }
    _update() {
        this._updateText();
        this._updateBackground();
    }
    _updateText() {
        if (this._Text) {
            this._Text.patch({
                content: this.title,
                style: {
                    textStyle: this.style.textStyle
                }
            });
        }
    }
    _textLoaded() {
        this._updateBackgroundHeight();
        this._updateTextPosition();
    }
    _updateBackground() {
        this.patch({
            Background: {
                texture: {
                    type: Bubble,
                    w: this._Background.w,
                    h: this._Background.h,
                    radius: getMaxRoundRadius(this.style.radius, this._Background.w - this.style.pointerHeight, this._Background.h - this.style.pointerHeight),
                    pointerWidth: this.style.pointerWidth,
                    pointerHeight: this.style.pointerHeight,
                    color: this.style.backgroundColor
                }
            }
        });
    }
    _updateBackgroundHeight() {
        var backgroundH = this._Text.finalH + this.style.paddingY * 2 + this.style.pointerHeight;
        var backgroundW = this._Text.finalW + this.style.paddingX * 2;
        this.patch({
            w: backgroundW,
            h: backgroundH,
            mountY: 1,
            y: -this.style.marginBottom,
            Background: {
                w: backgroundW,
                h: backgroundH,
                texture: {
                    type: Bubble,
                    w: backgroundW,
                    h: backgroundH
                }
            }
        });
    }
    _updateTextPosition() {
        if (this._Text) {
            this._Text.patch({
                mount: .5,
                x: this._Background.w / 2,
                y: (this._Background.h - this.style.pointerHeight) / 2
            });
        }
    }
    _clearTimers() {
        clearTimeout(this._hideTimer);
        clearTimeout(this._showTimer);
    }
    _transitionIn() {
        var smooth = {
            smooth: {
                alpha: [ 1, this.style.transition ],
                scale: [ 1, this.style.transition ]
            }
        };
        if (this.delayVisible) {
            this._showTimer = setTimeout((() => {
                this.patch({
                    smooth: smooth
                });
            }), this.delayVisible);
        } else {
            this._showTimer = undefined;
            this.patch({
                smooth: smooth
            });
        }
        this._hideTimer = this.timeVisible ? setTimeout((() => {
            this._unfocus();
        }), this.timeVisible + (this.delayVisible || 0)) : undefined;
    }
    _transitionOut() {
        this.patch({
            smooth: {
                alpha: [ 0, this.style.transition ],
                scale: [ .5, this.style.transition ]
            }
        });
    }
    _focus() {
        this._clearTimers();
        this._transitionIn();
    }
    _unfocus() {
        this._clearTimers();
        this._transitionOut();
    }
    set announce(announce) {
        super.announce = announce;
    }
    get announce() {
        return this._announce || this._Text && this._Text.announce;
    }
}

var pools = new Map;

function get(key) {
    if (pools.has(key)) {
        var pool = pools.get(key);
        var _index = pool.index;
        if (_index >= pool.components.length) {
            _index = 0;
        }
        pool.index = _index + 1;
        return pool.components[_index];
    }
    return false;
}

function clear() {
    pools.clear();
}

function create(_ref25) {
    var {name: name, component: component, stage: stage, size: size = 2} = _ref25;
    if (pools.has(name)) {
        return get(name);
    }
    component = component || {
        type: name
    };
    var components = [];
    for (var i = 0; i < size; i++) {
        components.push(stage.c(component));
    }
    pools.set(name, {
        index: 0,
        components: components
    });
    return get(name);
}

var index$2 = {
    get: get,
    create: create,
    clear: clear
};

function flattenStrings() {
    var series = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var flattenedSeries = [];
    for (var i = 0; i < series.length; i++) {
        if (typeof series[i] === "string" && !series[i].includes("PAUSE-")) {
            flattenedSeries.push(series[i]);
        } else {
            break;
        }
    }
    return [ flattenedSeries.join(",\b ") ].concat(series.slice(i));
}

function delay(pause) {
    return new Promise((resolve => {
        setTimeout(resolve, pause);
    }));
}

function speak(phrase, utterances) {
    var lang = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "en-US";
    var synth = window.speechSynthesis;
    return new Promise(((resolve, reject) => {
        var utterance = new SpeechSynthesisUtterance(phrase);
        utterance.lang = lang;
        utterance.onend = () => {
            resolve();
        };
        utterance.onerror = e => {
            reject(e);
        };
        utterances.push(utterance);
        synth.speak(utterance);
    }));
}

function speakSeries(series, lang) {
    var root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var synth = window.speechSynthesis;
    var remainingPhrases = flattenStrings(Array.isArray(series) ? series : [ series ]);
    var nestedSeriesResults = [];
    var utterances = [];
    var active = true;
    var seriesChain = _asyncToGenerator((function*() {
        try {
            while (active && remainingPhrases.length) {
                var phrase = yield Promise.resolve(remainingPhrases.shift());
                if (!active) {
                    break;
                } else if (typeof phrase === "string" && phrase.includes("PAUSE-")) {
                    var pause = phrase.split("PAUSE-")[1] * 1e3;
                    if (isNaN(pause)) {
                        pause = 0;
                    }
                    yield delay(pause);
                } else if (typeof phrase === "string" && phrase.length) {
                    var totalRetries = 3;
                    var retriesLeft = totalRetries;
                    while (active && retriesLeft > 0) {
                        try {
                            yield speak(phrase, utterances, lang);
                            retriesLeft = 0;
                        } catch (e) {
                            if (e instanceof SpeechSynthesisErrorEvent) {
                                if (e.error === "network") {
                                    retriesLeft--;
                                    console.warn("Speech synthesis network error. Retries left: ".concat(retriesLeft));
                                    yield delay(500 * (totalRetries - retriesLeft));
                                } else if (e.error === "canceled" || e.error === "interrupted") {
                                    retriesLeft = 0;
                                } else {
                                    throw new Error("SpeechSynthesisErrorEvent: ".concat(e.error));
                                }
                            } else {
                                throw e;
                            }
                        }
                    }
                } else if (typeof phrase === "function") {
                    var seriesResult = speakSeries(phrase(), lang, false);
                    nestedSeriesResults.push(seriesResult);
                    yield seriesResult.series;
                } else if (Array.isArray(phrase)) {
                    var _seriesResult = speakSeries(phrase, lang, false);
                    nestedSeriesResults.push(_seriesResult);
                    yield _seriesResult.series;
                }
            }
        } finally {
            active = false;
        }
    }))();
    return {
        series: seriesChain,
        get active() {
            return active;
        },
        append: toSpeak => {
            remainingPhrases.push(toSpeak);
        },
        cancel: () => {
            if (!active) {
                return;
            }
            if (root) {
                synth.cancel();
            }
            nestedSeriesResults.forEach((nestedSeriesResults => {
                nestedSeriesResults.cancel();
            }));
            active = false;
        }
    };
}

var currentSeries;

function Speech(toSpeak, lang) {
    currentSeries && currentSeries.cancel();
    currentSeries = speakSeries(toSpeak, lang);
    return currentSeries;
}

var defaultAbbreviations = [ {
    pattern: "TV-14",
    replacer: "Rated TV-14"
}, {
    pattern: "CC",
    replacer: "Closed Captions available"
}, {
    pattern: "HD",
    replacer: "High Definition available"
}, {
    pattern: /ENG(?!\+)/,
    replacer: "English Available"
}, {
    pattern: /ENG\+ES/,
    replacer: "Available in English and Spanish"
}, {
    pattern: "AD",
    replacer: "Audio Description available"
}, {
    pattern: "RT",
    replacer: "Rotten Tomatoes"
}, {
    pattern: /(S)+(\d+)+(E)+(\d+)+/,
    replacer: (match, p1, p2, p3, p4) => "Season ".concat(p2, " Episode ").concat(p4)
} ];

var defaultAbbrevConfig = generateAbbrevConfig(defaultAbbreviations);

function wrapWithBoundary(str) {
    return "\\b".concat(str, "\\b");
}

function getNumberOfCaptureGroups(regExp) {
    return new RegExp(regExp.toString() + "|").exec("").length - 1;
}

function generateAbbrevConfig() {
    var abbreviations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultAbbreviations;
    var extendDefault = arguments.length > 1 ? arguments[1] : undefined;
    var abbrev = extendDefault ? [ ...defaultAbbreviations, ...abbreviations ] : abbreviations;
    var stringPatternMap = {};
    var regExpPatternMap = {};
    var abbreviationsPattern = "";
    var patternGroupOffset = 0;
    abbrev.forEach(((_ref27, idx) => {
        var {pattern: pattern, replacer: replacer} = _ref27;
        var stringPattern;
        if (pattern instanceof RegExp) {
            var patternMapIdx = idx + patternGroupOffset;
            regExpPatternMap[patternMapIdx] = {
                pattern: pattern,
                replacer: replacer
            };
            stringPattern = wrapWithBoundary(pattern.source);
            patternGroupOffset += getNumberOfCaptureGroups(pattern);
        } else {
            stringPatternMap[pattern] = {
                replacer: replacer
            };
            stringPattern = wrapWithBoundary(pattern);
        }
        abbreviationsPattern = abbreviationsPattern === "" ? "(".concat(stringPattern, ")") : "".concat(abbreviationsPattern, "|(").concat(stringPattern, ")");
    }));
    abbreviationsPattern = new RegExp(abbreviationsPattern, "g");
    return {
        abbreviationsPattern: abbreviationsPattern,
        stringPatternMap: stringPatternMap,
        regExpPatternMap: regExpPatternMap
    };
}

var translateAbbrev = (phrase, translationConfig) => {
    var {abbreviationsPattern: abbreviationsPattern, stringPatternMap: stringPatternMap, regExpPatternMap: regExpPatternMap} = translationConfig;
    var translated = phrase.replace(abbreviationsPattern, (function(matched) {
        if (stringPatternMap[matched]) {
            return stringPatternMap[matched].replacer;
        }
        for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
            args[_key7 - 1] = arguments[_key7];
        }
        var patternIdx = args.findIndex((arg => !!arg));
        var {pattern: pattern, replacer: replacer} = regExpPatternMap[patternIdx];
        if (typeof replacer === "string") {
            return replacer;
        }
        if (typeof replacer === "function") {
            return matched.replace(pattern, replacer);
        }
    }));
    return translated;
};

var fiveMinutes = 300 * 1e3;

function elmName(elm) {
    return elm.ref || elm.constructor.name;
}

var defaultOptions = {
    voiceOutDelay: 500,
    abbreviationsConfig: {}
};

function withAnnouncer(Base) {
    var speak = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Speech;
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var announcerOptions = _objectSpread(_objectSpread({}, defaultOptions), options);
    return class extends Base {
        _construct() {
            this._announceEndedTimeout;
            this._currentlySpeaking = "";
            super._construct && super._construct();
        }
        _voiceOut(toAnnounce) {
            if (this._voiceOutDisabled) {
                return;
            }
            var toSpeak = toAnnounce;
            if (announcerOptions.abbreviationsConfig.abbreviationsPattern) {
                toSpeak = Array.isArray(toAnnounce) ? toAnnounce.map((phrase => translateAbbrev(phrase, announcerOptions.abbreviationsConfig))) : translateAbbrev(toAnnounce, announcerOptions.abbreviationsConfig);
            }
            var speech = speak(toSpeak, options.language);
            if (speech && speech.series) {
                speech.series.then((() => {
                    this.stage.emit("announceEnded");
                }));
            }
            var toAnnounceStr = Array.isArray(toSpeak) ? toSpeak.concat().join(" ") : toSpeak;
            var toAnnounceWords = toAnnounceStr.split(" ");
            var timeoutDelay = toAnnounceWords.length * announcerOptions.voiceOutDelay;
            clearTimeout(this._announceEndedTimeout);
            this._announceEndedTimeout = setTimeout((() => {
                this.stage.emit("announceTimeoutEnded");
            }), timeoutDelay);
            return speech;
        }
        _build() {
            super._build && super._build();
            this._debounceAnnounceFocusChanges = debounce(this._announceFocusChanges.bind(this), Number.isInteger(this.announcerFocusDebounce) ? this.announcerFocusDebounce : 400);
            this.announcerTimeout = Number.isInteger(this.announcerTimeout) ? this.announcerTimeout : fiveMinutes;
            this._resetFocusTimer = debounce((() => {
                this._lastFocusPath = undefined;
            }), this.announcerTimeout);
        }
        _firstEnable() {
            super._firstEnable && super._firstEnable();
            this._focusChange();
        }
        _disable() {
            clearTimeout(this._announceEndedTimeout);
            this.stage.emit("announceEnded");
            this.stage.emit("announceTimeoutEnded");
        }
        set announcerEnabled(val) {
            this._announcerEnabled = val;
            this._focusChange();
        }
        get announcerEnabled() {
            return this._announcerEnabled;
        }
        _focusChange() {
            if (!this._resetFocusTimer) {
                return;
            }
            this._resetFocusTimer();
            this.$announcerCancel();
            this._debounceAnnounceFocusChanges();
        }
        _announceFocusChanges() {
            var focusPath = this.application.focusPath || [];
            var lastFocusPath = this._lastFocusPath || [];
            var loaded = focusPath.every((elm => !elm.loading));
            var focusDiff = focusPath.filter((elm => !lastFocusPath.includes(elm)));
            if (!loaded) {
                this._debounceAnnounceFocusChanges();
                return;
            }
            this._lastFocusPath = focusPath.slice(0);
            this.focusDiffHook = focusDiff;
            if (!this.announcerEnabled) {
                return;
            }
            var toAnnounce = focusDiff.reduce(((acc, elm) => {
                if (elm.announce) {
                    acc.push([ elmName(elm), "Announce", elm.announce ]);
                } else if (elm.title) {
                    acc.push([ elmName(elm), "Title", elm.title || "" ]);
                }
                return acc;
            }), []);
            focusDiff.reverse().reduce(((acc, elm) => {
                if (elm.announceContext) {
                    acc.push([ elmName(elm), "Context", elm.announceContext ]);
                } else {
                    acc.push([ elmName(elm), "No Context", "" ]);
                }
                return acc;
            }), toAnnounce);
            if (this.debug) {
                console.table(toAnnounce);
            }
            toAnnounce = toAnnounce.reduce(((acc, a) => {
                var txt = a[2];
                txt && acc.push(txt);
                return acc;
            }), []);
            if (toAnnounce.length) {
                this.$announcerCancel();
                this._currentlySpeaking = this._voiceOut(toAnnounce.reduce(((acc, val) => acc.concat(val)), []));
            }
        }
        $announce(toAnnounce) {
            var {append: append = false, notification: notification = false} = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            if (!toAnnounce || !toAnnounce.trim().length) {
                return;
            }
            if (this.announcerEnabled) {
                this._debounceAnnounceFocusChanges.flush();
                if (append && this._currentlySpeaking && this._currentlySpeaking.active) {
                    this._currentlySpeaking.append(toAnnounce);
                } else {
                    this.$announcerCancel();
                    this._currentlySpeaking = this._voiceOut(toAnnounce);
                }
                if (notification) {
                    this._voiceOutDisabled = true;
                    this._currentlySpeaking.series.finally((() => {
                        this._voiceOutDisabled = false;
                        this.$announcerRefresh();
                    }));
                }
            }
        }
        $announcerCancel() {
            this._currentlySpeaking && this._currentlySpeaking.cancel();
        }
        $announcerRefresh(depth) {
            if (depth) {
                this._lastFocusPath = this._lastFocusPath.slice(0, depth);
            } else {
                this._lastFocusPath = undefined;
            }
            this._resetFocusTimer();
            this._focusChange();
        }
    };
}

function index$1(classImp) {
    var cache = new Map;
    return base => {
        if (cache.has(base)) {
            return cache.get(base);
        }
        var classWithNewBase = classImp(base);
        cache.set(base, classWithNewBase);
        return classWithNewBase;
    };
}

function withSelections(Base) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var defaultOpts = {
        captureKey: "Enter",
        defaultIndex: 0,
        eventName: "onSelect",
        keys: {
            currentSelected: "currentSelected",
            currentSelectedIndex: "currentSelectedIndex",
            isSelected: "isSelected",
            items: "items",
            setSelected: "setSelected"
        }
    };
    var {captureKey: captureKey, defaultIndex: defaultIndex, eventName: eventName, keys: {currentSelected: currentSelected, currentSelectedIndex: currentSelectedIndex, isSelected: isSelected, items: items, setSelected: setSelected}} = _objectSpread(_objectSpread(_objectSpread({}, defaultOpts), options), {}, {
        keys: _objectSpread(_objectSpread({}, defaultOpts.keys), options.keys)
    });
    return class extends Base {
        static get name() {
            return Base.name;
        }
        _construct() {
            super._construct();
            this[currentSelectedIndex] = defaultIndex;
        }
        _init() {
            super._init();
            this[currentSelected][isSelected] = true;
        }
        [setSelected](selected, val) {
            var prevSelected = (this[items] || [])[this[currentSelectedIndex]];
            if (selected && (selected !== prevSelected || selected[isSelected] !== val)) {
                prevSelected && (prevSelected[isSelected] = false);
                selected[isSelected] = val;
                this[currentSelectedIndex] = Array.from(this[items] || []).indexOf(selected);
                this.fireAncestors("$" + eventName, selected, val);
            }
        }
        _captureKey(event) {
            if (Array.isArray(captureKey) && captureKey.indexOf(event.key) > -1 || event.key === captureKey) {
                var [selected] = this.stage.application.focusPath.slice(-1);
                this[setSelected](selected, true);
            }
            return false;
        }
        ["$" + setSelected](selected, val) {
            this[setSelected](selected, val);
        }
        get [currentSelected]() {
            return this[items][this[currentSelectedIndex]];
        }
    };
}

function index(Base) {
    return class extends Base {
        _init() {
            super._init();
            this.isEditing = false;
        }
        toggleEdit() {
            this.isEditing = !this.isEditing;
        }
        _unfocus() {
            this.isEditing = false;
            super._unfocus();
        }
        _swapItemArrayPos(array, current, previous) {
            [array[current], array[previous]] = [ array[previous], array[current] ];
            super.selectedIndex = current;
        }
        _getPositionValue(item, axis) {
            return item.transition(axis) ? item.transition(axis).targetValue : item[axis];
        }
        _waitForTransition(item, axis) {
            return new Promise((resolve => item._getTransition(axis).on("finish", resolve)));
        }
        get selectedIndex() {
            return super.selectedIndex;
        }
        set selectedIndex(index) {
            var _this10 = this;
            if (!this.isEditing || this.selectedIndex >= this.items.length - 1 && index > this.selectedIndex) {
                if (!this.isEditing) {
                    super.selectedIndex = index;
                }
                return;
            }
            var currentItem = this.selected;
            this.prevSelected = currentItem;
            var nextItem = this.items[index];
            var previousIndex = this.selectedIndex;
            var oldPos = {
                x: this._getPositionValue(currentItem, "x"),
                y: this._getPositionValue(currentItem, "y")
            };
            var newPos = {
                x: this._getPositionValue(nextItem, "x"),
                y: this._getPositionValue(nextItem, "y")
            };
            var previousCurrentItemZIndex = currentItem.zIndex;
            currentItem.zIndex = previousCurrentItemZIndex + 1;
            this._swapItemArrayPos(this.items, index, previousIndex);
            currentItem.setSmooth("x", newPos.x);
            currentItem.setSmooth("y", newPos.y);
            nextItem.setSmooth("x", oldPos.x);
            nextItem.setSmooth("y", oldPos.y);
            _asyncToGenerator((function*() {
                var _this10$Items$childre;
                yield Promise.all([ _this10._waitForTransition(currentItem, "x"), _this10._waitForTransition(currentItem, "y"), _this10._waitForTransition(nextItem, "x"), _this10._waitForTransition(nextItem, "y") ]);
                currentItem.zIndex = previousCurrentItemZIndex;
                if (!_this10.Items.children.length || !((_this10$Items$childre = _this10.Items.children[index]) !== null && _this10$Items$childre !== void 0 && _this10$Items$childre.skipFocus)) {
                    _this10._selectedIndex = index;
                    _this10._render(_this10.selected, _this10.prevSelected);
                    _this10.signal("selectedChange", _this10.selected, _this10.prevSelected);
                    _this10._refocus();
                }
            }))();
        }
        _selectedChange(selected, prevSelected) {
            if (this.isEditing) return;
            this._render(selected, prevSelected);
            this.signal("selectedChange", selected, prevSelected);
        }
    };
}

var rad = deg => deg * Math.PI / 180;

var deg = rad => rad * 180 / Math.PI;

var getBreakpoints = (width, height) => {
    var a = height / 2;
    var b = width / 2;
    var c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
    var C = 90;
    var A = Math.ceil(deg(Math.asin(a * Math.sin(rad(C)) / c)));
    var B = 180 - C - A;
    return [ B, 90, 90 + A, 180, 180 + B, 270, 270 + A, 360 ];
};

var points = (degrees, width, height) => {
    var breakAngles = getBreakpoints(width, height);
    var breakIndex = breakAngles.findIndex((angle => angle >= degrees));
    var b = height / 2;
    var max = width / 2;
    if ([ 1, 2, 5, 6 ].includes(breakIndex)) {
        b = width / 2;
        max = height / 2;
    }
    if ([ 2, 4, 6 ].includes(breakIndex)) {
        degrees = degrees - breakAngles[breakIndex - 1];
    } else if (breakIndex > 0) {
        degrees = breakAngles[breakIndex] - degrees;
    }
    var A = degrees;
    var B = 90 - A;
    var a = Math.ceil(Math.sin(rad(A)) * b / Math.sin(rad(B)));
    if (a > max) {
        a = max;
    }
    var x0 = 0;
    var y0 = 0;
    var x1 = 0;
    var y1 = 0;
    switch (breakIndex) {
      case 0:
        x0 = width / 2 + a;
        break;

      case 1:
        x0 = width;
        y0 = height / 2 - a;
        break;

      case 2:
        x0 = width;
        y0 = height / 2 + a;
        break;

      case 3:
        x0 = width / 2 + a;
        y0 = height;
        break;

      case 4:
        x0 = width / 2 - a;
        y0 = height;
        break;

      case 5:
        y0 = height / 2 + a;
        break;

      case 6:
        y0 = height / 2 - a;
        break;

      case 7:
        x0 = width / 2 - a;
        break;
    }
    if (x0 == 0) {
        x1 = width;
        y1 = height - y0;
    }
    if (y0 == 0) {
        y1 = height;
        x1 = width - x0;
    }
    if (x0 == width) {
        x1 = 0;
        y1 = height - y0;
    }
    if (y0 == height) {
        y1 = 0;
        x1 = width - x0;
    }
    return {
        x0: x0,
        y0: y0,
        x1: x1,
        y1: y1
    };
};

class LinearGradient extends lng.Texture {
    constructor(stage) {
        super(stage);
        this._w = 0;
        this._h = 0;
        this._steps = [];
        this._degrees = 0;
    }
    get w() {
        return this._w;
    }
    set w(w) {
        this._w = w;
        this._changed();
    }
    get h() {
        return this._h;
    }
    set h(h) {
        this._h = h;
        this._changed();
    }
    get steps() {
        return this._steps;
    }
    set steps(steps) {
        this._steps = steps;
        this._changed();
    }
    get degrees() {
        return this._degrees;
    }
    set degrees(degrees) {
        this._degrees = degrees;
        this._changed();
    }
    _getLookupId() {
        return "__linearGradient_".concat(this._h, "_").concat(this._w, "_").concat(this._steps.count, "_").concat(this._degrees);
    }
    _getSourceLoader() {
        var w = this._w;
        var h = this._h;
        var d = this._degrees;
        var p = points(d, w, h);
        var {x0: x0, y0: y0, x1: x1, y1: y1} = p;
        var steps = this._steps;
        var strokeWidth = this.strokeWidth;
        var strokeRadius = this.strokeRadius ? Array.isArray(this.strokeRadius) && this.strokeRadius.length === 4 ? this.strokeRadius : Array(4).fill(this.strokeRadius) : Array(4).fill(0);
        return function(cb) {
            var canvas = this.stage.platform.getDrawingCanvas();
            canvas.width = w + strokeWidth + 2;
            canvas.height = h + strokeWidth + 2;
            var ctx = canvas.getContext("2d");
            var gradient = ctx.createLinearGradient(x0, y0, x1, y1);
            steps.forEach((step => {
                gradient.addColorStop(step.percent, step.color);
            }));
            if (strokeWidth) {
                var x = .5 * strokeWidth + 1, y = .5 * strokeWidth + 1;
                ctx.beginPath();
                ctx.moveTo(x + strokeRadius[0], y);
                ctx.lineTo(x + w - strokeRadius[1], y);
                ctx.arcTo(x + w, y, x + w, y + strokeRadius[1], strokeRadius[1]);
                ctx.lineTo(x + w, y + h - strokeRadius[2]);
                ctx.arcTo(x + w, y + h, x + w - strokeRadius[2], y + h, strokeRadius[2]);
                ctx.lineTo(x + strokeRadius[3], y + h);
                ctx.arcTo(x, y + h, x, y + h - strokeRadius[3], strokeRadius[3]);
                ctx.lineTo(x, y + strokeRadius[0]);
                ctx.arcTo(x, y, x + strokeRadius[0], y, strokeRadius[0]);
                ctx.closePath();
                ctx.lineWidth = strokeWidth;
                ctx.strokeStyle = gradient;
                ctx.stroke();
            } else {
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, w, h);
            }
            cb(null, {
                source: canvas,
                w: w,
                h: h
            });
        };
    }
}

class Circle extends lng.Texture {
    constructor(stage) {
        super(stage);
        this._color = "rgb(0,0,0)";
        this._fill = true;
        this._radius = 100;
        this._stroke = false;
        this._strokeColor = "rgb(0,0,0)";
        this._strokeWidth = 1;
    }
    get fill() {
        return this._fill;
    }
    set fill(fill) {
        this._fill = fill;
        this._changed();
    }
    get radius() {
        return this._radius;
    }
    set radius(radius) {
        this._radius = radius;
        this._changed();
    }
    get color() {
        return this._color;
    }
    set color(color) {
        this._color = color;
        this._changed();
    }
    get stroke() {
        return this._stroke;
    }
    set stroke(stroke) {
        this._stroke = stroke;
        this._changed();
    }
    get strokeWidth() {
        return this._strokeWidth;
    }
    set strokeWidth(strokeWidth) {
        this._strokeWidth = strokeWidth;
        this._changed();
    }
    get strokeColor() {
        return this._strokeColor;
    }
    set strokeColor(strokeColor) {
        this._strokeColor = strokeColor;
        this._changed();
    }
    _getLookupId() {
        return "__circle_".concat(this._radius);
    }
    _getSourceLoader() {
        var color = this._color;
        var fill = this._fill;
        var radius = this._radius;
        var stroke = this._stroke;
        var strokeColor = this._strokeColor;
        var strokeWidth = this._strokeWidth;
        var canvas = this.stage.platform.getDrawingCanvas();
        var dimension = radius;
        if (stroke) {
            dimension = radius + strokeWidth * 2;
        }
        canvas.width = dimension * 2;
        canvas.height = dimension * 2;
        return function(cb) {
            var ctx = canvas.getContext("2d");
            ctx.lineWidth = strokeWidth;
            ctx.strokeStyle = strokeColor;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(dimension, dimension, radius, 0, 2 * Math.PI);
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
            cb(null, {
                source: canvas,
                radius: radius
            });
        };
    }
}

class Arrow extends lng.Texture {
    constructor(stage) {
        super(stage);
        this._color = "rgb(13, 13, 15)";
        this._w = 0;
        this._h = 0;
        this._direction = "right";
    }
    get w() {
        return this._w;
    }
    set w(l) {
        this._w = l;
        this._changed();
    }
    get h() {
        return this._h;
    }
    set h(l) {
        this._h = l;
        this._changed();
    }
    get direction() {
        return this._direction;
    }
    get color() {
        return this._color;
    }
    set color(color) {
        this._color = color;
        this._changed();
    }
    set direction(direction) {
        this._direction = direction;
        this._changed();
    }
    _getLookupId() {
        return "__triangle_".concat(this._direction, "_").concat(this._w, "x").concat(this._h);
    }
    _getSourceLoader() {
        var color = this._color;
        var w = this._w;
        var h = this._h;
        var direction = this._direction;
        var canvas = this.stage.platform.getDrawingCanvas();
        return function(cb) {
            var ctx = canvas.getContext("2d");
            canvas.width = w;
            canvas.height = h;
            ctx.fillStyle = color;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.lineWidth = 2;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            var p = ctx.lineWidth / 2;
            ctx.beginPath();
            if (direction === "right") {
                ctx.moveTo(p, p);
                ctx.lineTo(p, h - p);
                ctx.lineTo(w - p, h / 2);
            } else if (direction === "down") {
                ctx.moveTo(p, p);
                ctx.lineTo(w - p, p);
                ctx.lineTo(w / 2, h - p);
            } else {
                ctx.moveTo(p, h / 2);
                ctx.lineTo(w - p, p);
                ctx.lineTo(w - p, h - p);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
            cb(null, {
                source: canvas,
                w: w,
                h: h,
                direction: direction
            });
        };
    }
}

class Line extends lng.Texture {
    constructor(stage) {
        super(stage);
        this._w = 0;
        this._h = 0;
        this._rounded = false;
    }
    get w() {
        return this._w;
    }
    set w(l) {
        this._w = l;
        this._changed();
    }
    get h() {
        return this._h;
    }
    set h(l) {
        this._h = l;
        this._changed();
    }
    get rounded() {
        return this._rounded;
    }
    set rounded(rounded) {
        this._rounded = rounded;
        this._changed();
    }
    _getLookupId() {
        return "__line_".concat(this._w, "x").concat(this._h).concat(this._rounded ? "_rounded" : "");
    }
    _getSourceLoader() {
        var w = this._w;
        var h = this._h;
        var rounded = this._rounded;
        var canvas = this.stage.platform.getDrawingCanvas();
        return function(cb) {
            var ctx = canvas.getContext("2d");
            canvas.width = w;
            canvas.height = h;
            ctx.lineWidth = h;
            if (rounded) {
                ctx.lineCap = "round";
            }
            ctx.strokeStyle = "white";
            ctx.beginPath();
            ctx.moveTo(rounded ? 2 : 0, h / 2);
            ctx.lineTo(rounded ? w - 2 : w, h / 2);
            ctx.stroke();
            cb(null, {
                source: canvas,
                w: w,
                h: h,
                rounded: rounded
            });
        };
    }
}

class SignalButton extends Button {
    onEnter() {
        this.signal(this.signalName);
    }
    set signalName(signalName) {
        this._signalName = signalName;
    }
    get signalName() {
        return this._signalName;
    }
}

exports.Arrow = Arrow;

exports.Artwork = Artwork;

exports.Badge = Badge;

exports.Base = Base$1;

exports.Bubble = Bubble;

exports.Button = Button;

exports.ButtonSmall = ButtonSmall;

exports.Card = Card;

exports.CardContent = CardContent;

exports.CardContentHorizontal = CardContentHorizontal;

exports.CardContentHorizontalLarge = CardContentHorizontalLarge;

exports.CardContentVertical = CardContentVertical;

exports.CardContentVerticalSmall = CardContentVerticalSmall;

exports.CardRadio = CardRadio;

exports.CardSection = CardSection;

exports.CardTitle = CardTitle;

exports.Checkbox = Checkbox;

exports.CheckboxSmall = CheckboxSmall;

exports.Circle = Circle;

exports.Column = Column;

exports.Control = Control;

exports.ControlRow = ControlRow;

exports.ControlSmall = ControlSmall;

exports.FadeShader = FadeShader;

exports.FocusManager = FocusManager;

exports.Gradient = Gradient;

exports.GridOverlay = GridOverlay;

exports.Icon = Icon;

exports.InlineContent = InlineContent;

exports.Input = Input;

exports.Key = Key;

exports.Keyboard = Keyboard;

exports.KeyboardEmail = KeyboardEmail;

exports.KeyboardFullscreen = KeyboardFullScreen;

exports.KeyboardInput = KeyboardInput;

exports.KeyboardNumbers = KeyboardNumbers;

exports.KeyboardQwerty = KeyboardQwerty;

exports.KeyboardSearch = KeyboardSearch;

exports.Knob = Knob;

exports.Label = Label;

exports.Line = Line;

exports.LinearGradient = LinearGradient;

exports.ListItem = ListItem;

exports.ListItemPicker = ListItemPicker;

exports.ListItemSlider = ListItemSlider;

exports.Marquee = Marquee;

exports.MetadataBase = MetadataBase$1;

exports.MetadataCard = MetadataCard;

exports.MetadataCardContent = MetadataCardContent;

exports.MetadataTile = MetadataTile;

exports.NavigationManager = NavigationManager;

exports.ProgressBar = ProgressBar;

exports.Provider = Provider;

exports.Radio = Radio;

exports.RadioSmall = RadioSmall;

exports.Row = Row;

exports.ScrollWrapper = ScrollWrapper;

exports.Shadow = Shadow;

exports.SignalButton = SignalButton;

exports.Slider = Slider;

exports.SliderLarge = SliderLarge;

exports.Speech = Speech;

exports.Surface = Surface;

exports.Tab = Tab;

exports.TabBar = TabBar;

exports.TextBox = TextBox;

exports.Tile = Tile;

exports.TitleRow = TitleRow;

exports.Toggle = Toggle;

exports.ToggleSmall = ToggleSmall;

exports.Tooltip = Tooltip;

exports.context = contextInstance;

exports.defaultAbbrevConfig = defaultAbbrevConfig;

exports.generateAbbrevConfig = generateAbbrevConfig;

exports.pool = index$2;

exports.updateManager = updateManager;

exports.utils = utils$1;

exports.withAnnouncer = withAnnouncer;

exports.withClassCache = index$1;

exports.withEditItems = index;

exports.withExtensions = withExtensions;

exports.withHandleKey = withHandleKey;

exports.withLayout = withLayout;

exports.withMarqueeSync = withMarqueeSync;

exports.withSelections = withSelections;

exports.withTags = withTags;

exports.withThemeStyles = withThemeStyles;

exports.withUpdates = withUpdates;
//# sourceMappingURL=lightning-ui-components.min.cjs.map
