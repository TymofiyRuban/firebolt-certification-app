import lng from '@lightningjs/core';

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare namespace Base {
  export interface TemplateSpec extends lng.Component.TemplateSpec {
    /**
     * string to be read by `withAnnouncer`
     */
    announce?: string;

    /**
     * when true, it places the child component in center of the parent
     */
    centerInParent: boolean;

    /**
     * a promise that is resolved at the end of the component's `_construct` lifecycle method
     * By default this is a resolved promise. Components can use _resetLoadedPromise if they require the functionality
     */
    loaded?: Promise<void>;

    /**
     * when true, plinko will use the previous item to determine the horizontal index of the next focused item
     */
    skipPlinko: boolean;
  }
}

declare class Base<
  TemplateSpec extends Base.TemplateSpec = Base.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends lng.Component<TemplateSpec, TypeConfig> {
  /**
   * string to be read by `withAnnouncer`
   */
  announce?: string;

  /**
   * when true, it places the child component in center of the parent
   */
  centerInParent: boolean;

  /**
   * a promise that is resolved at the end of the component's `_construct` lifecycle method
   * By default this is a resolved promise. Components can use _resetLoadedPromise if they require the functionality
   */
  loaded?: Promise<void>;

  /**
   * when true, plinko will use the previous item to determine the horizontal index of the next focused item
   */
  skipPlinko: boolean;

  /**
   * used by `applySmooth` to track if a component should have values transitioned in, or patched without an animation
   */
  get shouldSmooth(): boolean;

  /**
   * conditionally transitions in values based on the state of `shouldSmooth`
   * if `true`, values will be applied using the [lng.Element.smooth](@link https://github.com/rdkcentral/Lightning/blob/8378d0e69752f476abedecc85568a27dbb63cbb0/src/tree/Element.d.mts#L1823C4-L1823C4)
   * if `false`, values will be applied using [lng.Element.patch](@link https://github.com/rdkcentral/Lightning/blob/8378d0e69752f476abedecc85568a27dbb63cbb0/src/tree/Element.d.mts#L1746)
   */
  // TODO took a stab at these types, could probably make this type-safe
  applySmooth(
    // ref tag ref of target component
    ref: lng.Component<lng.Component.TemplateSpecLoose>,

    // patch object of properties to patch to target
    patch: lng.Element.PatchTemplate,

    // smooth object of properties to smooth to target
    smooth: lng.Element.PatchTemplate
  );

  /**
   * returns the layout.focusScale property of the current theme
   */
  getFocusScale(): number;

  /**
   * returns default scale value, 1
   */
  getUnfocusScale(): number;

  /**
   * returns true if this component is fully within the stage and boundsMargin
   */
  isFullyOnScreen(offsets: { offsetX: number; offsetY: number }): boolean;

  // TODO: for future reference these accessors should technically be public
  /**
   * check if the component is disabled
   */
  get _isDisabledMode(): boolean;

  /**
   * check if the component is in focus
   */
  get _isFocusedMode(): boolean;

  /**
   * check if the component is unfocused
   */
  get _isUnfocusedMode(): boolean;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

type Color = number;

// a way that allows users to define all or however many style properties they'd like for a component
type StylePartial<T> = {
  // This is a mapped type (https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
  // It's a way of iterating over every key in the object T. The variable for the key is `P`
  // The `?` before the `:` makes every key P of the object T optional
  [P in keyof T]?: T[P] extends (infer U)[] // The first conditional checks if the type of the value (aka T[P]) is an array of any type U. If it's true then U is the type contained in the array.
    ? // Here we just spit back the array intact. We're saying to not apply StylePartial to items in arrays.
      // We do this before checking if T[P] is an object, because all arrays are objects but not all objects are arrays.
      U[]
    : // If it's not an array, then let's ask if T[P] is an object. If it is then, let's recursively apply StylePartial on it.
    // Likewise recursively apply StylePartial on objects that are optional from the beginning
    T[P] extends object | undefined
    ? StylePartial<T[P]>
    : // If it is NOT an object, then just spit back the original value type.
      T[P];
};

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type AspectRatio = '16x9' | '3x4' | '4x3' | '2x1' | '1x1';

type ArtworkStyle = {
  animationBlurEntrance: lng.types.TransitionSettings.Literal;
  animationBlurExit: lng.types.TransitionSettings.Literal;
  animationComponentEntrance: lng.types.TransitionSettings.Literal;
  animationGradientEntrance: lng.types.TransitionSettings.Literal;
  animationGradientExit: lng.types.TransitionSettings.Literal;
  animationImageScaleEntrance: lng.types.TransitionSettings.Literal;
  animationImageScaleExit: lng.types.TransitionSettings.Literal;
  blur: number;
  centerImageRadius: number;
  fallbackSrc: string;
  fillColor: Color;
  gradientColor: Color;
  imageScale: number;
  imageScalePivotX: number;
  imageScalePivotY: number;
  padding: number;
  radius: lng.Tools.CornerRadius;
  zIndexSet: {
    image: number;
    blur: number;
    centerImage: number;
    fill: number;
    gradient: number;
    foreground: number;
  };
};

declare namespace Artwork {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * When true, a blur will be applied to the image this will default to true if circleImage is true
     */
    blur?: boolean;
    /**
     * When true, a fill will be applied over the image this will default to false
     */
    fill?: boolean;
    /**
     * Sets the fallback image that will be shown in if the src request fails
     */
    fallbackSrc?: string;
    /**
     * @deprecated
     * Height value for the foregroundSrc if defined
     */
    foregroundH?: number;
    /**
     * Height value for the foregroundSrc if defined
     */
    foregroundHeight?: number;
    /**
     * Sets the fallback image that will be shown in if the src request fails
     */
    foregroundSrc?: string;
    /**
     * @deprecated
     * Width value for the foregroundSrc if defined
     */
    foregroundW?: number;
    /**
     * Width value for the foregroundSrc if defined
     */
    foregroundWidth?: number;
    /**
     * When true, a gradient will be added over all other elements
     */
    gradient?: boolean;
    /**
     * When true, scale will be applied over the image and this will default to false
     */
    shouldScale?: boolean;
    /**
     * Selection of image display modes
     */
    format?: 'default' | 'circle' | 'square' | 'contain';
    /**
     * Which image will be displayed
     */
    src: string; // Inherited from lng.Element
    /**
     * optional callback that can be used to generate custom strings to request an image. The callback will be passed an object containing the following parameters: aspectRatio, src, w, h. Be default aspect ratio will match the closest value from srcCallbackAspectRatios
     */
    srcCallback?: (obj: {
      closestAspectRatio: string;
      aspectRatio: string;
      src: string;
      w: number;
      h: number;
    }) => string;
    /**
     * srcCallback will receive an aspectRatio parameter when called, this array is used to find the closest value for your use case
     */
    srcCallbackAspectRatios?: AspectRatio[];
  }
  export interface TypeConfig extends lng.Component.TypeConfig {
    SignalMapType: SignalMap;
  }
  /**
   * emitted on initial loading of image
   */
  export type SignalMap = {
    resolveLoading(): void;
  };
}

declare class Artwork<
  TemplateSpec extends Artwork.TemplateSpec = Artwork.TemplateSpec,
  TypeConfig extends Artwork.TypeConfig = Artwork.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  // Properties
  /**
   * When true, a blur will be applied to the image this will default to true if circleImage is true
   */
  blur?: boolean;
  /**
   * When true, a fill will be applied over the image this will default to false
   */
  fill?: boolean;
  /**
   * Sets the fallback image that will be shown in if the src request fails
   */
  fallbackSrc?: string;
  /**
   * Height value for the foregroundSrc if defined
   */
  foregroundHeight?: number;
  /**
   * Image location for item that should be placed on top of the artwork above all other layers
   */
  foregroundSrc?: string;
  /**
   * Width value for the foregroundSrc if defined
   */
  foregroundWidth?: number;
  /**
   * When true, a gradient will be added over all other elements
   */
  gradient?: boolean;
  /**
   * When true, scale will be applied over the image and this will default to false
   */
  shouldScale?: boolean;
  /**
   * Selection of image display modes
   */
  format?: 'default' | 'circle' | 'square' | 'contain';
  /**
   * Which image will be displayed
   */
  src: string; // Inherited from lng.Element
  /**
   * optional callback that can be used to generate custom strings to request an image. The callback will be passed an object containing the following parameters: aspectRatio, src, w, h. Be default aspect ratio will match the closest value from srcCallbackAspectRatios
   */
  srcCallback?: (obj: {
    closestAspectRatio: string;
    aspectRatio: string;
    src: string;
    w: number;
    h: number;
  }) => string;

  /**
   * srcCallback will receive an aspectRatio parameter when called, this array is used to find the closest value for your use case
   */
  srcCallbackAspectRatios?: AspectRatio[];

  get style(): ArtworkStyle;
  set style(v: StylePartial<ArtworkStyle>);

  // tags
  get _Blur(): lng.Component;
  get _CenterImage(): lng.Component;
  get _FillColor(): lng.Component;
  get _ForegroundImage(): lng.Component;
  get _Gradient(): lng.Component;
  get _Image(): lng.Component;
  get _Item(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type BadgeStyle = {
  backgroundColor: Color;
  contentSpacing: number;
  iconColor: Color;
  offsetY: number;
  paddingX: number;
  paddingY: number;
  radius: lng.Tools.CornerRadius;
  strokeColor: Color;
  strokeWidth: number;
  textStyle: lng.textures.TextTexture.Settings;
};

declare namespace Badge {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * path to image or inline SVG XML
     */
    icon?: string;

    /**
     * width of icon
     */
    iconWidth?: number;

    /**
     * height of icon
     */
    iconHeight?: number;

    /**
     * side of the text where icon will appear on (`left` or `right`)
     */
    iconAlign?: 'left' | 'right';

    /**
     * Badge text
     */
    title?: string;
  }

  export interface TypeConfig extends lng.Component.TypeConfig {
    SignalMapType: SignalMap;
  }
  /**
   * emitted when the Badge component finishes loading its content and adjusts the background to fit the text input size.
   */
  export type SignalMap = {
    loadedBadge(): void;
  };
}

declare class Badge<
  TemplateSpec extends Badge.TemplateSpec = Badge.TemplateSpec,
  TypeConfig extends Badge.TypeConfig = Badge.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * path to image or inline SVG XML
   */
  icon?: string;

  /**
   * width of icon
   */
  iconWidth?: number;

  /**
   * height of icon
   */
  iconHeight?: number;

  /**
   * side of the text where icon will appear on (`left` or `right`)
   */
  iconAlign?: 'left' | 'right';

  /**
   * Badge text
   */
  title?: string;

  get style(): BadgeStyle;
  set style(v: StylePartial<BadgeStyle>);

  // tags
  get _Background(): lng.Component;
  get _Text(): lng.Component;
  get _Icon(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type SurfaceStyle = {
  animation: lng.types.TransitionSettings;
  backgroundColor: Color;
  radius: lng.Tools.CornerRadius;
  scale: number;
};

declare namespace Surface {
  export interface TemplateSpec extends Base.TemplateSpec {
    // TODO we may actually not want to include this here
    Background: typeof lng.Component<lng.Component.TemplateSpecLoose>; // TemplateSpecLoose allows us to patch in any arbitrary lng.Component
  }
}

declare class Surface<
  TemplateSpec extends Surface.TemplateSpec = Surface.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * alias for this.h
   */
  get innerH(): number;

  /**
   * alias for this.w
   */
  get innerW(): number;

  get style(): SurfaceStyle;
  set style(v: StylePartial<SurfaceStyle>);

  // tags
  get _Background(): lng.Component;
}

type TextBoxStyle = {
  offsetY: number;
  offsetX: number;
  textStyle: lng.textures.TextTexture.Settings | string;
};

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
 // text in Button is all using our own version of TextBox

type ButtonStyle = SurfaceStyle & {
  justify: 'center' | 'left' | 'right';
  minWidth: number;
  paddingX: number;
  paddingXNoTitle: number;
  paddingY: number;
  /** @deprecated */
  titlePadding: number;
  contentSpacing: number;
  textStyle: TextBoxStyle;
  contentColor: Color;
};

declare namespace Button {
  export interface TemplateSpec extends Surface.TemplateSpec {
    Content: typeof lng.Component<lng.Component.TemplateSpecLoose>;
    /**
     * forces Button to have a statically set width
     * when true, `w` overrides dynamically calculated width
     */
    fixed?: boolean;

    /**
     * alignment of the button's content
     */
    justify?: 'center' | 'left' | 'right';

    /**
     * Lightning component(s) to be placed to the left of the title
     */
    prefix?:
      | typeof lng.Component<lng.Component.TemplateSpecLoose>
      | Array<typeof lng.Component<lng.Component.TemplateSpecLoose>>;

    /**
     * Lightning component(s )to be placed to the right of the title
     */
    suffix?:
      | typeof lng.Component<lng.Component.TemplateSpecLoose>
      | Array<typeof lng.Component<lng.Component.TemplateSpecLoose>>;

    /**
     * Button text
     */
    title?: string;
  }
}

declare class Button<
  TemplateSpec extends Button.TemplateSpec = Button.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Surface<TemplateSpec, TypeConfig> {
  /**
   * forces Button to have a statically set width
   * when true, `w` overrides dynamically calculated width
   */
  fixed?: boolean;

  /**
   * alignment of the button's content
   */
  justify?: 'center' | 'left' | 'right';

  /**
   * Lightning component(s) to be placed to the left of the title
   */
  prefix?:
    | typeof lng.Component<lng.Component.TemplateSpecLoose>
    | Array<typeof lng.Component<lng.Component.TemplateSpecLoose>>;

  /**
   * Lightning component(s )to be placed to the right of the title
   */
  suffix?:
    | typeof lng.Component<lng.Component.TemplateSpecLoose>
    | Array<typeof lng.Component<lng.Component.TemplateSpecLoose>>;

  /**
   * Button text
   */
  title?: string;

  get style(): ButtonStyle;
  set style(v: StylePartial<ButtonStyle>);

  // tags
  get _Prefix(): lng.Component;
  get _Suffix(): lng.Component;
  get _TextWrapper(): lng.Component;
  get _Title(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare class ButtonSmall<
  TemplateSpec extends Button.TemplateSpec = Button.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Button<TemplateSpec, TypeConfig> {}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type MarqueeStyle = {
  /** @deprecated */
  fadeW: number;
  fadeWidth: number;
  offset: number;
  shouldSmooth: boolean;
  textStyle: TextBoxStyle;
};

declare namespace Marquee {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * Automatically start scrolling the content on initiation
     */
    autoStart?: boolean;

    /**
     * It will center the entire texture if the width of the content is less than the container
     */
    centerAlign?: boolean;

    /**
     * Texture object for the marquee content
     */
    contentTexture?: object;

    /**
     * Color of the text
     */
    color: Color; //TODO: is this correct return type?

    /**
     * Delay in milliseconds before scrolling starts
     */
    delay?: number;

    /**
     * Overrides the length of the marquee loop. Used by withMarqueeSync to synchronize multiple marquee components
     */
    overrideLoopX?: number;

    /**
     * Number of times to repeat scrolling
     */
    repeat?: number;

    /**
     * Text content for the marquee title
     */
    title?: string;
  }
  export interface TypeConfig extends lng.Component.TypeConfig {
    SignalMapType: SignalMap;
  }
  /**
   * emitted during the initial loading process of content or images in the component
   */
  export type SignalMap = {
    marqueeContentLoaded(): void;
  };
}

declare class Marquee<
  TemplateSpec extends Marquee.TemplateSpec = Marquee.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * Automatically start scrolling the content on initiation
   */
  autoStart?: boolean;

  /**
   * It will center the entire texture if the width of the content is less than the container
   */
  centerAlign?: boolean;

  /**
   * Texture object for the marquee content
   */
  contentTexture?: object;

  /**
   * Color of the text
   */
  color: Color;

  /**
   * Delay in milliseconds before scrolling starts
   */
  delay?: number;

  /**
   * Overrides the length of the marquee loop. Used by withMarqueeSync to synchronize multiple marquee components
   */
  overrideLoopX?: number;

  /**
   * Number of times to repeat scrolling
   */
  repeat?: number;

  /**
   * Text content for the marquee title
   */
  title?: string;

  // Methods:

  /**
   * Start scrolling the content
   */
  startScrolling(): void;

  /**
   * Stop scrolling the content
   */
  stopScrolling(): void;

  // Accessors

  /**
   * Get the current title's text content
   */
  get textContent(): string;

  get style(): MarqueeStyle;
  set style(v: StylePartial<MarqueeStyle>);

  // tags
  get _ContentClipper(): lng.Component;
  get _ContentBox(): lng.Component;
  get _Content(): lng.Component;
  get _ContentLoopTexture(): lng.Component;
}

type ContentBase = {
  title?: string;
  announce?: string;
  style?: lng.textures.TextTexture.Settings | string;
};

type TextContent =
  | string
  | (ContentBase & ({ text: string } | { icon: string } | { badge: string }));

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type JustifyContent =
  | 'flex-start'
  | 'flex-end'
  | 'center'
  | 'space-between'
  | 'space-around'
  | 'space-evenly';

type FlexItem = {
  grow?: number;
  shrink?: number;
  alignSelf?:
    | 'auto'
    | 'normal'
    | 'self-start'
    | 'self-end'
    | 'flex-start'
    | 'center'
    | 'baseline'
    | 'stretch'
    | 'safe'
    | 'unsafe';
  order?: unknown;
  'flex-basis'?: unknown;
  minWidth?: number;
  minHeight?: number;
  maxWidth?: number;
  maxHeight?: number;
  margin?: number;
  marginLeft?: number;
  marginTop?: number;
  marginRight?: number;
  marginBottom?: number;
};

type InlineContentStyle = {
  textY: number;
  /** @deprecated */
  iconW: number;
  iconWidth: number;
  /** @deprecated */
  iconH: number;
  iconHeight: number;
  contentSpacing: number;
  marginBottom: number;
  textStyle: lng.textures.TextTexture.Settings;
  maxLines: number;
  justify: JustifyContent;
};

declare namespace InlineContent {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * an array of  data to render inline
     */
    content?: TextContent[];
    /**
     * object setting flexItem props on all content items
     */
    contentProperties?: FlexItem;
    /**
     * y value of all badges
     */
    badgeY?: number;
    /**
     * styling to update the Badge component
     */
    badgeProperties?: Partial<Badge>;
    /**
     * alignment of first line flexbox content
     */
    justify?: JustifyContent;
    /**
     * determines whether the containing flexbox should wrap the content onto the next line
     */
    contentWrap?: boolean;
    /**
     * set of nested objects containing [Lightning Text](https://rdkcentral.github.io/Lightning/docs/textures/text) properties which can be referenced in the [Content Element Properties](#content-element-properties) to apply styling to individual text elements
     */
    customStyleMappings?: Record<string, lng.textures.TextTexture.Settings>;
    /**
     * maximum number of lines to render before truncation
     */
    maxLines?: number;
    /**
     * suffix appended to last line of content if it will exceed the `maxLines`
     */
    maxLinesSuffix?: string;
  }
  export interface TypeConfig extends lng.Component.TypeConfig {
    SignalMapType: SignalMap;
  }
  export type SignalMap = {
    loadedInlineContent(): void;
  };
}
declare class InlineContent<
  TemplateSpec extends InlineContent.TemplateSpec = InlineContent.TemplateSpec,
  TypeConfig extends InlineContent.TypeConfig = InlineContent.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * list of data to render inline
   */
  content?: TextContent[];
  /**
   * object setting flexItem props on all content items
   */
  contentProperties?: FlexItem;
  /**
   * y value of all badges
   */
  badgeY?: number;
  /**
   * styling to update the Badge component
   */
  badgeProperties?: Partial<Badge>;
  /**
   * alignment of first line flexbox content
   */
  justify?: JustifyContent;
  /**
   * determines whether the containing flexbox should wrap the content onto the next line
   */
  contentWrap?: boolean;
  /**
   * set of nested objects containing [Lightning Text](https://lightningjs.io/api/lightning-core/interfaces/lightning.textures.texttexture.settings) properties which can be referenced in the [Content Element Properties](#content-element-properties) to apply styling to individual text elements
   */
  customStyleMappings?: Record<string, lng.textures.TextTexture.Settings>;
  /**
   * maximum number of lines to render before truncation
   */
  maxLines?: number;
  /**
   * suffix appended to last line of content if it will exceed the `maxLines`
   */
  maxLinesSuffix?: string;

  // accessor
  /**
   * method that returns the height the text
   */
  get textHeight(): number;

  get style(): InlineContentStyle;
  set style(v: StylePartial<InlineContentStyle>);
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare namespace TextBox {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * Text to be displayed in element
     * This could be a string or content InlineContent, a string or an array from InlineContent
     */
    content?: string | TextContent[];
    /**
     * If true, allows the width of the text to be set with `w`
     */
    fixed?: boolean;
    /**
     * If true, allows text to be scrollable
     */
    marquee?: boolean;
  }
  export interface TypeConfig extends lng.Component.TypeConfig {
    SignalMapType: SignalMap;
  }

  export type SignalMap = {
    /**
     * emits when w and/or height has changed
     */
    textBoxChanged(): void;
    /**
     * emits when Marquee content has been loaded
     */
    willMarque(): void;
  };
}
declare class TextBox<
  TemplateSpec extends TextBox.TemplateSpec = TextBox.TemplateSpec,
  TypeConfig extends TextBox.TypeConfig = TextBox.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  // Properties

  /**
   * Text to be displayed in element
   * Takes in a string or an Array from InlineContent
   */
  content?: string | TextContent[];
  /**
   * If true, allows the width of the text to be set with `w`
   */
  fixed?: boolean;
  /**
   * If true, allows text to be scrollable
   */
  marquee?: boolean;
  /**
   * If `true`, the component will not render as visible following the text texture loading. This allows manually controlling the alpha of the component.
   */
  hideOnLoad?: boolean;

  // Accessors

  /**
   * returns a string from content
   */
  get title(): string;
  /**
   * returns a number used to alter the length of the marquee loop
   */
  get marqueeOverrideLoopX(): number;
  /**
   * sets the number used to determine the length of the marquee loop
   */
  set marqueeOverrideLoopX(v: number);

  get style(): TextBoxStyle;
  set style(v: StylePartial<TextBoxStyle>);

  // Methods
  /**
   * A method that calls the private _toggleMarquee method to toggle text to scroll or not scroll
   */
  toggleMarquee(): void;

  // tags
  get _InlineContent(): InlineContent;
  get _Marquee(): Marquee;
  get _Text(): TextBox;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type CardStyle = SurfaceStyle & {
  backgroundColor: Color;
  paddingHorizontal: number;
  paddingVertical: number;
  radius: lng.Tools.CornerRadius;
  titleTextStyle: TextBoxStyle;
};
declare namespace Card {
  export interface TemplateSpec extends Surface.TemplateSpec {
    /**
     * headline of the content
     */
    title?: string | TextBox[];
  }
}

declare class Card<
  TemplateSpec extends Card.TemplateSpec = Card.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Surface<TemplateSpec, TypeConfig> {
  /**
   * headline of the content
   */
  title?: string | TextBox[];

  get style(): CardStyle;
  set style(v: StylePartial<CardStyle>);

  // tags
  get _Title(): TextBox;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type CardTitleStyle = CardStyle & {
  descriptionTextStyle: TextBoxStyle;
  detailsTextProperties: TextBoxStyle;
};

declare namespace CardTitle {
  export interface TemplateSpec extends Card.TemplateSpec {
    /**
     * text to be displayed in the description section
     */
    description?: string | TextBox[];
    /**
     * text to be displayed in the details section
     */
    details?: string | TextBox[];
  }
}

declare class CardTitle<
  TemplateSpec extends CardTitle.TemplateSpec = CardTitle.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Card<TemplateSpec, TypeConfig> {
  /**
   * text to be displayed in the description section
   */
  description?: string | TextBox[];
  /**
   * text to be displayed in the details section
   */
  details?: string | TextBox[];

  get style(): CardTitleStyle;
  set style(v: StylePartial<CardTitleStyle>);

  // tags
  get _Description(): TextBox;
  get _Details(): TextBox;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */



type CardRadioStyle = CardTitleStyle & {
  descriptionTextStyle: TextBoxStyle;
  subtitleTextStyle: TextBoxStyle;
};

declare namespace CardRadio {
  export interface TemplateSpec extends CardTitle.TemplateSpec {
    /**
     * Object containing all properties supported in the Radio Component
     * TODO: See if the types can be updated when Radio has been updated
     */
    radio?: Record<string, unknown>;
    /**
     * text to be displayed in the subtitle section of the card
     */
    subtitle?: string | TextBox[];
  }
}
declare class CardRadio<
  TemplateSpec extends CardRadio.TemplateSpec = CardRadio.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends CardTitle<TemplateSpec, TypeConfig> {
  /**
   * Object containing all properties supported in the Radio Component
   */
  radio?: Record<string, unknown>;
  /**
   * text to be displayed in the subtitle section of the card
   */
  subtitle?: string | TextBox[];

  get style(): CardRadioStyle;
  set style(v: StylePartial<CardRadioStyle>);

  //tags
  get _Subtitle(): TextBox;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type IconStyle = {
  color: Color;
};

declare namespace Icon {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * icon color (can only be applied on png icons)
     */
    color: Color;
    /**
     * when `true`, icon width and height will not dynamically resize to the final texture's `finalW` and `finalH` properties
     */
    fixed?: boolean;

    /**
     * path to image or inline SVG XML
     */
    icon?: string;
  }
  export interface TypeConfig extends lng.Component.TypeConfig {
    SignalMapType: SignalMap;
  }

  /**
   * emitted when an item in the Icon component changes.
   */
  export type SignalMap = {
    itemChanged(icon: Icon): void;
  };
}

declare class Icon<
  TemplateSpec extends Icon.TemplateSpec = Icon.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * icon color (can only be applied on png icons)
   */
  color: Color;

  /**
   * when `true`, icon width and height will not dynamically resize to the final texture's `finalW` and `finalH` properties
   */
  fixed?: boolean;

  /**
   * path to image or inline SVG XML
   */
  icon?: string;

  get style(): IconStyle;
  set style(v: StylePartial<IconStyle>);
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type CardSectionStyle = CardStyle & {
  iconHeight: number;
  iconWidth: number;
  titleTextStyle: TextBoxStyle;
};

declare namespace CardSection {
  export interface TemplateSpec extends Card.TemplateSpec {
    /**
     * height of the icon on the right
     */
    iconHeight?: number;
    /**
     * icon source
     */
    iconSrc?: string;
    /**
     * width of the icon on the right
     */
    iconWidth?: number;
  }
}

declare class CardSection<
  TemplateSpec extends CardSection.TemplateSpec = CardSection.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Card<TemplateSpec, TypeConfig> {
  // Properties
  /**
   * height of the icon on the right
   */
  iconHeight?: number;
  /**
   * icon source
   */
  iconSrc?: string;
  /**
   * width of the icon on the right
   */
  iconWidth?: number;

  get style(): CardSectionStyle;
  set style(v: StylePartial<CardSectionStyle>);

  // tags
  get _Icon(): Icon;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type MetadataBaseStyle = {
  descriptionTextStyle: TextBoxStyle;
  fadeWidth: number;
  logoWidth: number;
  logoHeight: number;
  logoPadding: number;
  detailsTextStyle: TextBoxStyle;
  titleTextStyle: TextBoxStyle;
};

declare namespace MetadataBase {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * text of subtitle content
     */
    subtitle?: string;
    /**
     * third line or description of the content
     */
    description?: string;
    /**
     * relevant content data in the middle
     */
    details?: string;
    /**
     * logo to display at bottom of component
     */
    logo?: string;
    /**
     * height of logo
     */
    logoHeight?: number;
    /**
     * width of logo
     */
    logoWidth?: number;
    /**
     * which side to place logo (`right` or `left`)
     */
    logoPosition?: string;
    /**
     * title of logo to use for announcer
     */
    logoTitle?: string;
    /**
     * sets the marquee for Title and Description to the same value so they sync
     */
    marquee?: boolean;
    /**
     * first line or headline of the content
     */
    title?: string;
  }
  export interface TypeConfig extends lng.Component.TypeConfig {
    SignalMapType: SignalMap;
  }
  /**
   * emits when an update to the height of logo and/or text happens
   */
  export type SignalMap = {
    updateMetadataHeight(): void;
  };
}

declare class MetadataBase<
  TemplateSpec extends MetadataBase.TemplateSpec = MetadataBase.TemplateSpec,
  TypeConfig extends MetadataBase.TypeConfig = MetadataBase.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  // Properties
  /**
   * text of subtitle content
   */
  subtitle?: string;
  /**
   * third line or description of the content
   */
  description?: string;
  /**
   * relevant content data in the middle
   */
  details?: string;
  /**
   * logo to display at bottom of component
   */
  logo?: string;
  /**
   * height of logo
   */
  logoHeight?: number;
  /**
   * width of logo
   */
  logoWidth?: number;
  /**
   * which side to place logo (`right` or `left`)
   */
  logoPosition?: string;
  /**
   * title of logo to use for announcer
   */
  logoTitle?: string;
  /**
   * TODO: confirm type and get a description
   */
  marquee?: boolean;
  /**
   * first line or headline of the content
   */
  title?: string;

  get style(): MetadataBaseStyle;
  set style(v: StylePartial<MetadataBaseStyle>);

  // Tags
  get _Title(): TextBox;
  get _Subtitle(): TextBox;
  get _DetailsWrapper(): TextBox;
  get _Details(): TextBox;
  get _Description(): TextBox;
  get _Logo(): Icon;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type ProgressBarStyle = {
  animation: object;
  barColor: Color;
  progressColor: Color;
  radius: lng.Tools.CornerRadius;
};

declare namespace ProgressBar {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * Percentage of current progress in a decimal format from 0 to 1
     */
    progress?: number;
  }
}

declare class ProgressBar<
  TemplateSpec extends ProgressBar.TemplateSpec = ProgressBar.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * Percentage of current progress in a decimal format from 0 to 1
   */
  progress?: number;
  get style(): ProgressBarStyle;
  set style(v: StylePartial<ProgressBarStyle>);

  // tags
  get _Bar(): lng.Component;
  get _Progress(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type CheckboxStyle = {
  alpha: number;
  backgroundColor: Color;
  backgroundColorChecked: Color;
  checkColor: Color;
  /** @deprecated */
  checkH: number;
  /** @deprecated */
  checkHeight: number;
  iconHeight: number;
  /** @deprecated */
  checkW: number;
  /** @deprecated */
  checkWidth: number;
  iconWidth: number;
  /** @deprecated */
  checkSrc: string;
  icon: string;
  radius: lng.Tools.CornerRadius;
  strokeColor: Color;
  strokeWidth: number;
};

declare namespace Checkbox {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * Indicates whether the checkbox is checked or unchecked.
     * Setting this to `true` will check the checkbox, and setting it to `false` will uncheck it.
     */
    checked?: boolean;
  }
}

declare class Checkbox<
  TemplateSpec extends Checkbox.TemplateSpec = Checkbox.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * Indicates whether the checkbox is checked or unchecked.
   * Setting this to `true` will check the checkbox, and setting it to `false` will uncheck it.
   */
  checked?: boolean;

  // Method
  /**
   * Toggles the checkbox state and updates the UI.
   */
  toggle(): void;

  get style(): CheckboxStyle;
  set style(v: StylePartial<CheckboxStyle>);

  // tags
  get _Check(): Icon;
  get _Body(): lng.Component;
  get _Stroke(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type LabelStyle = {
  backgroundColor: Color;
  paddingX: number;
  paddingY: number;
  radius: lng.Tools.CornerRadius;
  textStyle: lng.textures.TextTexture.Settings;
};

declare namespace Label {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * text to display in label
     */
    title: string;
  }
  export interface TypeConfig extends lng.Component.TypeConfig {
    SignalMapType: SignalMap;
  }
  /**
   * emitted when an update to the Background has been patched
   */
  export type SignalMap = {
    updateBackground(): void;
  };
}
declare class Label<
  TemplateSpec extends Label.TemplateSpec = Label.TemplateSpec,
  TypeConfig extends Label.TypeConfig = Label.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * text to display in label
   */
  title: string;
  get style(): LabelStyle;
  set style(v: StylePartial<LabelStyle>);

  // tags
  get _Background(): lng.Component;
  get _Text(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type TileStyle = SurfaceStyle & {
  animationEntrance: lng.types.TransitionSettings.Literal;
  animationExit: lng.types.TransitionSettings.Literal;
  /** @deprecated */
  iconWidth: number;
  logoWidth: number;
  /** @deprecated */
  iconHeight: number;
  logoHeight: number;
  metadataLocation: 'standard' | 'inset';
  paddingX: number;
  paddingY: number;
  paddingYProgress: number;
  paddingYBetweenContent: number;
  radius: lng.Tools.CornerRadius | string;
};
declare namespace Tile {
  export interface TemplateSpec extends Surface.TemplateSpec {
    /**
     * Object containing all properties supported in the [Artwork component](?path=/docs/components-artwork--artwork)
     */
    artwork: lng.Element.PatchTemplate<Artwork.TemplateSpec>;
    /**
     * Object containing all properties supported in the [Badge component](?path=/docs/components-badge--text)
     */
    badge?: lng.Element.PatchTemplate<Badge.TemplateSpec>;

    /**
     * Object containing all properties supported in the [Checkbox component](?path=/docs/components-checkbox--checkbox)
     */
    checkbox?: lng.Element.PatchTemplate<Checkbox.TemplateSpec>;
    /**
     * If true, changes format of itemLayout to circle
     */
    circle?: boolean;
    /**
     * Object containing all properties supported in the [Label component](?path=/docs/components-label--label)
     */
    label?: lng.Element.PatchTemplate<Label.TemplateSpec>;
    /**
     * icon source
     */
    logo?: string;
    /**
     * Controls where there metadata is displayed in relation to the Tile. Available values are 'standard' and 'inset'
     */
    metadataLocation?: 'standard' | 'inset';
    /**
     * Object containing all properties supported in the [MetadataTile component](?path=/docs/components-metadatatile--metadata-tile)<br /> Can use a different Metadata component by passing in a 'type' and then that component's properties
     */
    metadata?: lng.Element.PatchTemplate<MetadataBase.TemplateSpec>;
    /**
     * Metadata will be shown at all times if set to true, otherwise it will only show when the Tile has focusMetadata will be shown at all times if set to true, otherwise it will only show when the Tile has focus
     */
    persistentMetadata?: boolean;
    /**
     * Object containing all properties supported in the [ProgressBar component](?path=/docs/components-progressbar--progress-bar)
     */
    progressBar?: lng.Element.PatchTemplate<ProgressBar.TemplateSpec>;
  }
}
declare class Tile<
  TemplateSpec extends Tile.TemplateSpec = Tile.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Surface<TemplateSpec, TypeConfig> {
  // Properties
  /**
   * Object containing all properties supported in the [Artwork component](?path=/docs/components-artwork--artwork)
   */
  artwork: lng.Element.PatchTemplate<Artwork.TemplateSpec>;
  /**
   * Object containing all properties supported in the [Badge component](?path=/docs/components-badge--text)
   */
  badge?: lng.Element.PatchTemplate<Badge.TemplateSpec>;
  /**
   * Object containing all properties supported in the [Checkbox component](?path=/docs/components-checkbox--checkbox)
   */
  checkbox?: lng.Element.PatchTemplate<Checkbox.TemplateSpec>;
  /**
   * If true, changes format of itemLayout to circle
   */
  circle?: boolean;
  /**
   * Object containing all properties supported in the [Label component](?path=/docs/components-label--label)
   */
  label?: lng.Element.PatchTemplate<Label.TemplateSpec>;
  /**
   * Controls where there metadata is displayed in relation to the Tile. Available values are 'standard' and 'inset'
   */
  metadataLocation?: 'standard' | 'inset';
  /**
   * Object containing all properties supported in the [MetadataTile component](?path=/docs/components-metadatatile--metadata-tile)<br /> Can use a different Metadata component by passing in a 'type' and then that component's properties
   */
  metadata?: lng.Element.PatchTemplate<MetadataBase.TemplateSpec>;
  /**
   * Metadata will be shown at all times if set to true, otherwise it will only show when the Tile has focusMetadata will be shown at all times if set to true, otherwise it will only show when the Tile has focus
   */
  persistentMetadata?: boolean;
  /**
   * Object containing all properties supported in the [ProgressBar component](?path=/docs/components-progressbar--progress-bar)
   */
  progressBar?: lng.Element.PatchTemplate<ProgressBar.TemplateSpec>;

  get innerH(): number;
  get style(): TileStyle;
  set style(v: StylePartial<TileStyle>);

  // tags
  get _Artwork(): Artwork;
  get _Content(): TextBox;
  get _Tile(): TextBox;
  get _Badge(): Badge;
  get _Checkbox(): Checkbox;
  get _Icon(): Icon;
  get _Metadata(): MetadataBase;
  get _ProgressBar(): ProgressBar;
  get _Label(): Label;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type ImageSize = {
  w: number;
  h: number;
};

type CardContentStyle = CardStyle & {
  backgroundColor: Color;
  /** @deprecated */
  expandedW: number;
  expandedWidth: number;
  /** @deprecated */
  expandedH: number;
  expandedHeight: number;
  imageSize: ImageSize;
  metadata: TextBoxStyle;
};

declare namespace CardContent {
  export interface TemplateSpec extends Card.TemplateSpec {
    /**
     * when collapseToMetadata is true and shouldCollapse is enabled, the image collapses to show the metadata
     */
    collapseToMetadata?: boolean;
    /**
     * object containing all properties supported in the MetadataCardContent component
     */
    metadata?: lng.Element.PatchTemplate<MetadataBase.TemplateSpec>;
    /**
     * specifies whether the card layout should be oriented horizontally or vertically
     */
    orientation?: ['horizontal', 'vertical'];
    /**
     * will collapse the Card when the Card is not focused
     */
    shouldCollapse?: boolean;
    /**
     *  path to artwork image
     */
    src: string;
    /**
     * object containing all properties supported in the Tile component
     */
    tile?: lng.Element.PatchTemplate<Tile.TemplateSpec>;
  }
}
declare class CardContent<
  TemplateSpec extends CardContent.TemplateSpec = CardContent.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Card<TemplateSpec, TypeConfig> {
  /**
   * when collapseToMetadata is true and shouldCollapse is enabled, the image collapses to show the metadata
   */
  collapseToMetadata?: boolean;
  /**
   * object containing all properties supported in the MetadataCardContent component
   */
  metadata?: lng.Element.PatchTemplate<MetadataBase.TemplateSpec>;
  /**
   * specifies whether the card layout should be oriented horizontally or vertically
   */
  orientation?: ['horizontal', 'vertical'];
  /**
   * will collapse the Card when the Card is not focused
   */
  shouldCollapse?: boolean;
  /**
   *  path to artwork image
   */
  src: string;
  /**
   * object containing all properties supported in the Tile component
   */
  tile?: lng.Element.PatchTemplate<Tile.TemplateSpec>;

  get style(): CardContentStyle;
  set style(v: StylePartial<CardContentStyle>);

  // tags
  get _Metadata(): MetadataBase;
  get _Tile(): TextBox;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare class CardContentHorizontal<
  TemplateSpec extends CardContent.TemplateSpec = CardContent.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends CardContent<TemplateSpec, TypeConfig> {}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare class CardContentHorizontalLarge<
  TemplateSpec extends CardContent.TemplateSpec = CardContent.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends CardContentHorizontal<TemplateSpec, TypeConfig> {}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare class CardContentVertical<
  TemplateSpec extends CardContent.TemplateSpec = CardContent.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends CardContent<TemplateSpec, TypeConfig> {}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare class CardContentVerticalSmall<
  TemplateSpec extends CardContent.TemplateSpec = CardContent.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends CardContentVertical<TemplateSpec, TypeConfig> {}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type NavigationDirectionType = 'none' | 'column' | 'row';

type FocusItemsType = Array<
  lng.Component.NewPatchTemplate<lng.Component.Constructor> | lng.Component
>;

declare namespace FocusManager {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * the navigation direction
     */
    direction?: NavigationDirectionType;

    /**
     * child element or elements of the FocusManager
     */
    items: Array<
      | lng.Component.NewPatchTemplate<lng.Component.Constructor>
      | typeof lng.Component
    >;

    /**
     * index of currently selected item
     * updating value emits the `selectedChange` signal
     */
    selectedIndex?: number;

    /**
     * enables wrapping behavior, so `selectNext` selects the first item if the current item is the last on the list and vice versa
     */
    wrapSelected?: boolean;

    /**
     * x (horizontal) position value of the Row/Column (items array)
     */
    itemPosX?: number;

    /**
     * y (vertical) position value of the Row/Column (items array)
     */
    itemPosY?: number;
  }
  export interface TypeConfig extends lng.Component.TypeConfig {
    SignalMapType: SignalMap;
  }

  export type SignalMap = {
    /**
     * emitted whenever the currently selected item changes
     * @param selected the currently selected component
     * @param prevSelected the previous selected component
     */
    selectedChange(selected: lng.Component, prevSelected: lng.Component): void;
  };
}

declare class FocusManager<
  TemplateSpec extends FocusManager.TemplateSpec = FocusManager.TemplateSpec,
  TypeConfig extends FocusManager.TypeConfig = FocusManager.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  // Properties

  /**
   * the navigation direction
   */
  direction?: NavigationDirectionType;

  /**
   * child element or elements of the FocusManager
   */
  items: FocusItemsType;

  /**
   * index of currently selected item
   * updating value emits the `selectedChange` signal
   */
  selectedIndex: number;

  /**
   * enables wrapping behavior, so `selectNext` selects the first item if the current item is the last on the list and vice versa
   */
  wrapSelected: boolean;

  /**
   * x (horizontal) position value of the Row/Column (items array)
   */
  itemPosX?: number;

  /**
   * y (vertical) position value of the Row/Column (items array)
   */
  itemPosY?: number;

  // Accessors

  get Items(): lng.Element;

  /**
   * returns the currently selected component
   */
  get selected(): lng.Component;

  /**
   * returns a list of items that are currently fully and partially on screen
   */
  get onScreenItems(): Array<lng.Component>;

  /**
   * returns an array containing the children of the FocusManager that are fully within the visible bounds of the FocusManager
   */
  get fullyOnScreenItems(): Array<lng.Component>;

  // Methods

  /**
   * adds the provided Rows to the end of the FocusManager children
   * @param items array of Components or Component patch objects
   */
  appendItems(items: FocusItemsType): void;

  /**
   * adds the provided Rows to the end of the FocusManager children at the provided index
   * @param items array of Components or Component patch objects
   * @param idx index to insert `items` at
   */
  appendItemsAt(items: FocusItemsType, idx: number): void;

  /**
   * adds the provided Rows to the beginning of the FocusManager children
   * @param items array of Components or Component patch objects
   */
  prependItems(items: FocusItemsType): void;

  /**
   * removes Item from FocusManager children at the given index
   * @param index index of item to remove
   */
  removeItemAt(idx: number): void;

  /**
   * returns the transition value for `x` of FocusManager.Items
   */
  getTransitionXTargetValue(): string;

  /**
   * returns the transition value for `y` of FocusManager.Items
   */
  getTransitionYTargetValue(): string;

  /**
   * A no-op function that is called when `selectedIndex` is set. Can be overridden by classes that extend `FocusManager` for custom render behavior.
   */
  _render(): void;

  /**
   * Selects next item. If this.wrapSelected=true, will select the first element in the list if focus is currently on the last item.
   * emits the `selectedChange` signal
   * @param shouldSmoothOverride allows setting the shouldSmooth value before the select update
   */
  selectNext(shouldSmoothOverride?: boolean): void;

  /**
   * Selects previous item. If this.wrapSelected=true, will select the last element in the list if focus is currently on the first item.
   * emits the `selectedChange` signal
   */
  selectPrevious(): void;

  // tags
  get _Items(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type NavigationManagerStyle = {
  alwaysScroll: boolean;
  itemSpacing: number;
  itemTransition: lng.types.TransitionSettings;
  neverScroll: boolean;
  scrollIndex: number;
};

declare namespace NavigationManager {
  export interface TemplateSpec extends FocusManager.TemplateSpec {
    /**
     * Determines whether the component will stop scrolling as it nears the end to prevent white space.
     * If true, the component will scroll infinitely.
     */
    alwaysScroll?: boolean;

    /**
     * If true, the component will never scroll, unless `alwaysScroll` is set to true.
     * If false, the component will apply normal scrolling logic.
     */
    neverScroll?: boolean;

    /**
     * Item index at which scrolling begins, provided the sum of item widths is greater than the width of the Row component.
     */
    scrollIndex?: number;

    /**
     * Automatically sets the width of the row to be the same as the Items container inside (this will prevent scrolling).
     */
    autoResizeWidth?: boolean;

    /**
     * Automatically sets the height of the row to be the same as the Items container inside.
     */
    autoResizeHeight?: boolean;

    /**
     * Note: `lazyUpCount` and `lazyUpCountBuffer` work hand in hand.
     * If defined, `lazyUpCount` enables "lazy loading" of items where only an initial number of items are displayed when the Row/Column first renders until further navigation.
     * The initial number of items is calculated by `lazyUpCount` + `lazyLoadUpCountBuffer`.
     * The remaining items are stored as lazy items.
     * Each time `selectNext` is invoked (moving right in Row or down in a Column), an item (that was not initially displayed) will be added to the end until all lazy items are loaded.
     */
    lazyUpCount?: number;

    /**
     * By default `lazyUpCountBuffer` is 2.
     * Changing this value updates the initial number of items to display on first render of Row/Column.
     * Note: this behavior will only occur if `lazyUpCount` is defined.
     * ex: only providing `lazyUpCountBuffer: 1` will display all items since `lazyUpCount` is not set so the “lazy loading” behavior is not enabled.
     */
    lazyUpCountBuffer?: number;
  }
}

declare class NavigationManager<
  TemplateSpec extends NavigationManager.TemplateSpec = NavigationManager.TemplateSpec,
  TypeConfig extends FocusManager.TypeConfig = FocusManager.TypeConfig
> extends FocusManager<TemplateSpec, TypeConfig> {
  // Properties
  /**
   * Determines whether the component will stop scrolling as it nears the end to prevent white space.
   * If true, the component will scroll infinitely.
   */
  alwaysScroll?: boolean;

  /**
   * If true, the component will never scroll, unless alwaysScroll is set to true.
   * If false, the component will apply normal scrolling logic.
   */
  neverScroll?: boolean;

  /**
   * Item index at which scrolling begins, provided the sum of item widths is greater than the width of the Row component.
   */
  scrollIndex?: number;

  /**
   * Automatically sets the width of the row to be the same as the Items container inside (this will prevent scrolling).
   */
  autoResizeWidth?: boolean;

  /**
   * Automatically sets the height of the row to be the same as the Items container inside.
   */
  autoResizeHeight?: boolean;

  /**
   * Note: `lazyUpCount` and `lazyUpCountBuffer` work hand in hand.
   * If defined, `lazyUpCount` enables "lazy loading" of items where only an initial number of items are displayed when the Row/Column first renders until further navigation.
   * The initial number of items is calculated by `lazyUpCount` + `lazyLoadUpCountBuffer`.
   * The remaining items are stored as lazy items.
   * Each time `selectNext` is invoked (moving right in Row or down in a Column), an item (that was not initially displayed) will be added to the end until all lazy items are loaded.
   */
  lazyUpCount?: number;

  /**
   * By default `lazyUpCountBuffer` is 2.
   * Changing this value updates the initial number of items to display on first render of Row/Column.
   * Note: this behavior will only occur if `lazyUpCount` is defined.
   * ex: only providing `lazyUpCountBuffer: 1` will display all items since `lazyUpCount` is not set so the “lazy loading” behavior is not enabled.
   */
  lazyUpCountBuffer?: number;

  // Accessors
  get style(): NavigationManagerStyle;
  set style(v: StylePartial<NavigationManagerStyle>);

  // Methods
  /**
   * An event that, when triggered, calls a method that forces the component to update.
   */
  $itemChanged(): void;

  /**
   * Updates the position of a component along the main axis of the NavigationManager component.
   * For components where `direction` is `'row'`, it will update the `x` property on the passed in component(`item`) to the passed in value(`position`).
   * For components where `direction` is `'column'`, it will update the `y` property on the passed in component(`item`) to the passed in value(`position`).
   * @param item component whose property will be updated
   * @param position value to replace either the `x` or `y` property of item
   */
  updatePositionOnAxis(item: lng.Component, position: number): void;

  /**
   * Scrolls to the child at the supplied index at the rate of `duration` * (`this.selectedIndex` - `index`)
   * @param index index of item to scroll to
   * @param duration how long, in ms, it should take to scroll to the item at index
   */
  scrollTo(index: number, duration: number): void;

  /**
   * A method that is invoked upon any transitions to the component's axis property finishing (ex. 'x' for Row, 'y' for Column).
   * It is not set by default and can be overwritten.
   */
  transitionDone(): void;

  /**
   * Returns a boolean for whether or not the component should scroll left
   * based off if the component's `direction` property is `'row'`, the selected item's index is past the `scrollIndex`, and that content that is out of view can be scrolled to.
   */
  shouldScrollLeft(): boolean;

  /**
   * Returns a boolean for whether or not the component should scroll right
   * based off if the component's `direction` property is `'row'`, the selected item's index is past the `scrollIndex`, and that content that is out of view can be scrolled to.
   */
  shouldScrollRight(): boolean;

  /**
   * Returns a boolean for whether or not the component should scroll up
   * based off if the component's `direction` property is `'column'`, the selected item's index is past the `scrollIndex`, and that content that is out of view can be scrolled to.
   */
  shouldScrollUp(): boolean;

  /**
   * Returns a boolean for whether or not the component should scroll down
   * based off if the component's `direction` property is `'column'`, the selected item's index is past the `scrollIndex`, and that content that is out of view can be scrolled to.
   */
  shouldScrollDown(): boolean;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare namespace Column {
  export interface TemplateSpec extends NavigationManager.TemplateSpec {
    /**
     * When navigation between multiple Columns,
     * plinko functionality enables navigation to the item in the next Column that is closest to the index of the item in the previous Column.
     */
    plinko?: boolean;
  }
}

declare class Column<
  TemplateSpec extends Column.TemplateSpec = Column.TemplateSpec,
  TypeConfig extends FocusManager.TypeConfig = FocusManager.TypeConfig
> extends NavigationManager<TemplateSpec, TypeConfig> {
  // Properties
  /**
   * When navigation between multiple Columns,
   * plinko functionality enables navigation to the item in the next Column that is closest to the index of the item in the previous Column.
   */
  plinko?: boolean;

  // Methods
  /**
   * Returns the item right before the item that has skipPlinko or before prev if no item has skipPlinko
   * @param prev component existing right before the current component
   * @param next component existing right after the current component
   */
  checkSkipPlinko(prev: lng.Component, next: lng.Component): lng.Component;

  /**
   * A callback that can be overridden to do something with the items that are currently on screen.
   * This will be called on every new render.
   */
  onScreenEffect(): void;

  /**
   * Removes the passed in item from the items array and updates the selectedIndex, if necessary
   * @param item component to be removed
   */
  $removeItem(item: lng.Component): void;

  /**
   * An event that, when triggered, calls a method that forces the component to update.
   */
  $columnChanged(): void;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type LogoStyleObject$1 = {
  radius: lng.Tools.CornerRadius;
  h: number;
  w: number;
};

type ControlStyle = ButtonStyle & {
  iconStyle: Record<string, unknown>;
  logoStyle: LogoStyleObject$1;
  radius: lng.Tools.CornerRadius;
};

declare namespace Control {
  export interface TemplateSpec extends Button.TemplateSpec {
    /**
     *  URL for the icon asset
     */
    icon?: string;

    /**
     *  URL for the image asset
     */
    logo?: string;

    /**
     * flag that if `true`, hides the title when `Control` is in unfocused or disabled mode
     */
    shouldCollapse?: boolean;
  }
}

declare class Control<
  TemplateSpec extends Control.TemplateSpec = Control.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Button<TemplateSpec, TypeConfig> {
  /**
   *  URL for the icon asset
   */
  icon?: string;

  /**
   *  URL for the image asset
   */
  logo?: string;

  /**
   * flag that if `true`, hides the title when `Control` is in unfocused or disabled mode
   */
  shouldCollapse?: boolean;

  get style(): ControlStyle;
  set style(v: StylePartial<ControlStyle>);
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare class ControlSmall<
  TemplateSpec extends Control.TemplateSpec = Control.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Control<TemplateSpec, TypeConfig> {}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare namespace Row {
  export interface TemplateSpec extends NavigationManager.TemplateSpec {
    /**
     * If true, will only scroll the row if the item is off screen and `alwaysScroll` and `neverScroll` are both false.
     */
    lazyScroll?: boolean;

    /**
     * When `lazyScroll` is `true`,
     * this is the index of item in `items`, and items thereafter, at which lazy scrolling should occur
     * (alwaysScroll functionality will take place before this index)
     */
    startLazyScrollIndex?: number;

    /**
     * When `lazyScroll` is `true`,
     * this is the index of item in `items`, and items preceding, at which lazy scrolling should occur
     * (alwaysScroll functionality will take place after this index)
     */
    stopLazyScrollIndex?: number;
  }
}

declare class Row<
  TemplateSpec extends Row.TemplateSpec = Row.TemplateSpec,
  TypeConfig extends FocusManager.TypeConfig = FocusManager.TypeConfig
> extends NavigationManager<TemplateSpec, TypeConfig> {
  // Properties
  /**
   * If true, will only scroll the row if the item is off screen and `alwaysScroll` and `neverScroll` are both false.
   */
  lazyScroll?: boolean;

  /**
   * When `lazyScroll` is `true`,
   * this is the index of item in `items`, and items thereafter, at which lazy scrolling should occur
   * (alwaysScroll functionality will take place before this index)
   */
  startLazyScrollIndex?: number;

  /**
   * When `lazyScroll` is `true`,
   * this is the index of item in `items`, and items preceding, at which lazy scrolling should occur
   * (alwaysScroll functionality will take place after this index)
   */
  stopLazyScrollIndex?: number;

  // Methods
  /**
   * A callback that can be overridden to do something with the items that are currently on screen.
   * This will be called on every new render.
   */
  onScreenEffect(): void;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


// Why does `TitleRow` extend `Row` but use style props from `NavigationManager`?
/**
 * `Row` style props are the same as `NavigationManager` style props.
 * We are not re-mapping properties and defining a `RowStyle` in `Row` since `Row` inherits all of `NavigationManager` style props.
 * Hence `TitleRowStyle` uses `NavigationManagerStyle` rather than the previous `RowStyle`
 */

type TitleRowStyle = NavigationManagerStyle & {
  w: number;
  titleMarginLeft: number;
  titleTextStyle: TextBoxStyle;
  titleMarginBottom: number;
  /** @deprecated */
  rowMarginTop: number;
};

declare namespace TitleRow {
  export interface TemplateSpec extends Row.TemplateSpec {
    /**
     * Title text to be displayed above the `Row` items
     */
    title?: string;
  }
}

declare class TitleRow<
  TemplateSpec extends TitleRow.TemplateSpec = TitleRow.TemplateSpec,
  TypeConfig extends FocusManager.TypeConfig = FocusManager.TypeConfig
> extends Row<TemplateSpec, TypeConfig> {
  // Properties
  /**
   * Title text to be displayed above the `Row` items
   */
  title?: string;

  // Accessors
  get style(): TitleRowStyle;
  set style(v: StylePartial<TitleRowStyle>);

  // Tags
  get _Title(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type ControlRowItem = Array<
  lng.Component.NewPatchTemplate<typeof lng.Component> | lng.Component
>;

type ControlRowStyle = TitleRowStyle & {
  extraItemSpacing: number;
};

declare namespace ControlRow {
  export interface TemplateSpec extends TitleRow.TemplateSpec {
    /**
     * additional space to be added between controls and content items
     */
    extraItemSpacing?: number;
  }
}

declare class ControlRow<
  TemplateSpec extends ControlRow.TemplateSpec = ControlRow.TemplateSpec,
  TypeConfig extends FocusManager.TypeConfig = FocusManager.TypeConfig
> extends TitleRow<TemplateSpec, TypeConfig> {
  /**
   * additional space to be added between controls and content items
   */
  extraItemSpacing?: number;

  get style(): ControlRowStyle;
  set style(v: StylePartial<ControlRowStyle>);

  // Methods

  /**
   * Method to handle loading more items.
   */
  loadMoreItems(): void;

  /**
   * Adds items to the end of the row.
   * @param items An array of items to be added.
   */
  addContentItems(items: ControlRowItem[]): void;

  /**
   * Adds items at a specified index of the row.
   * @param items An array of items to be added.
   * @param index The index where the items should be added.
   */
  addContentItemsAt(items: ControlRowItem[], index: number): void;

  /**
   * Adds controls to the end of the left controls.
   * @param controls An array of controls to be added.
   */
  addLeftControls(items: ControlRowItem[]): void;

  /**
   * Adds controls at a specified index of the left controls.
   * @param controls An array of controls to be added.
   * @param index The index where the controls should be added.
   */
  addLeftControlsAt(items: ControlRowItem[], index: number): void;

  /**
   * Removes a left control at the specified index.
   * @param index The index of the left control to be removed.
   */
  removeLeftControlAt(index: number): void;

  /**
   * Adds controls to the end of the right controls.
   * @param controls An array of controls to be added.
   */
  addRightControls(items: ControlRowItem[]): void;

  /**
   * Adds controls at a specified index of the right controls.
   * @param controls An array of controls to be added.
   * @param index The index where the controls should be added.
   */
  addRightControlsAt(items: ControlRowItem[], index: number): void;

  /**
   * Removes a right control at the specified index.
   * @param index The index of the right control to be removed.
   */
  removeRightControlAt(index: number): void;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type GradientStyle = {
  gradientColor: Color;
  gradientTop: string;
  radius: lng.Tools.CornerRadius;
};

declare class Gradient<
  TemplateSpec extends Base.TemplateSpec = Base.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  get style(): GradientStyle;
  set style(v: StylePartial<GradientStyle>);
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type GridOverlayStyle = {
  propertyTextStyle: TextBoxStyle;
  valueTextStyle: TextBoxStyle;
};

declare namespace GridOverlay {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * when set to true, it displays the column span rectangles.
     */
    showColumns?: boolean;

    /**
     * when set to true, it displays the rulers for spacing between columns.
     */
    showGutters?: boolean;

    /**
     * when set to true, it displays the X and Y margin rulers.
     */
    showMargins?: boolean;

    /**
     * when set to true, it displays the X and Y "safe" zone rulers. This represents the area where content should not be rendered to avoid screen clipping on a device.
     */
    showSafe?: boolean;

    /**
     * when set to true, it displays the textbox containing the exact numbers associated with the screen, margin, safe, and gutter sizes.
     */
    showText?: boolean;
  }
  export interface TypeConfig extends lng.Component.TypeConfig {
    SignalMapType: SignalMap;
  }
  /**
   * This signal indicates that the spacer's appearance and layout have been adjusted based on its properties
   */
  export type SignalMap = {
    spacerLoaded(): void;
  };
}
declare class GridOverlay<
  TemplateSpec extends GridOverlay.TemplateSpec = GridOverlay.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * when set to true, it displays the column span rectangles.
   */
  showColumns?: boolean;

  /**
   * when set to true, it displays the rulers for spacing between columns.
   */
  showGutters?: boolean;

  /**
   * when set to true, it displays the X and Y margin rulers.
   */
  showMargins?: boolean;

  /**
   * when set to true, it displays the X and Y "safe" zone rulers. This represents the area where content should not be rendered to avoid screen clipping on a device.
   */
  showSafe?: boolean;

  /**
   * when set to true, it displays the textbox containing the exact numbers associated with the screen, margin, safe, and gutter sizes.
   */
  showText?: boolean;

  get style(): GridOverlayStyle;
  set style(v: StylePartial<GridOverlayStyle>);

  // tags
  get _Line(): lng.Component;
  get _TickLeft(): lng.Component;
  get _TickRight(): lng.Component;

  get _Columns(): lng.Component;

  get _Gutters(): lng.Component;
  get _GutterHorizontal(): lng.Component;

  get _Margins(): lng.Component;
  get _MarginHorizontal(): lng.Component;
  get _MarginLeft(): lng.Component;
  get _MarginRight(): lng.Component;
  get _MarginVertical(): lng.Component;
  get _MarginTop(): lng.Component;

  get _Safe(): lng.Component;
  get _SafeBottom(): lng.Component;
  get _SafeHorizontal(): lng.Component;
  get _SafeLeft(): lng.Component;
  get _SafeRight(): lng.Component;
  get _SafeTop(): lng.Component;
  get _SafeVertical(): lng.Component;

  get _TextColumnCount(): lng.Component;
  get _TextGutterY(): lng.Component;
  get _TextMarginX(): lng.Component;
  get _TextMarginY(): lng.Component;
  get _TextPanel(): lng.Component;
  get _TextSafe(): lng.Component;
  get _TextScreenH(): lng.Component;
  get _TextScreenW(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type InputStyle = ButtonStyle & {
  cursorStyle: object;
  eyebrowTextStyle: TextBoxStyle;
  helpTextStyle: TextBoxStyle;
  minWidth: number;
  paddingX: number;
  paddingY: number;
};

declare namespace Input {
  export interface TemplateSpec extends Button.TemplateSpec {
    /**
     * actualTitle is a proxy element for title which is used to store actual value typed when password is enabled
     */
    actualTitle?: string;

    /**
     * cursor indicates the current insertion or deletion position within the title
     */
    cursor: string;

    /**
     * eyebrow of input container.
     */
    eyebrow?: string;

    /**
     * help text for the input container.
     */
    helpText?: string;

    /**
     * when true, the listening property enables the input to accept changes from methods like clear, insert, and backspace. When false, these methods have no effect on the input
     */
    listening?: boolean;

    /**
     *  specifies the character used as a mask when the password is set to true.
     */
    mask?: string;

    /**
     * determines whether input should be masked
     */
    password?: boolean;

    /**
     * index of the current cursor positions
     */
    position?: number;
  }
}

declare class Input<
  TemplateSpec extends Input.TemplateSpec = Input.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Button<TemplateSpec, TypeConfig> {
  /**
   * actualTitle is a proxy element for title which is used to store actual value typed when password is enabled
   */
  actualTitle?: string;

  /**
   * cursor indicates the current insertion or deletion position within the title
   */
  cursor: string;

  /**
   * eyebrow of input container.
   */
  eyebrow?: string;

  /**
   * help text for the input container.
   */
  helpText?: string;

  /**
   * when true, the listening property enables the input to accept changes from methods like clear, insert, and backspace. When false, these methods have no effect on the input
   */
  listening?: boolean;

  /**
   *  specifies the character used as a mask when the password is set to true.
   */
  mask?: string;

  /**
   * determines whether input should be masked
   */
  password?: boolean;

  /**
   * index of the current cursor positions
   */
  position?: number;

  // methods

  /**
   * clears the content of the input container
   */
  clear(): void;

  /**
   * inserts the content at the current cursor position within the input container
   */
  insert(content: string): void;

  /**
   * Removes the character before the current cursor position
   */
  backspace(): void;

  /**
   *  moves the cursor one position to the left
   */
  moveLeft(): void;

  /**
   * moves the cursor one position to the right
   */
  moveRight(): void;

  get style(): InputStyle;
  set style(v: StylePartial<InputStyle>);

  // tags
  get _Eyebrow(): TextBox;
  get _HelpText(): TextBox;
  get _Cursor(): lng.Component;
  get _HiddenContent(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type SizeObject = {
  sm: number;
  md: number;
  lg: number;
  xl: number;
  xxl: number;
};

type KeyStyle = ButtonStyle & {
  h: number;
  sizes: SizeObject;
  /** @deprecated */
  iconW: number;
  iconWidth: number;
  /** @deprecated */
  iconH: number;
  iconHeight: number;
  baseWidth: number;
};

declare namespace Key {
  export interface TemplateSpec extends Button.TemplateSpec {
    /**
     * url for icon
     */
    icon?: string;

    /**
     * it allows custom handling of the "Enter" key press behavior in the Key component, overriding the default $onSoftKey and $toggleKeyboard events.
     */
    onEnter?: (key: string, toggle: boolean) => void;

    /**
     * width of the Key
     */
    size?: string;

    /**
     * If true, pressing the key will trigger the $toggleKeyboard event. If false, the key will trigger the $onSoftKey event.
     */
    toggle?: boolean;

    /**
     * The horizontal spacing between each key in a Keyboard. This value is factored into the width of the key so that it aligns with with the borders of other keys in a Keyboard.
     */
    keySpacing?: string;
    /**
     * Text to identify key instead of title
     */
    keyId?: string;
  }
}
declare class Key<
  TemplateSpec extends Key.TemplateSpec = Key.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Button<TemplateSpec, TypeConfig> {
  /**
   * url for icon
   */
  icon?: string;

  /**
   * it allows custom handling of the "Enter" key press behavior in the Key component, overriding the default $onSoftKey and $toggleKeyboard events.
   */
  onEnter?: (key: string, toggle: boolean) => void;

  /**
   * width of the Key
   */
  size?: string;

  /**
   * If true, pressing the key will trigger the $toggleKeyboard event. If false, the key will trigger the $onSoftKey event.
   */
  toggle?: boolean;

  /**
   * The horizontal spacing between each key in a Keyboard. This value is factored into the width of the key so that it aligns with with the borders of other keys in a Keyboard.
   */
  keySpacing?: string;

  /**
   * Text to identify key instead of title
   */
  keyId?: string;

  get style(): KeyStyle;
  set style(v: StylePartial<KeyStyle>);
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type inputStyleObject$1 = {
  radius: lng.Tools.CornerRadius;
};

type KeyboardStyle = {
  keySpacing: number;
  screenW: number;
  marginX: number;
  inputSpacing: number;
  inputStyle: inputStyleObject$1;
};

type KeyboardFormat = Record<
  string,
  Array<Array<string | Record<string, unknown>>>
>;

type KeyboardSelectedKeyPosition = {
  row: number;
  column: number;
};

declare namespace Keyboard {
  export interface TemplateSpec extends Base.TemplateSpec {
    // properties
    formats?: KeyboardFormat;
    centerKeyboard?: boolean;
    rowWrap?: boolean;
    centerKeys?: boolean;
    keyComponent?: lng.Component;
    defaultFormat?: string;
    columnCount?: number;
    rowCount?: number;
  }

  export interface TypeConfig extends lng.Component.TypeConfig {
    SignalMapType: SignalMap;
  }
  /**
   * emitted when the width of the Keyboard changes in response to a child component's dimensions changing (triggered by a signal called '$itemChanged')
   */
  export type SignalMap = {
    keyboardWidthChanged(): void;
  };
}

declare class Keyboard<
  TemplateSpec extends Keyboard.TemplateSpec = Keyboard.TemplateSpec,
  TypeConfig extends Keyboard.TypeConfig = Keyboard.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  // Properties
  /**
   * object containing arrays that represent different formats that the keyboard can be presented in. These arrays can contain strings or objects.
   */
  formats?: KeyboardFormat;

  /**
   * center the keyboard within it's set width (must set the w property of Keyboard)
   */
  centerKeyboard?: boolean;

  /**
   * wrap keyboard rows when navigating left and right
   */
  rowWrap?: boolean;

  /**
   * center the keys within it's set width (must set the w property of Keyboard)
   */
  centerKeys?: boolean;

  /**
   * component to display for each key
   */
  keyComponent?: lng.Component;

  /**
   * Default format of the keyboard to be shown. Should be a key of `formats`.
   */
  defaultFormat?: string;

  /**
   * number of columns across the keyboard if passing a flat array
   */
  columnCount?: number;

  /**
   * number of rows down the keyboard if passing a flat array
   */
  rowCount?: number;

  get style(): KeyboardStyle;
  set style(v: StylePartial<KeyboardStyle>);

  // methods
  /**
   * switches the keyboard format used to a newly specified format
   * @param string a key of keyboard format to switch to
   */
  $toggleKeyboard(next: string): void;

  /**
   *
   * @param keyboard an element rendering a keyboard
   * @param KeyboardSelectedKeyPosition an object specifying the row and column of the key to select
   */
  selectKeyOn(
    keyboard: lng.Component,
    KeyboardSelectedKeyPosition: KeyboardSelectedKeyPosition
  ): void;

  /**
   * returns an object specifying the row and column of the selected key
   */
  getSelectedKey(): KeyboardSelectedKeyPosition;

  /**
   * An method triggered by fireAncestors('$itemChanged') being invoked by a child component.
   */
  $itemChanged(): void;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare class KeyboardEmail extends Keyboard {}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare class KeyboardFullscreen extends Keyboard {}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare class KeyboardNumbers extends Keyboard {}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare class KeyboardQwerty extends Keyboard {}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type inputStyleObject = {
  radius: lng.Tools.CornerRadius;
};

type KeyboardInputStyle = {
  keySpacing: number;
  screenW: number;
  marginX: number;
  inputSpacing: number;
  inputStyle: inputStyleObject;
};

declare class KeyboardInput extends Base {
  centerKeyboard?: boolean;
  defaultFormat?: string;
  input?: Record<string, unknown>;
  keyboardType?: lng.Component; // use this prop to specify which keyboard to use (KeyboardQwerty, KeyboardEmail, etc)
  get style(): KeyboardInputStyle;
  set style(v: StylePartial<KeyboardInputStyle>);
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare class KeyboardSearch extends Keyboard {}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type KnobStyle = {
  circleColor: Color;
  radius: lng.Tools.CornerRadius;
};

declare class Knob<
  TemplateSpec extends Base.TemplateSpec = Base.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  get style(): KnobStyle;
  set style(v: StylePartial<KnobStyle>);
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type LogoStyleObject = {
  radius: lng.Tools.CornerRadius;
  h: number;
  w: number;
};

type ListItemStyle = ButtonStyle & {
  alpha: number;
  descriptionTextStyle: TextBoxStyle;
  logoStyle: LogoStyleObject;
  paddingX: number;
  suffixH: number;
  /** @deprecated */
  titlePadding: number;
  contentSpacing: number;
  titleTextStyle: TextBoxStyle;
};

declare namespace ListItem {
  export interface TemplateSpec extends Button.TemplateSpec {
    /**
     * description text
     */
    description?: string;

    /**
     * Logo to be placed to the left of the title and description
     */
    prefixLogo?: string;

    /**
     * flag that if `true`, hides the title when `ListItem` is in unfocused or disabled mode
     */
    shouldCollapse?: boolean;

    /**
     * Logo to be placed to the right of the title and description
     */
    suffixLogo?: string;

    style?: StylePartial<ListItemStyle>;
  }
}

declare class ListItem<
  TemplateSpec extends ListItem.TemplateSpec = ListItem.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Button<TemplateSpec, TypeConfig> {
  /**
   * description text
   */
  description?: string;

  /**
   * Logo to be placed to the left of the title and description
   */
  prefixLogo?: string;

  /**
   * flag that if `true`, hides the title when `ListItem` is in unfocused or disabled mode
   */
  shouldCollapse?: boolean;

  /**
   * Logo to be placed to the right of the title and description
   */
  suffixLogo?: string;

  get style(): ListItemStyle;
  set style(v: StylePartial<ListItemStyle>);

  // tags
  get _Description(): TextBox;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type ListItemPickerStyle = ListItemStyle & {
  arrowAlphaValue: number;
  arrowAlphaValueLimit: number;
  arrowWidth: number;
  arrowHeight: number;
  arrowColor: Color;
  iconLeftSrc: string;
  iconRightSrc: string;
};

declare namespace ListItemPicker {
  export interface TemplateSpec extends ListItem.TemplateSpec {
    /**
     * list of selectable options
     */
    options?: string[];

    /**
     * index of current selected option
     */
    selectedIndex?: number;

    style?: StylePartial<ListItemStyle>;
  }
}

declare class ListItemPicker<
  TemplateSpec extends ListItemPicker.TemplateSpec = ListItemPicker.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends ListItem<TemplateSpec, TypeConfig> {
  /**
   * list of selectable options
   */
  options?: string[];

  /**
   * index of current selected option
   */
  selectedIndex?: number;

  /**
   * returns the component instance of the currently selected option in `ListItemPicker._Picker.items`
   */
  get selectedOption(): Marquee;

  get style(): ListItemPickerStyle;
  set style(v: StylePartial<ListItemPickerStyle>);

  // tags
  get _LeftArrow(): Icon;
  get _RightArrow(): Icon;
  get _Picker(): Row;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type SliderStyle = {
  arrowAlphaValue: number;
  arrowAlphaValueLimit: number;
  arrowColor: Color;
  arrowHeight: number;
  arrowSpacing: number;
  arrowWidth: number;
  containerHeight: number;
  iconLeftSrc: string;
  iconRightSrc: string;
  minWidth: number;
  progressBarStyle: ProgressBarStyle;
  showArrows: boolean;
  showKnob: boolean;
  circleAnimation: {
    timingFunction: string;
    duration: number;
    delay: number;
  };
};

declare namespace Slider {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * upper bound of `value`
     */
    max?: number;

    /**
     *  lower bound of `value`
     */
    min?: number;

    /**
     * The increment or decrement step for changing the value of the slider.
     */
    step?: number;

    /**
     * current value of the slider.
     */
    value?: number;

    /**
     * If set to true, the slider will be displayed vertically otherwise, it will be displayed horizontally.
     */
    vertical?: boolean;
  }
}

declare class Slider<
  TemplateSpec extends Slider.TemplateSpec = Slider.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * upper bound of `value`
   */
  max?: number;

  /**
   *  lower bound of `value`
   */
  min?: number;

  /**
   * The increment or decrement step for changing the value of the slider.
   */
  step?: number;

  /**
   * current value of the slider.
   */
  value?: number;

  /**
   * If set to true, the slider will be displayed vertically otherwise, it will be displayed horizontally.
   */
  vertical?: boolean;

  get style(): SliderStyle;
  set style(v: StylePartial<SliderStyle>);

  // tags
  get _Container(): lng.Component;
  get _SliderBar(): lng.Component;
  get _Bar(): lng.Component;
  get _Circle(): lng.Component;
  get _LeftArrow(): lng.Component;
  get _RightArrow(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type NestedSliderStyle = SliderStyle & {
  showArrows: boolean;
  showKnob: boolean;
};

declare class NestedSlider<
  TemplateSpec extends Slider.TemplateSpec = Slider.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Slider<TemplateSpec, TypeConfig> {
  get style(): NestedSliderStyle;
  set style(v: StylePartial<NestedSliderStyle>);
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type ListItemSliderStyle = ListItemStyle & {
  paddingY: number;
  valueTextStyle: TextBoxStyle;
};

declare namespace ListItemSlider {
  export interface TemplateSpec extends ListItem.TemplateSpec {
    /**
     * object containing all properties supported in the [Slider component](?path=/docs/elements-slider--basic)
     */
    slider?: Record<string, unknown>;

    /**
     * current value of slider
     */
    value?: number;

    style?: StylePartial<ListItemSliderStyle>;
  }
}
declare class ListItemSlider<
  TemplateSpec extends ListItemSlider.TemplateSpec = ListItemSlider.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends ListItem<TemplateSpec, TypeConfig> {
  /**
   * object containing all properties supported in the [Slider component](?path=/docs/elements-slider--basic)
   */
  slider?: Record<string, unknown>;

  /**
   * current value of slider
   */
  value?: number;

  get style(): ListItemSliderStyle;
  set style(v: StylePartial<ListItemSliderStyle>);

  // tags
  get _Slider(): NestedSlider;
  get _Value(): TextBox;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type MetadataCardStyle = MetadataBaseStyle;

declare class MetadataCard extends MetadataBase {}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type MetadataCardContentStyle = MetadataBaseStyle;

declare class MetadataCardContent extends MetadataBase {}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type MetadataTileStyle = MetadataBaseStyle;

declare class MetadataTile extends MetadataBase {}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type ProviderStyle = {
  alpha: number;
  counterBackgroundColor: Color;
  counterTextStyle: TextBoxStyle;
  itemSize: number;
  itemSpacing: number;
  radius: lng.Tools.CornerRadius;
};

declare namespace Provider {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * If true, disables the radius style property for Icon providers
     */
    disableRadius: boolean;

    /**
     * text to override counter's default '+Number' functionality
     */
    counterText?: string;

    /**
     *  list of provider images
     */
    providers?: Array<string>;

    /**
     * the number of providers to show before adding a counter
     */
    visibleCount?: number;
  }
  export interface TypeConfig extends lng.Component.TypeConfig {
    SignalMapType: SignalMap;
  }
  /**
   * emitted when an item in the Provider component changes, indicating a change in the displayed providers
   */
  export type SignalMap = {
    providerChanged(): void;
  };
}

declare class Provider<
  TemplateSpec extends Provider.TemplateSpec = Provider.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   *  If true, disables the radius style property for Icon providers
   */
  disableRadius: boolean;

  /**
   * Text to override counter's default '+Number' functionality
   */
  counterText?: string;

  /**
   *  An array of provider images or icons to be displayed in the row
   */
  providers?: Array<string>;

  /**
   * The number of providers to show before adding a counter
   */
  visibleCount?: number;

  // Accessors

  /**
   *  Get the number of hidden providers
   */
  get providersHidden(): number;

  get style(): ProviderStyle;
  set style(v: StylePartial<ProviderStyle>);

  // tags
  get _Row(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type RadioStyle = {
  alpha: number;
  backgroundColor: Color;
  backgroundColorChecked: Color;
  knobColor: Color;
  knobHeight: number;
  knobWidth: number;
  radius: lng.Tools.CornerRadius;
  strokeColor: Color;
  strokeWidth: number;
};

declare namespace Radio {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * status of the radio button
     */
    checked?: boolean;
  }
}

declare class Radio<
  TemplateSpec extends Radio.TemplateSpec = Radio.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * status of the radio button
   */
  checked?: boolean;

  // Method
  /**
   * Toggles the radio state and updates the UI.
   */
  toggle(): void;

  get style(): RadioStyle;
  set style(v: StylePartial<RadioStyle>);

  // tags

  /**
   * returns the radio knob
   */
  get _Knob(): lng.Component;

  /**
   * returns the body of the radio
   */
  get _Body(): lng.Component;

  /**
   * returns the stroke
   */
  get _Stroke(): lng.Component;
}

type ScrollWrapperStyle = {
  textStyle: TextBoxStyle;
  scrollBarW: number;
  scrollBarH: number;
  fadeHeight: 100;
  scroll: {
    timingFunction: string;
    duration: number;
  };
  contentMarginTop: number;
  contentMarginLeft: number;
  sliderMarginLeft: number;
};

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */



type ScrollSliderStyle = SliderStyle & {
  progressBar: { animation: ScrollWrapperStyle['scroll'] };
  circleAnimation: ScrollWrapperStyle['scroll'];
};

declare class ScrollSlider<
  TemplateSpec extends Slider.TemplateSpec = Slider.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Slider<TemplateSpec, TypeConfig> {
  get style(): ScrollSliderStyle;
  set style(v: StylePartial<ScrollSliderStyle>);
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare namespace ScrollWrapper {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * whether or not to auto scroll the content
     */
    autoScroll?: boolean;

    /**
     * delay, in ms, before auto scroll starts
     */
    autoScrollDelay?: number;

    /**
     * time delay, in ms, before each scroll step
     */
    autoScrollSpeed?: number;

    /**
     * Content is items that are viewable in the container. It can be an
     * array of strings or an array of lightning elements that can be patched in
     */
    content?: string | (string | lng.Component)[];

    /**
     * fade out content at the bottom of the ScrollWrapper
     */
    fadeContent?: boolean;

    /**
     * determines the direction items are placed in flexContainer
     */
    flexDirection?: 'row' | 'row-reverse' | 'column' | 'column-reverse';

    /**
     * animation duration for the scroll
     */
    scrollDuration?: number;

    /**
     * how many pixels to scroll by on every up/down keypress
     */
    scrollStep?: number;

    /**
     * determines if items should wrap around ScrollContainer
     */
    shouldWrap?: boolean;

    /**
     * show the scroll bar when focused
     */
    showScrollBar?: boolean;
  }

  export interface TypeConfig extends lng.Component.TypeConfig {
    SignalMapType: SignalMap;
  }

  export type SignalMap = {
    /**
     * emitted when user is at the top of the content and presses up again
     */
    onUpAtTop(): void;

    /**
     * emitted when user is at the bottom of the content and presses bottom again
     */
    onDownAtBottom(): void;
  };
}

declare class ScrollWrapper<
  TemplateSpec extends ScrollWrapper.TemplateSpec = ScrollWrapper.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * whether or not to auto scroll the content
   */
  autoScroll?: boolean;

  /**
   * delay, in ms, before auto scroll starts
   */
  autoScrollDelay?: number;

  /**
   * time delay, in ms, before each scroll step
   */
  autoScrollSpeed?: number;

  /**
   * Content is items that are viewable in the container. It can be an
   * array of strings or an array of lightning elements that can be patched in
   */
  content?: string | (string | lng.Component)[];

  /**
   * fade out content at the bottom of the ScrollWrapper
   */
  fadeContent?: boolean;

  /**
   * determines the direction items are placed in flexContainer
   */
  flexDirection?: 'row' | 'row-reverse' | 'column' | 'column-reverse';

  /**
   * animation duration for the scroll
   */
  scrollDuration?: number;

  /**
   * how many pixels to scroll by on every up/down keypress
   */
  scrollStep?: number;

  /**
   * determines if items should wrap around ScrollContainer
   */
  shouldWrap?: boolean;

  /**
   * show the scroll bar when focused
   */
  showScrollBar?: boolean;

  /**
   * Resets the `y` value of both the content and the scroll bar
   */
  resetScroll(): void;

  get style(): ScrollWrapperStyle;
  set style(v: StylePartial<ScrollWrapperStyle>);

  // tags
  get _FadeContainer(): lng.Component;
  get _Slider(): ScrollSlider;
  get _ScrollContainer(): lng.Component;
  get _ScrollableText(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type ShadowStyle = {
  alpha: number;
  animation: lng.types.TransitionSettings.Literal;
  blur: number;
  color: Color;
  offsetX: number;
  offsetY: number;
  radius: lng.Tools.CornerRadius;
  spread: number;
  maxOffsetX: number;
  maxOffsetY: number;
};

declare namespace Shadow {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * if true, uses holepunch shader to mask out base component shape
     */
    maskShadow?: boolean;
  }
}

declare class Shadow<
  TemplateSpec extends Shadow.TemplateSpec = Shadow.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * if true, uses holepunch shader to mask out base component shape
   */
  maskShadow?: boolean;

  get style(): ShadowStyle;
  set style(v: StylePartial<ShadowStyle>);

  // tags
  get _Frame(): lng.Component;
  get _Shadow(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type TabBarStyle = {
  tabsMarginBottom: number;
  tabSpacing: number;
};

type ResolvedTab =
  | lng.Component.NewPatchTemplate<typeof lng.Component>
  | lng.Component;

declare namespace TabBar {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * when true, a lower alpha will be applied to unselected tabs when focus is delegated to the tab content
     */
    alphaSelectedTab?: boolean;

    /**
     * when true, the height of the TabBar will only reflect the height of the Tabs when unfocused or no tab content is available
     */
    collapse?: boolean;

    /**
     * when true, the selected tab index will be reset when the TabBar component is unfocused
     */
    reset?: boolean;

    /**
     * the content displayed when a tab is selected via tabConent property on each tab
     */
    tabs?: Array<ResolvedTab | Promise<ResolvedTab> | (() => ResolvedTab)>;

    //Following properties come from spreading of Row

    /**
     * the navigation direction of the tabBar
     */
    direction?: NavigationDirectionType;

    /**
     * enables wrapping behavior of tabs within the tabBar
     */
    wrapSelected?: boolean;

    /**
     * Determines whether the component will stop scrolling as it nears the end of the tabBar to prevent white space.
     * If true, the component will scroll infinitely when migrating to a different tab within the tabBar.
     */
    alwaysScroll?: boolean;

    /**
     * If true, the component will never scroll when migrating to a different tab within the tabBar, unless `alwaysScroll` is set to true.
     * If false, the component will apply normal scrolling logic when migrating from one tab to another within the tabBar.
     */
    neverScroll?: boolean;

    /**
     * Tab index at which scrolling of the tabBar containing the tabs begins, provided the sum of tabs widths is greater than the width of the tabBar component.
     */
    scrollIndex?: number;

    /**
     * Automatically sets the width of the tabBar containing the tabs to be the same as the Items container inside (this will prevent scrolling).
     */
    autoResizeWidth?: boolean;

    /**
     * Automatically sets the height of the tabBar containing the tabs to be the same as the Items container inside.
     */
    autoResizeHeight?: boolean;

    /**
     * Note: `lazyUpCount` and `lazyUpCountBuffer` work hand in hand.
     * If defined, `lazyUpCount` enables "lazy loading" of items where only an initial number of items are displayed when the Row/Column first renders until further navigation.
     * The initial number of tabs is calculated by `lazyUpCount` + `lazyLoadUpCountBuffer`.
     * The remaining tabs are stored as lazy tabss.
     * Each time `selectNext` is invoked (moving right in Row or down in a Column), an item (that was not initially displayed) will be added to the end until all lazy items are loaded.
     */
    lazyUpCount?: number;

    /**
     * By default `lazyUpCountBuffer` is 2.
     * Changing this value updates the initial number of tabs to display on first render of Row/Column.
     * Note: this behavior will only occur if `lazyUpCount` is defined.
     * ex: only providing `lazyUpCountBuffer: 1` will display all tabs since `lazyUpCount` is not set so the “lazy loading” behavior is not enabled.
     */
    lazyUpCountBuffer?: number;

    /**
     * If true, will only scroll to the next tab in the tabBar if the tab is off screen and `alwaysScroll` and `neverScroll` are both false.
     */
    lazyScroll?: boolean;

    /**
     * When `lazyScroll` is `true`,
     * this is the index of tab in `items`, and items thereafter, at which lazy scrolling should occur
     * (alwaysScroll functionality will take place before this index)
     */
    startLazyScrollIndex?: number;

    /**
     * When `lazyScroll` is `true`,
     * this is the index of tab in `items`, and items preceding, at which lazy scrolling should occur
     * (alwaysScroll functionality will take place after this index)
     */
    stopLazyScrollIndex?: number;
  }
}

declare class TabBar<
  TemplateSpec extends TabBar.TemplateSpec = TabBar.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * when true, a lower alpha will be applied to unselected tabs when focus is delegated to the tab content
   */
  alphaSelectedTab?: boolean;

  /**
   * when true, the height of the TabBar will only reflect the height of the Tabs when unfocused or no tab content is available
   */
  collapse?: boolean;

  /**
   * when true, the selected tab index will be reset when the TabBar component is unfocused
   */
  reset?: boolean;

  /**
   * the content displayed when a tab is selected via tabConent property on each tab
   */
  tabs?: Array<ResolvedTab | Promise<ResolvedTab> | (() => ResolvedTab)>;

  //Following properties come from spreading of Row

  /**
   * the navigation direction of the tabBar
   */
  direction?: NavigationDirectionType;

  /**
   * enables wrapping behavior of tabs within the tabBar
   */
  wrapSelected?: boolean;

  /**
   * Determines whether the component will stop scrolling as it nears the end of the tabBar to prevent white space.
   * If true, the component will scroll infinitely when migrating to a different tab within the tabBar.
   */
  alwaysScroll?: boolean;

  /**
   * If true, the component will never scroll when migrating to a different tab within the tabBar, unless `alwaysScroll` is set to true.
   * If false, the component will apply normal scrolling logic when migrating from one tab to another within the tabBar.
   */
  neverScroll?: boolean;

  /**
   * Tab index at which scrolling of the tabBar containing the tabs begins, provided the sum of tabs widths is greater than the width of the tabBar component.
   */
  scrollIndex?: number;

  /**
   * Automatically sets the width of the tabBar containing the tabs to be the same as the Items container inside (this will prevent scrolling).
   */
  autoResizeWidth?: boolean;

  /**
   * Automatically sets the height of the tabBar containing the tabs to be the same as the Items container inside.
   */
  autoResizeHeight?: boolean;

  /**
   * Note: `lazyUpCount` and `lazyUpCountBuffer` work hand in hand.
   * If defined, `lazyUpCount` enables "lazy loading" of items where only an initial number of items are displayed when the Row/Column first renders until further navigation.
   * The initial number of tabs is calculated by `lazyUpCount` + `lazyLoadUpCountBuffer`.
   * The remaining tabs are stored as lazy tabss.
   * Each time `selectNext` is invoked (moving right in Row or down in a Column), an item (that was not initially displayed) will be added to the end until all lazy items are loaded.
   */
  lazyUpCount?: number;

  /**
   * By default `lazyUpCountBuffer` is 2.
   * Changing this value updates the initial number of tabs to display on first render of Row/Column.
   * Note: this behavior will only occur if `lazyUpCount` is defined.
   * ex: only providing `lazyUpCountBuffer: 1` will display all tabs since `lazyUpCount` is not set so the “lazy loading” behavior is not enabled.
   */
  lazyUpCountBuffer?: number;

  /**
   * If true, will only scroll to the next tab in the tabBar if the tab is off screen and `alwaysScroll` and `neverScroll` are both false.
   */
  lazyScroll?: boolean;

  /**
   * When `lazyScroll` is `true`,
   * this is the index of tab in `items`, and items thereafter, at which lazy scrolling should occur
   * (alwaysScroll functionality will take place before this index)
   */
  startLazyScrollIndex?: number;

  /**
   * When `lazyScroll` is `true`,
   * this is the index of tab in `items`, and items preceding, at which lazy scrolling should occur
   * (alwaysScroll functionality will take place after this index)
   */
  stopLazyScrollIndex?: number;

  get style(): TabBarStyle;
  set style(v: StylePartial<TabBarStyle>);

  // tags
  get _Tabs(): lng.Component;
  get _TabContent(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type TabStyle = SurfaceStyle & {
  backgroundColor: Color;
  contentColor: Color;
  iconMarginRight: number;
  iconSize: number;
  /**
   * @deprecated
   * use paddingXNoTitle instead
   * of noTitlePaddingX
   */
  noTitlePaddingX: number;
  paddingXNoTitle: number;
  paddingX: number;
  paddingY: number;
  radius: number;
  textStyle: TextBoxStyle;
};

declare namespace Tab {
  export interface TemplateSpec extends Surface.TemplateSpec {
    /**
     * path to icon to prepend tab title with
     */
    icon?: string;

    /**
     * text to display on tab
     */
    title?: string;
  }
}

declare class Tab<
  TemplateSpec extends Tab.TemplateSpec = Tab.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Surface<TemplateSpec, TypeConfig> {
  /**
   * path to icon to prepend tab title with
   */
  icon?: string;

  /**
   * text to display on tab
   */
  title?: string;

  get _textW(): number;
  get _iconW(): number;
  get _iconH(): number;
  get _paddingX(): number;
  get style(): TabStyle;
  set style(v: StylePartial<TabStyle>);

  // tags
  get _Content(): lng.Component;
  get _Icon(): Icon;
  get _Text(): TextBox;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type ToggleStyle = {
  backgroundColor: Color;
  backgroundColorChecked: Color;
  knobWidth: number;
  knobHeight: number;
  knobPadding: number;
  knobRadius: lng.Tools.CornerRadius;
  knobColor: Color;
  knobColorChecked: Color;
  /* @deprecated */
  knobX: number;
  /* @deprecated */
  knobXChecked: number;
  strokeColor: Color;
  strokeRadius: lng.Tools.CornerRadius;
  /* @deprecated */
  strokeWeight: number;
  strokeWidth: number;
};

declare namespace Toggle {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * status of the toggle
     */
    checked?: boolean;
  }
}

declare class Toggle<
  TemplateSpec extends Toggle.TemplateSpec = Toggle.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * status of the toggle
   */
  checked?: boolean;

  // Method

  toggle(): this; // TODO is this valid?

  get style(): ToggleStyle;
  set style(v: StylePartial<ToggleStyle>);

  // tags

  /**
   * returns the container containing the stroke and knob
   */
  get _Container(): lng.Component;

  /**
   * returns the toggle knob
   */
  get _Knob(): lng.Component;

  /**
   * returns the stroke
   */
  get _Stroke(): lng.Component;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type TooltipStyle = {
  backgroundColor: Color;
  marginBottom: number;
  paddingX: number;
  paddingY: number;
  /** @deprecated */
  pointerW: number;
  pointerWidth: number;
  /** @deprecated */
  pointerH: number;
  pointerHeight: number;
  radius: lng.Tools.CornerRadius;
  textStyle: TextBoxStyle;
  transition: lng.types.TransitionSettings;
};

declare namespace Tooltip {
  export interface TemplateSpec extends Base.TemplateSpec {
    /**
     * Text of tooltip content
     */
    title?: string;

    /**
     * The amount of time, in milliseconds, before the tooltip is displayed after being focused
     */
    delayVisible?: number;

    /**
     * The amount of time, in milliseconds, the tooltip is displayed before transitioning out of the display
     */
    timeVisible?: number;
  }
}

declare class Tooltip<
  TemplateSpec extends Tooltip.TemplateSpec = Tooltip.TemplateSpec,
  TypeConfig extends lng.Component.TypeConfig = lng.Component.TypeConfig
> extends Base<TemplateSpec, TypeConfig> {
  /**
   * text of tooltip
   */
  title?: string;

  /**
   * the amount of time, in milliseconds, before the tooltip is displayed after being focused
   */
  delayVisible?: number;

  /**
   * the amount of time, in milliseconds, the tooltip is displayed before transitioning out of the display
   */
  timeVisible?: number;

  get style(): TooltipStyle;
  set style(v: StylePartial<TooltipStyle>);

  // tags
  get _Background(): lng.Component;
  get _Text(): TextBox;
}

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

type AbbreviationReplacer =
  | string
  | ((match: string, ...groups: string[]) => string);

type AbbreviationConfig = {
  abbreviationsPattern: RegExp;
  stringPatternMap: Record<string, { replacer: AbbreviationReplacer }>;
  regExpPatternMap: Record<
    number,
    { pattern: RegExp; replacer: AbbreviationReplacer }
  >;
};

type Abbreviation = {
  pattern: string | RegExp;
  replacer: AbbreviationReplacer;
};

declare function generateAbbrevConfig(
  abbreviations: Abbreviation[],
  extendDefault
): AbbreviationConfig;

declare const defaultAbbrevConfig: AbbreviationConfig;

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type SpeechType =
  | string
  | undefined
  | Array<SpeechType>
  | Promise<SpeechType>
  | (() => SpeechType);

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type SpeakFunction = (toSpeak: SpeechType) => any;

interface WithAnnouncerOptions {
  voiceOutDelay?: number;
  abbreviationsConfig?: AbbreviationConfig;
}

interface AnnounceOptions {
  append: boolean;
  notification: boolean;
}

interface WithAnnouncer {
  announcerTimeout: number;

  set announcerEnabled(val: boolean);
  get announcerEnabled(): boolean;

  _voiceOut(toAnnounce: SpeechType): void;
  _focusChange(): void;
  _announceFocusChanges(): void;

  $announce: (announcement: SpeechType, options?: AnnounceOptions) => void;
  $announcerCancel: () => void;
  $announcerRefresh: () => void;
}

interface WithAnnouncerConstructor {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  new (...args: any[]): WithAnnouncer;
}

declare function withAnnouncer<T extends typeof lng.Component>(
  base: T,
  speak?: SpeakFunction,
  options?: WithAnnouncerOptions
): T & WithAnnouncerConstructor;

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type WithClassCacheConstructor<BaseType extends typeof lng.Component> =
  BaseType & {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    new (...args: any[]): BaseType;
  };

declare function withClassCache<BaseType extends typeof lng.Component>(
  base: BaseType
): WithClassCacheConstructor<BaseType>;

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


interface WithEditItems {
  get selectedIndex(): number;
  set selectedIndex(val: number);

  toggleEdit(): void;
}

interface WithEditItemsConstructor {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  new (...args: any[]): WithEditItems;
}

declare function withTags$1<BaseType extends typeof lng.Component>(
  base: BaseType
): BaseType & WithEditItemsConstructor;

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


interface WithExtensions {
  get _withExtensionsApplied(): boolean;
  get _prototypeChain(): Set<string>;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get _extensions(): Record<string, any>[];
  get _componentExtensions(): unknown[];
  get _extensionsApplied(): boolean;

  _resetComponent(): void;
  _calculateComponentExtensionLength(): number;
  _createExtension(): void;
  _createExtensionClass(): unknown;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _createExtensionAliases(obj: Record<string, any>): object;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _setComponentAliases(aliasObj: Record<string, any>): void;
}

interface WithExtensionsConstructor {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  new (...args: any[]): WithExtensions;
}

declare function withExtensions<
  BaseType extends lng.Component.Constructor // use this instead of lng.Component for BaseType in mixins
>(base: BaseType): BaseType & WithExtensionsConstructor;

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type WithHandleKeyConstructor<BaseType extends typeof lng.Component> =
  BaseType & {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    new (...args: any[]): BaseType;
  };

declare function withHandleKey<BaseType extends typeof lng.Component>(
  base: BaseType
): WithHandleKeyConstructor<BaseType>;

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


interface LayoutOptions {
  w?: number;
  h?: number;
  circle?: boolean;
  ratioX?: number;
  ratioY?: number;
  upCount?: number;
}

interface WithLayout {
  _previousDimensionsData: string;
  _itemLayout?: LayoutOptions;

  set itemLayout(val: LayoutOptions);
  get itemLayout(): LayoutOptions;

  _allowUpdate(): boolean;
  _updateItemLayout(): void;
}

type WithLayoutConstructor<BaseType extends typeof lng.Component> =
  BaseType & {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    new (...args: any[]): BaseType & WithLayout;
  };

declare function withLayout<BaseType extends typeof lng.Component>(
  base: BaseType
): WithLayoutConstructor<BaseType>;

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type WithMarqueeSyncConstructor<BaseType extends typeof lng.Component> =
  BaseType & {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    new (...args: any[]): BaseType;
    _cleanupSyncValues(): void;
    _updateSignals(): void;
    _willMarquee(): void;
    get _shouldSync(): boolean;
  };

declare function withMarqueeSync<BaseType extends typeof lng.Component>(
  base: BaseType
): WithMarqueeSyncConstructor<BaseType>;

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare const setSelected: unique symbol;
declare const currentSelected: unique symbol;

interface WithSelectionsOptionsKeys {
  currentSelected?: string;
  currentSelectedIndex?: string;
  isSelected?: string;
  items?: string;
  setSelected?: string;
}

interface WithSelectionsOptions {
  captureKey?: string;
  defaultIndex?: number;
  eventName?: string;
  options?: WithSelectionsOptionsKeys;
}

interface WithSelections {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get [currentSelected](): any;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  [setSelected](selected: any, val: any): void;
}

interface WithSelectionsConstructor {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  new (...args: any[]): WithSelections;
}

declare function withSelections<BaseType extends typeof lng.Component>(
  base: BaseType,
  options: WithSelectionsOptions
): BaseType & WithSelectionsConstructor;

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


type WithTagsConstructor<BaseType extends typeof lng.Component> =
  BaseType & {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    new (...args: any[]): BaseType;
  };

declare function withTags<BaseType extends typeof lng.Component>(
  base: BaseType
): WithTagsConstructor<BaseType>;

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


interface WithThemeStyles<StyleType> {
  _componentStyle: StyleType; // TODO: Remove when legacy code is also removed
  style: StyleType;
}

type WithThemeStylesConstructor<
  BaseType extends lng.Component.Constructor,
  StyleType
> = BaseType & {
  new (...args: any[]): BaseType & WithThemeStyles<StyleType>;
  _componentStyle: StyleType; // TODO: Remove when legacy code is also removed
  style: StyleType;
};

declare function withThemeStyles<
  BaseType extends lng.Component.Constructor,
  StyleType
>(
  Base: BaseType,
  style: (theme: Record<string, any>) => StyleType
): WithThemeStylesConstructor<BaseType, StyleType>;

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


interface WithUpdates {
  queueRequestUpdate();
  requestEarlyUpdate(): boolean;
  requestUpdate(force: boolean);
  logPropTable();
}

type WithUpdatesConstructor<BaseType extends typeof lng.Component> =
  BaseType & {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    new (...args: any[]): BaseType & WithUpdates;
  };

declare function withUpdates<BaseType extends typeof lng.Component>(
  base: BaseType
): WithUpdatesConstructor<BaseType>;

/* eslint-disable @typescript-eslint/no-explicit-any */
type ThemeObject = any;

type CallbackFunction = (...args: unknown[]) => void;

declare class Context {
  get theme(): ThemeObject;
  set theme(value: ThemeObject);
  get keyMetricsCallback(): any;
  set keyMetricsCallback(value: any);
  get debug(): boolean;
  set debug(value: boolean);

  on(name: string, callback: CallbackFunction): void;
  off(name: string, callback?: CallbackFunction): void;
  emit(name: string, payload: string | object | number | boolean): void;

  log(...args: unknown[]): void;
  info(...args: unknown[]): void;
  warn(...args: unknown[]): void;
  error(...args: unknown[]): void;

  setTheme(value: ThemeObject | ThemeObject[]): ThemeObject;
  updateTheme(value: ThemeObject | ThemeObject[]): ThemeObject;
  getSubTheme(subThemeName: string): ThemeObject;
  setSubThemes(subThemesObj: Record<string, unknown>): void;
  setSubTheme(subThemeName: string, value: unknown): ThemeObject;
  updateSubTheme(subThemeName: string, value: unknown): ThemeObject;
  removeSubTheme(subThemeName: string): void;
  setLogCallback(value: CallbackFunction): void;
  setKeyMetricsCallback(value: CallbackFunction): void;
  config(config: Record<string, unknown>): Context;
}

declare const contextInstance: Context;

/**
 * Copyright 2023 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


declare const utils = {
  isMarkupString,
  capitalizeFirstLetter,
  degreesToRadians,
  downloadFile,
  delayForAnimation,
  stringifyCompare,
  objectPropertyOf,
  flatten,
  getDimension,
  getFirstNumber,
  measureTextWidth,
  clone,
  getMergeValue,
  RoundRect,
  rgba2argb,
  getValFromObjPath,
  reduceFraction,
  getValidColor,
  getHexColor,
  getAspectRatioH,
  getAspectRatioW,
  getWidthByUpCount,
  getDimensions,
  getWidthByColumnSpan,
  createConditionalZContext,
  watchForUpdates,
  convertTextAlignToFlexJustify,
  getMaxRoundRadius
};

export { Artwork, ArtworkStyle, Badge, BadgeStyle, Base, Button, ButtonSmall, ButtonStyle, Card, CardContent, CardContentHorizontal, CardContentHorizontalLarge, CardContentStyle, CardContentVertical, CardContentVerticalSmall, CardRadio, CardRadioStyle, CardSection, CardSectionStyle, CardStyle, CardTitle, CardTitleStyle, Checkbox, CheckboxStyle, Color, Column, Control, ControlRow, ControlRowStyle, ControlSmall, ControlStyle, FocusManager, Gradient, GradientStyle, GridOverlay, Icon, IconStyle, InlineContent, InlineContentStyle, Input, InputStyle, Key, KeyStyle, Keyboard, KeyboardEmail, KeyboardFormat, KeyboardFullscreen, KeyboardInput, KeyboardNumbers, KeyboardQwerty, KeyboardSearch, KeyboardSelectedKeyPosition, KeyboardStyle, Knob, KnobStyle, Label, LabelStyle, LayoutOptions, ListItem, ListItemPicker, ListItemSlider, ListItemStyle, Marquee, MarqueeStyle, MetadataBase, MetadataBaseStyle, MetadataCard, MetadataCardContent, MetadataCardContentStyle, MetadataCardStyle, MetadataTile, MetadataTileStyle, NavigationManager, NavigationManagerStyle, ProgressBar, ProgressBarStyle, Provider, ProviderStyle, Radio, RadioStyle, Row, ScrollWrapper, ScrollWrapperStyle, Shadow, ShadowStyle, Slider, SliderStyle, SpeechType, StylePartial, Surface, SurfaceStyle, Tab, TabBar, TabBarStyle, TabStyle, TextBox, TextBoxStyle, TextContent, Tile, TileStyle, TitleRow, TitleRowStyle, Toggle, ToggleStyle, Tooltip, TooltipStyle, withTags$1 as WithEditItems, WithExtensionsConstructor, contextInstance as context, defaultAbbrevConfig, generateAbbrevConfig, utils, withAnnouncer, withClassCache, withExtensions, withHandleKey, withLayout, withMarqueeSync, withSelections, withTags, withThemeStyles, withUpdates };
