/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

export module Settings {
    type LogLevel = "WARN" | "INFO" | "DEBUG" | "ERROR"
    function setLogLevel(logLevel: LogLevel): void
    function getLogLevel(): LogLevel     
}

export module Log {
    function info(...args: any[]): void
    function debug(...args: any[]): void
    function error(...args: any[]): void
    function warn(...args: any[]): void
}

export module Events {
    function listen(...args: any[]): Promise<number>
    function once(...args: any[]): Promise<number>
    function clear(...args: any[]): boolean
}

export module Localization {

    type Event = 'countryCodeChanged' | 'languageChanged' | 'localeChanged' | 'localityChanged' | 'postalCodeChanged' | 'preferredAudioLanguagesChanged' | 'timeZoneChanged'

// Types

    /**
     * 
     */
type Locality = string

    /**
     * 
     */
type CountryCode = string

    /**
     * 
     */
type Language = string

    /**
     * 
     */
type ISO639_2Language = string

    /**
     * 
     */
type Locale = string

    /**
     * 
     */
type TimeZone = string


  /**
   * Add any platform-specific localization information in key/value pair
   * 
   * @param {string} key Key to add additionalInfo
   * @param {number} value Value to be set for additionalInfo. Value can be a number, string or boolean
  */
  function addAdditionalInfo(key: string, value: number): Promise<void>

  /**
   * Get any platform-specific localization information
   * 
  */
  function additionalInfo(): Promise<object>

  /**
   * Turn off all listeners previously registered from this module.
   */
  function clear(): boolean

  /**
   * Clear a specific listen by the listener ID.
   * 
   * @param {number} id The id of the listener to clear
   */
  function clear(id: number): boolean

  /**
   * Getter: Get the ISO 3166-1 alpha-2 code for the country device is located in
   * 
  */
  function countryCode(): Promise<CountryCode>


  /**
   * Setter: Get the ISO 3166-1 alpha-2 code for the country device is located in
   * 
   */
  function countryCode(value: CountryCode): Promise<void>



/**
   * Subscriber: Get the ISO 3166-1 alpha-2 code for the country device is located in
   * 
   */
function countryCode(subscriber: (code: CountryCode) => void): Promise<number>


  /**
   * Getter: Get the ISO 639 1/2 code for the preferred language
   * 
   * @deprecated since version 0.17.0
  */
  function language(): Promise<Language>


  /**
   * Setter: Get the ISO 639 1/2 code for the preferred language
   * 
   */
  function language(value: Language): Promise<void>



/**
   * Subscriber: Get the ISO 639 1/2 code for the preferred language
   * 
   */
function language(subscriber: (lang: Language) => void): Promise<number>


  /**
   * Listen to all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function listen(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Getter: Get the *full* BCP 47 code, including script, region, variant, etc., for the preferred langauage/locale
   * 
  */
  function locale(): Promise<Locale>


  /**
   * Setter: Get the *full* BCP 47 code, including script, region, variant, etc., for the preferred langauage/locale
   * 
   */
  function locale(value: Locale): Promise<void>



/**
   * Subscriber: Get the *full* BCP 47 code, including script, region, variant, etc., for the preferred langauage/locale
   * 
   */
function locale(subscriber: (locale: Locale) => void): Promise<number>


  /**
   * Getter: Get the locality/city the device is located in
   * 
  */
  function locality(): Promise<Locality>


  /**
   * Setter: Get the locality/city the device is located in
   * 
   */
  function locality(value: Locality): Promise<void>



/**
   * Subscriber: Get the locality/city the device is located in
   * 
   */
function locality(subscriber: (locality: Locality) => void): Promise<number>


  /**
   * Listen for the first of any and all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function once(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Get the ISO 3166-1 alpha-2 code for the country device is located in
   * 
   * @param {'countryCodeChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'countryCodeChanged', callback: (data: CountryCode) => void): Promise<number>

  /**
   * Get the ISO 3166-1 alpha-2 code for the country device is located in
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'countryCodeChanged'} event
   * @param {Function} callback
  */
function once(event: 'countryCodeChanged', callback: (data: CountryCode) => void): Promise<number>

  /**
   * Get the ISO 639 1/2 code for the preferred language
   * 
   * @param {'languageChanged'} event
   * @param {Function} callback
   * @deprecated since version 0.17.0
  */
  function listen(event: 'languageChanged', callback: (data: Language) => void): Promise<number>

  /**
   * Get the ISO 639 1/2 code for the preferred language
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'languageChanged'} event
   * @param {Function} callback
   * @deprecated since version 0.17.0
  */
function once(event: 'languageChanged', callback: (data: Language) => void): Promise<number>

  /**
   * Get the *full* BCP 47 code, including script, region, variant, etc., for the preferred langauage/locale
   * 
   * @param {'localeChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'localeChanged', callback: (data: Locale) => void): Promise<number>

  /**
   * Get the *full* BCP 47 code, including script, region, variant, etc., for the preferred langauage/locale
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'localeChanged'} event
   * @param {Function} callback
  */
function once(event: 'localeChanged', callback: (data: Locale) => void): Promise<number>

  /**
   * Get the locality/city the device is located in
   * 
   * @param {'localityChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'localityChanged', callback: (data: Locality) => void): Promise<number>

  /**
   * Get the locality/city the device is located in
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'localityChanged'} event
   * @param {Function} callback
  */
function once(event: 'localityChanged', callback: (data: Locality) => void): Promise<number>

  /**
   * Get the postal code the device is located in
   * 
   * @param {'postalCodeChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'postalCodeChanged', callback: (data: string) => void): Promise<number>

  /**
   * Get the postal code the device is located in
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'postalCodeChanged'} event
   * @param {Function} callback
  */
function once(event: 'postalCodeChanged', callback: (data: string) => void): Promise<number>

  /**
   * A prioritized list of ISO 639 1/2 codes for the preferred audio languages on this device.
   * 
   * @param {'preferredAudioLanguagesChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'preferredAudioLanguagesChanged', callback: (data: ISO639_2Language[]) => void): Promise<number>

  /**
   * A prioritized list of ISO 639 1/2 codes for the preferred audio languages on this device.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'preferredAudioLanguagesChanged'} event
   * @param {Function} callback
  */
function once(event: 'preferredAudioLanguagesChanged', callback: (data: ISO639_2Language[]) => void): Promise<number>

  /**
   * Set the IANA timezone for the device
   * 
   * @param {'timeZoneChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'timeZoneChanged', callback: (data: TimeZone) => void): Promise<number>

  /**
   * Set the IANA timezone for the device
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'timeZoneChanged'} event
   * @param {Function} callback
  */
function once(event: 'timeZoneChanged', callback: (data: TimeZone) => void): Promise<number>

  /**
   * Getter: Get the postal code the device is located in
   * 
  */
  function postalCode(): Promise<string>


  /**
   * Setter: Get the postal code the device is located in
   * 
   */
  function postalCode(value: string): Promise<void>



/**
   * Subscriber: Get the postal code the device is located in
   * 
   */
function postalCode(subscriber: (postalCode: string) => void): Promise<number>


  /**
   * Getter: A prioritized list of ISO 639 1/2 codes for the preferred audio languages on this device.
   * 
  */
  function preferredAudioLanguages(): Promise<ISO639_2Language[]>


  /**
   * Setter: A prioritized list of ISO 639 1/2 codes for the preferred audio languages on this device.
   * 
   */
  function preferredAudioLanguages(value: ISO639_2Language[]): Promise<void>



/**
   * Subscriber: A prioritized list of ISO 639 1/2 codes for the preferred audio languages on this device.
   * 
   */
function preferredAudioLanguages(subscriber: (languages: ISO639_2Language[]) => void): Promise<number>


  /**
   * Remove any platform-specific localization information from map
   * 
   * @param {string} key Key to remove additionalInfo
  */
  function removeAdditionalInfo(key: string): Promise<void>

  /**
   * Getter: Set the IANA timezone for the device
   * 
  */
  function timeZone(): Promise<TimeZone>


  /**
   * Setter: Set the IANA timezone for the device
   * 
   */
  function timeZone(value: TimeZone): Promise<void>



/**
   * Subscriber: Set the IANA timezone for the device
   * 
   */
function timeZone(subscriber: (result: TimeZone) => void): Promise<number>




}


export module Metrics {


// Types

    /**
     * 
     */
type EventObjectPrimitives = string | number | number | boolean | null

    /**
     * 
     */
type EventObject = {

}



  /**
   * Inform the platform of 1st party distributor metrics.
   * 
   * @param {string} schema The schema URI of the metric type
   * @param {EventObject} data A JSON payload conforming the the provided schema
  */
  function event(schema: string, data: EventObject): Promise<null>



}

export module Wifi {


// Types

    /**
     * Security Mode supported for Wifi
     */
enum WifiSecurityMode {
    NONE = 'none',
    WEP_64 = 'wep64',
    WEP_128 = 'wep128',
    WPA_PSK_TKIP = 'wpaPskTkip',
    WPA_PSK_AES = 'wpaPskAes',
    WPA_2PSK_TKIP = 'wpa2PskTkip',
    WPA_2PSK_AES = 'wpa2PskAes',
    WPA_ENTERPRISE_TKIP = 'wpaEnterpriseTkip',
    WPA_ENTERPRISE_AES = 'wpaEnterpriseAes',
    WPA_2ENTERPRISE_TKIP = 'wpa2EnterpriseTkip',
    WPA_2ENTERPRISE_AES = 'wpa2EnterpriseAes',
    WPA_2PSK = 'wpa2Psk',
    WPA_2ENTERPRISE = 'wpa2Enterprise',
    WPA_3PSK_AES = 'wpa3PskAes',
    WPA_3SAE = 'wpa3Sae',
}


    /**
     * Security pin type for WPS(Wifi Protected Setup).
     */
enum WPSSecurityPin {
    PUSH_BUTTON = 'pushButton',
    PIN = 'pin',
    MANUFACTURER_PIN = 'manufacturerPin',
}


    /**
     * Defines the timeout in seconds. If the threshold for timeout is passed for any operation without a result it will throw an error.
     */
type Timeout = number

    /**
     * Strength of Wifi signal, value is negative based on RSSI specification.
     */
type WifiSignalStrength = number

    /**
     * Wifi Frequency in Ghz, example 2.4Ghz and 5Ghz.
     */
type WifiFrequency = number

    /**
     * Properties of a scanned wifi list item.
     */
type AccessPoint = {
    ssid?: string // Name of the wifi.
    securityMode?: WifiSecurityMode // Security Mode supported for Wifi
    signalStrength?: WifiSignalStrength // Strength of Wifi signal, value is negative based on RSSI specification.
    frequency?: WifiFrequency // Wifi Frequency in Ghz, example 2.4Ghz and 5Ghz.
}


    /**
     * List of scanned Wifi networks available near the device.
     */
type AccessPointList = {
    list?: AccessPoint[] // Properties of a scanned wifi list item.
}



  /**
   * Connect the device to the specified SSID.
   * 
   * @param {string} ssid 
   * @param {string} passphrase 
   * @param {WifiSecurityMode} security 
  */
  function connect(ssid?: string, passphrase?: string, security?: WifiSecurityMode): Promise<AccessPoint>

  /**
   * Disconnect the device if connected via WIFI.
   * 
  */
  function disconnect(): Promise<void>

  /**
   * Scan available wifi networks in the location.
   * 
   * @param {Timeout} timeout 
  */
  function scan(timeout?: Timeout): Promise<AccessPointList>

  /**
   * Connect to WPS
   * 
   * @param {WPSSecurityPin} security 
  */
  function wps(security?: WPSSecurityPin): Promise<AccessPoint>



}

export module ClosedCaptions {

    type Event = 'backgroundColorChanged' | 'backgroundOpacityChanged' | 'enabledChanged' | 'fontColorChanged' | 'fontEdgeChanged' | 'fontEdgeColorChanged' | 'fontFamilyChanged' | 'fontOpacityChanged' | 'fontSizeChanged' | 'preferredLanguagesChanged' | 'textAlignChanged' | 'textAlignVerticalChanged' | 'windowColorChanged' | 'windowOpacityChanged'

// Types

    /**
     * 
     */
enum FontFamily {
    MONOSPACED_SERIF = 'monospaced_serif',
    PROPORTIONAL_SERIF = 'proportional_serif',
    MONOSPACED_SANSERIF = 'monospaced_sanserif',
    PROPORTIONAL_SANSERIF = 'proportional_sanserif',
    SMALLCAPS = 'smallcaps',
    CURSIVE = 'cursive',
    CASUAL = 'casual',
}


    /**
     * 
     */
type FontSize = number

    /**
     * 
     */
type Color = string

    /**
     * 
     */
enum FontEdge {
    NONE = 'none',
    RAISED = 'raised',
    DEPRESSED = 'depressed',
    UNIFORM = 'uniform',
    DROP_SHADOW_LEFT = 'drop_shadow_left',
    DROP_SHADOW_RIGHT = 'drop_shadow_right',
}


    /**
     * 
     */
type Opacity = number

    /**
     * 
     */
type HorizontalAlignment = string

    /**
     * 
     */
type VerticalAlignment = string

    /**
     * 
     */
type ISO639_2Language = string


  /**
   * Getter: The preferred background color for displaying closed-captions, .
   * 
  */
  function backgroundColor(): Promise<Color>


  /**
   * Setter: The preferred background color for displaying closed-captions, .
   * 
   */
  function backgroundColor(value: Color): Promise<void>



/**
   * Subscriber: The preferred background color for displaying closed-captions, .
   * 
   */
function backgroundColor(subscriber: (color: Color) => void): Promise<number>


  /**
   * Getter: The preferred opacity for displaying closed-captions backgrounds.
   * 
  */
  function backgroundOpacity(): Promise<Opacity>


  /**
   * Setter: The preferred opacity for displaying closed-captions backgrounds.
   * 
   */
  function backgroundOpacity(value: Opacity): Promise<void>



/**
   * Subscriber: The preferred opacity for displaying closed-captions backgrounds.
   * 
   */
function backgroundOpacity(subscriber: (opacity: Opacity) => void): Promise<number>


  /**
   * Turn off all listeners previously registered from this module.
   */
  function clear(): boolean

  /**
   * Clear a specific listen by the listener ID.
   * 
   * @param {number} id The id of the listener to clear
   */
  function clear(id: number): boolean

  /**
   * Getter: Whether or not closed-captions are enabled.
   * 
  */
  function enabled(): Promise<boolean>


  /**
   * Setter: Whether or not closed-captions are enabled.
   * 
   */
  function enabled(value: boolean): Promise<void>



/**
   * Subscriber: Whether or not closed-captions are enabled.
   * 
   */
function enabled(subscriber: (enabled: boolean) => void): Promise<number>


  /**
   * Getter: The preferred font color for displaying closed-captions.
   * 
  */
  function fontColor(): Promise<Color>


  /**
   * Setter: The preferred font color for displaying closed-captions.
   * 
   */
  function fontColor(value: Color): Promise<void>



/**
   * Subscriber: The preferred font color for displaying closed-captions.
   * 
   */
function fontColor(subscriber: (color: Color) => void): Promise<number>


  /**
   * Getter: The preferred font edge style for displaying closed-captions.
   * 
  */
  function fontEdge(): Promise<FontEdge>


  /**
   * Setter: The preferred font edge style for displaying closed-captions.
   * 
   */
  function fontEdge(value: FontEdge): Promise<void>



/**
   * Subscriber: The preferred font edge style for displaying closed-captions.
   * 
   */
function fontEdge(subscriber: (edge: FontEdge) => void): Promise<number>


  /**
   * Getter: The preferred font edge color for displaying closed-captions.
   * 
  */
  function fontEdgeColor(): Promise<Color>


  /**
   * Setter: The preferred font edge color for displaying closed-captions.
   * 
   */
  function fontEdgeColor(value: Color): Promise<void>



/**
   * Subscriber: The preferred font edge color for displaying closed-captions.
   * 
   */
function fontEdgeColor(subscriber: (color: Color) => void): Promise<number>


  /**
   * Getter: The preferred font family for displaying closed-captions.
   * 
  */
  function fontFamily(): Promise<FontFamily>


  /**
   * Setter: The preferred font family for displaying closed-captions.
   * 
   */
  function fontFamily(value: FontFamily): Promise<void>



/**
   * Subscriber: The preferred font family for displaying closed-captions.
   * 
   */
function fontFamily(subscriber: (family: FontFamily) => void): Promise<number>


  /**
   * Getter: The preferred opacity for displaying closed-captions characters.
   * 
  */
  function fontOpacity(): Promise<Opacity>


  /**
   * Setter: The preferred opacity for displaying closed-captions characters.
   * 
   */
  function fontOpacity(value: Opacity): Promise<void>



/**
   * Subscriber: The preferred opacity for displaying closed-captions characters.
   * 
   */
function fontOpacity(subscriber: (opacity: Opacity) => void): Promise<number>


  /**
   * Getter: The preferred font size for displaying closed-captions.
   * 
  */
  function fontSize(): Promise<FontSize>


  /**
   * Setter: The preferred font size for displaying closed-captions.
   * 
   */
  function fontSize(value: FontSize): Promise<void>



/**
   * Subscriber: The preferred font size for displaying closed-captions.
   * 
   */
function fontSize(subscriber: (size: FontSize) => void): Promise<number>


  /**
   * Listen to all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function listen(callback: (event: string, data: object) => void): Promise<number>
  /**
   * The preferred background color for displaying closed-captions, .
   * 
   * @param {'backgroundColorChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'backgroundColorChanged', callback: (data: Color) => void): Promise<number>

  /**
   * The preferred background color for displaying closed-captions, .
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'backgroundColorChanged'} event
   * @param {Function} callback
  */
function once(event: 'backgroundColorChanged', callback: (data: Color) => void): Promise<number>

  /**
   * The preferred opacity for displaying closed-captions backgrounds.
   * 
   * @param {'backgroundOpacityChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'backgroundOpacityChanged', callback: (data: Opacity) => void): Promise<number>

  /**
   * The preferred opacity for displaying closed-captions backgrounds.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'backgroundOpacityChanged'} event
   * @param {Function} callback
  */
function once(event: 'backgroundOpacityChanged', callback: (data: Opacity) => void): Promise<number>

  /**
   * Listen for the first of any and all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function once(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Whether or not closed-captions are enabled.
   * 
   * @param {'enabledChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'enabledChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether or not closed-captions are enabled.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'enabledChanged'} event
   * @param {Function} callback
  */
function once(event: 'enabledChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * The preferred font color for displaying closed-captions.
   * 
   * @param {'fontColorChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'fontColorChanged', callback: (data: Color) => void): Promise<number>

  /**
   * The preferred font color for displaying closed-captions.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'fontColorChanged'} event
   * @param {Function} callback
  */
function once(event: 'fontColorChanged', callback: (data: Color) => void): Promise<number>

  /**
   * The preferred font edge style for displaying closed-captions.
   * 
   * @param {'fontEdgeChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'fontEdgeChanged', callback: (data: FontEdge) => void): Promise<number>

  /**
   * The preferred font edge style for displaying closed-captions.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'fontEdgeChanged'} event
   * @param {Function} callback
  */
function once(event: 'fontEdgeChanged', callback: (data: FontEdge) => void): Promise<number>

  /**
   * The preferred font edge color for displaying closed-captions.
   * 
   * @param {'fontEdgeColorChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'fontEdgeColorChanged', callback: (data: Color) => void): Promise<number>

  /**
   * The preferred font edge color for displaying closed-captions.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'fontEdgeColorChanged'} event
   * @param {Function} callback
  */
function once(event: 'fontEdgeColorChanged', callback: (data: Color) => void): Promise<number>

  /**
   * The preferred font family for displaying closed-captions.
   * 
   * @param {'fontFamilyChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'fontFamilyChanged', callback: (data: FontFamily) => void): Promise<number>

  /**
   * The preferred font family for displaying closed-captions.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'fontFamilyChanged'} event
   * @param {Function} callback
  */
function once(event: 'fontFamilyChanged', callback: (data: FontFamily) => void): Promise<number>

  /**
   * The preferred opacity for displaying closed-captions characters.
   * 
   * @param {'fontOpacityChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'fontOpacityChanged', callback: (data: Opacity) => void): Promise<number>

  /**
   * The preferred opacity for displaying closed-captions characters.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'fontOpacityChanged'} event
   * @param {Function} callback
  */
function once(event: 'fontOpacityChanged', callback: (data: Opacity) => void): Promise<number>

  /**
   * The preferred font size for displaying closed-captions.
   * 
   * @param {'fontSizeChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'fontSizeChanged', callback: (data: FontSize) => void): Promise<number>

  /**
   * The preferred font size for displaying closed-captions.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'fontSizeChanged'} event
   * @param {Function} callback
  */
function once(event: 'fontSizeChanged', callback: (data: FontSize) => void): Promise<number>

  /**
   * A prioritized list of ISO 639-2/B codes for the preferred closed captions languages on this device.
   * 
   * @param {'preferredLanguagesChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'preferredLanguagesChanged', callback: (data: ISO639_2Language[]) => void): Promise<number>

  /**
   * A prioritized list of ISO 639-2/B codes for the preferred closed captions languages on this device.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'preferredLanguagesChanged'} event
   * @param {Function} callback
  */
function once(event: 'preferredLanguagesChanged', callback: (data: ISO639_2Language[]) => void): Promise<number>

  /**
   * The preferred horizontal alignment for displaying closed-captions characters.
   * 
   * @param {'textAlignChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'textAlignChanged', callback: (data: HorizontalAlignment) => void): Promise<number>

  /**
   * The preferred horizontal alignment for displaying closed-captions characters.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'textAlignChanged'} event
   * @param {Function} callback
  */
function once(event: 'textAlignChanged', callback: (data: HorizontalAlignment) => void): Promise<number>

  /**
   * The preferred horizontal alignment for displaying closed-captions characters.
   * 
   * @param {'textAlignVerticalChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'textAlignVerticalChanged', callback: (data: VerticalAlignment) => void): Promise<number>

  /**
   * The preferred horizontal alignment for displaying closed-captions characters.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'textAlignVerticalChanged'} event
   * @param {Function} callback
  */
function once(event: 'textAlignVerticalChanged', callback: (data: VerticalAlignment) => void): Promise<number>

  /**
   * The preferred window color for displaying closed-captions, .
   * 
   * @param {'windowColorChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'windowColorChanged', callback: (data: Color) => void): Promise<number>

  /**
   * The preferred window color for displaying closed-captions, .
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'windowColorChanged'} event
   * @param {Function} callback
  */
function once(event: 'windowColorChanged', callback: (data: Color) => void): Promise<number>

  /**
   * The preferred window opacity for displaying closed-captions backgrounds.
   * 
   * @param {'windowOpacityChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'windowOpacityChanged', callback: (data: Opacity) => void): Promise<number>

  /**
   * The preferred window opacity for displaying closed-captions backgrounds.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'windowOpacityChanged'} event
   * @param {Function} callback
  */
function once(event: 'windowOpacityChanged', callback: (data: Opacity) => void): Promise<number>

  /**
   * Getter: A prioritized list of ISO 639-2/B codes for the preferred closed captions languages on this device.
   * 
  */
  function preferredLanguages(): Promise<ISO639_2Language[]>


  /**
   * Setter: A prioritized list of ISO 639-2/B codes for the preferred closed captions languages on this device.
   * 
   */
  function preferredLanguages(value: ISO639_2Language[]): Promise<void>



/**
   * Subscriber: A prioritized list of ISO 639-2/B codes for the preferred closed captions languages on this device.
   * 
   */
function preferredLanguages(subscriber: (languages: ISO639_2Language[]) => void): Promise<number>


  /**
   * Getter: The preferred horizontal alignment for displaying closed-captions characters.
   * 
  */
  function textAlign(): Promise<HorizontalAlignment>


  /**
   * Setter: The preferred horizontal alignment for displaying closed-captions characters.
   * 
   */
  function textAlign(value: HorizontalAlignment): Promise<void>



/**
   * Subscriber: The preferred horizontal alignment for displaying closed-captions characters.
   * 
   */
function textAlign(subscriber: (alignment: HorizontalAlignment) => void): Promise<number>


  /**
   * Getter: The preferred horizontal alignment for displaying closed-captions characters.
   * 
  */
  function textAlignVertical(): Promise<VerticalAlignment>


  /**
   * Setter: The preferred horizontal alignment for displaying closed-captions characters.
   * 
   */
  function textAlignVertical(value: VerticalAlignment): Promise<void>



/**
   * Subscriber: The preferred horizontal alignment for displaying closed-captions characters.
   * 
   */
function textAlignVertical(subscriber: (alignment: VerticalAlignment) => void): Promise<number>


  /**
   * Getter: The preferred window color for displaying closed-captions, .
   * 
  */
  function windowColor(): Promise<Color>


  /**
   * Setter: The preferred window color for displaying closed-captions, .
   * 
   */
  function windowColor(value: Color): Promise<void>



/**
   * Subscriber: The preferred window color for displaying closed-captions, .
   * 
   */
function windowColor(subscriber: (color: Color) => void): Promise<number>


  /**
   * Getter: The preferred window opacity for displaying closed-captions backgrounds.
   * 
  */
  function windowOpacity(): Promise<Opacity>


  /**
   * Setter: The preferred window opacity for displaying closed-captions backgrounds.
   * 
   */
  function windowOpacity(value: Opacity): Promise<void>



/**
   * Subscriber: The preferred window opacity for displaying closed-captions backgrounds.
   * 
   */
function windowOpacity(subscriber: (opacity: Opacity) => void): Promise<number>




}

export module AudioDescriptions {

    type Event = 'enabledChanged'

// Types



  /**
   * Turn off all listeners previously registered from this module.
   */
  function clear(): boolean

  /**
   * Clear a specific listen by the listener ID.
   * 
   * @param {number} id The id of the listener to clear
   */
  function clear(id: number): boolean

  /**
   * Getter: Whether or not audio-descriptions are enabled.
   * 
  */
  function enabled(): Promise<boolean>


  /**
   * Setter: Whether or not audio-descriptions are enabled.
   * 
   */
  function enabled(value: boolean): Promise<void>



/**
   * Subscriber: Whether or not audio-descriptions are enabled.
   * 
   */
function enabled(subscriber: (enabled: boolean) => void): Promise<number>


  /**
   * Listen to all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function listen(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Listen for the first of any and all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function once(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Whether or not audio-descriptions are enabled.
   * 
   * @param {'enabledChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'enabledChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether or not audio-descriptions are enabled.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'enabledChanged'} event
   * @param {Function} callback
  */
function once(event: 'enabledChanged', callback: (data: boolean) => void): Promise<number>



}

export module VoiceGuidance {

    type Event = 'enabledChanged' | 'speedChanged'

// Types

    /**
     * 
     */
type VoiceSpeed = number


  /**
   * Turn off all listeners previously registered from this module.
   */
  function clear(): boolean

  /**
   * Clear a specific listen by the listener ID.
   * 
   * @param {number} id The id of the listener to clear
   */
  function clear(id: number): boolean

  /**
   * Getter: Whether or not voice-guidance is enabled.
   * 
  */
  function enabled(): Promise<boolean>


  /**
   * Setter: Whether or not voice-guidance is enabled.
   * 
   */
  function enabled(value: boolean): Promise<void>



/**
   * Subscriber: Whether or not voice-guidance is enabled.
   * 
   */
function enabled(subscriber: (enabled: boolean) => void): Promise<number>


  /**
   * Listen to all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function listen(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Listen for the first of any and all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function once(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Whether or not voice-guidance is enabled.
   * 
   * @param {'enabledChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'enabledChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether or not voice-guidance is enabled.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'enabledChanged'} event
   * @param {Function} callback
  */
function once(event: 'enabledChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * The speed at which voice guidance speech will be read back to the user.
   * 
   * @param {'speedChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'speedChanged', callback: (data: VoiceSpeed) => void): Promise<number>

  /**
   * The speed at which voice guidance speech will be read back to the user.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'speedChanged'} event
   * @param {Function} callback
  */
function once(event: 'speedChanged', callback: (data: VoiceSpeed) => void): Promise<number>

  /**
   * Getter: The speed at which voice guidance speech will be read back to the user.
   * 
  */
  function speed(): Promise<VoiceSpeed>


  /**
   * Setter: The speed at which voice guidance speech will be read back to the user.
   * 
   */
  function speed(value: VoiceSpeed): Promise<void>



/**
   * Subscriber: The speed at which voice guidance speech will be read back to the user.
   * 
   */
function speed(subscriber: (speed: VoiceSpeed) => void): Promise<number>




}

export module Device {

    type Event = 'deviceNameChanged' | 'nameChanged'

// Types



  /**
   * Turn off all listeners previously registered from this module.
   */
  function clear(): boolean

  /**
   * Clear a specific listen by the listener ID.
   * 
   * @param {number} id The id of the listener to clear
   */
  function clear(id: number): boolean

  /**
   * Listen to all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function listen(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Getter: The human readable name of the device
   * 
  */
  function name(): Promise<string>


  /**
   * Setter: The human readable name of the device
   * 
   */
  function name(value: string): Promise<void>



/**
   * Subscriber: The human readable name of the device
   * 
   */
function name(subscriber: (value: string) => void): Promise<number>


  /**
   * Listen for the first of any and all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function once(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Get the human readable name of the device
   * 
   * @param {'deviceNameChanged'} event
   * @param {Function} callback
   * @deprecated since version 0.6.0
  */
  function listen(event: 'deviceNameChanged', callback: (data: string) => void): Promise<number>

  /**
   * Get the human readable name of the device
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'deviceNameChanged'} event
   * @param {Function} callback
   * @deprecated since version 0.6.0
  */
function once(event: 'deviceNameChanged', callback: (data: string) => void): Promise<number>

  /**
   * The human readable name of the device
   * 
   * @param {'nameChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'nameChanged', callback: (data: string) => void): Promise<number>

  /**
   * The human readable name of the device
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'nameChanged'} event
   * @param {Function} callback
  */
function once(event: 'nameChanged', callback: (data: string) => void): Promise<number>

  /**
   * Used by a distributor to push provision info to firebolt.
   * 
   * @param {string} accountId The id of the account that is device is attached to in the back office.
   * @param {string} deviceId The id of the device in the back office.
   * @param {string} distributorId The id of the distributor in the back office.
  */
  function provision(accountId: string, deviceId: string, distributorId?: string): Promise<void>



}

export module UserGrants {


// Types

    /**
     * Role provides access level for the app for a given capability.
     */
enum Role {
    USE = 'use',
    MANAGE = 'manage',
    PROVIDE = 'provide',
}


    /**
     * The state the grant is in
     */
enum GrantState {
    GRANTED = 'granted',
    DENIED = 'denied',
}


    /**
     * Information about an app that a grant was for
     */
type AppInfo = {
    id: string
    title?: string
}


    /**
     * Options when modifying any grant
     */
type GrantModificationOptions = {
    appId?: string
}


    /**
     * A Capability is a discrete unit of functionality that a Firebolt device might be able to perform.
     */
type Capability = string

    /**
     * 
     */
type RequestOptions = {
    force?: boolean // Whether to force for user grant even if the previous decision stored
}


    /**
     * Information about a grant given by a user
     */
type GrantInfo = {
    app?: AppInfo // Information about an app that a grant was for
    state: GrantState // The state the grant is in
    capability: Capability // A Capability is a discrete unit of functionality that a Firebolt device might be able to perform.
    role: Role // Role provides access level for the app for a given capability.
    lifespan: 'once' | 'forever' | 'appActive' | 'powerActive' | 'seconds'
    expires?: string
}


    /**
     * A capability combined with a Role, which an app may be permitted (by a distributor) or granted (by an end user).
     */
type Permission = {
    role?: Role // Role provides access level for the app for a given capability.
    capability: Capability // A Capability is a discrete unit of functionality that a Firebolt device might be able to perform.
}



  /**
   * Get all granted and denied user grants for the given app
   * 
   * @param {string} appId 
  */
  function app(appId: string): Promise<GrantInfo[]>

  /**
   * Get all granted and denied user grants for the given capability
   * 
   * @param {Capability} capability 
  */
  function capability(capability: Capability): Promise<GrantInfo[]>

  /**
   * Clears the grant for a given capability, to a specific app if appropriate. Calling this results in a persisted Denied Grant that lasts for the duration of the Grant Policy lifespan. 
   * 
   * @param {Role} role 
   * @param {Capability} capability 
   * @param {GrantModificationOptions} options 
  */
  function clear(role: Role, capability: Capability, options?: GrantModificationOptions): Promise<void>

  /**
   * Denies a given capability, to a specific app if appropriate. Calling this results in a persisted Denied Grant that lasts for the duration of the Grant Policy lifespan. 
   * 
   * @param {Role} role 
   * @param {Capability} capability 
   * @param {GrantModificationOptions} options 
  */
  function deny(role: Role, capability: Capability, options?: GrantModificationOptions): Promise<void>

  /**
   * Get all granted and denied user grants for the device
   * 
  */
  function device(): Promise<GrantInfo[]>

  /**
   * Grants a given capability to a specific app, if appropriate. Calling this results in a persisted active grant that lasts for the duration of the grant policy lifespan. 
   * 
   * @param {Role} role 
   * @param {Capability} capability 
   * @param {GrantModificationOptions} options 
  */
  function grant(role: Role, capability: Capability, options?: GrantModificationOptions): Promise<void>

  /**
   * Requests Firebolt to carry out a set of user grants for a given application such that the user grant provider is notified or an existing user grant is reused.
   * 
   * @param {string} appId 
   * @param {Permission[]} permissions 
   * @param {RequestOptions} options Request options
  */
  function request(appId: string, permissions: Permission[], options?: RequestOptions): Promise<GrantInfo[]>



}

export module Privacy {

    type Event = 'allowACRCollectionChanged' | 'allowAppContentAdTargetingChanged' | 'allowCameraAnalyticsChanged' | 'allowPersonalizationChanged' | 'allowPrimaryBrowseAdTargetingChanged' | 'allowPrimaryContentAdTargetingChanged' | 'allowProductAnalyticsChanged' | 'allowRemoteDiagnosticsChanged' | 'allowResumePointsChanged' | 'allowUnentitledPersonalizationChanged' | 'allowUnentitledResumePointsChanged' | 'allowWatchHistoryChanged'

// Types

    /**
     * 
     */
type PrivacySettings = {
    allowACRCollection: boolean
    allowResumePoints: boolean
    allowAppContentAdTargeting: boolean
    allowCameraAnalytics: boolean
    allowPersonalization: boolean
    allowPrimaryBrowseAdTargeting: boolean
    allowPrimaryContentAdTargeting: boolean
    allowProductAnalytics: boolean
    allowRemoteDiagnostics: boolean
    allowUnentitledPersonalization: boolean
    allowUnentitledResumePoints: boolean
    allowWatchHistory: boolean
}



  /**
   * Getter: Whether the user allows their automatic content recognition data to be collected
   * 
  */
  function allowACRCollection(): Promise<boolean>


  /**
   * Setter: Whether the user allows their automatic content recognition data to be collected
   * 
   */
  function allowACRCollection(value: boolean): Promise<void>



/**
   * Subscriber: Whether the user allows their automatic content recognition data to be collected
   * 
   */
function allowACRCollection(subscriber: (allow: boolean) => void): Promise<number>


  /**
   * Getter: Whether the user allows ads to be targeted to the user while watching content in apps
   * 
  */
  function allowAppContentAdTargeting(): Promise<boolean>


  /**
   * Setter: Whether the user allows ads to be targeted to the user while watching content in apps
   * 
   */
  function allowAppContentAdTargeting(value: boolean): Promise<void>



/**
   * Subscriber: Whether the user allows ads to be targeted to the user while watching content in apps
   * 
   */
function allowAppContentAdTargeting(subscriber: (allow: boolean) => void): Promise<number>


  /**
   * Getter: Whether the user allows data from their camera to be used for Product Analytics
   * 
  */
  function allowCameraAnalytics(): Promise<boolean>


  /**
   * Setter: Whether the user allows data from their camera to be used for Product Analytics
   * 
   */
  function allowCameraAnalytics(value: boolean): Promise<void>



/**
   * Subscriber: Whether the user allows data from their camera to be used for Product Analytics
   * 
   */
function allowCameraAnalytics(subscriber: (allow: boolean) => void): Promise<number>


  /**
   * Getter: Whether the user allows their usage data to be used for personalization and recommendations
   * 
  */
  function allowPersonalization(): Promise<boolean>


  /**
   * Setter: Whether the user allows their usage data to be used for personalization and recommendations
   * 
   */
  function allowPersonalization(value: boolean): Promise<void>



/**
   * Subscriber: Whether the user allows their usage data to be used for personalization and recommendations
   * 
   */
function allowPersonalization(subscriber: (allow: boolean) => void): Promise<number>


  /**
   * Getter: Whether the user allows ads to be targeted to the user while browsing in the primary experience
   * 
  */
  function allowPrimaryBrowseAdTargeting(): Promise<boolean>


  /**
   * Setter: Whether the user allows ads to be targeted to the user while browsing in the primary experience
   * 
   */
  function allowPrimaryBrowseAdTargeting(value: boolean): Promise<void>



/**
   * Subscriber: Whether the user allows ads to be targeted to the user while browsing in the primary experience
   * 
   */
function allowPrimaryBrowseAdTargeting(subscriber: (allow: boolean) => void): Promise<number>


  /**
   * Getter: Whether the user allows ads to be targeted to the user while watching content in the primary experience
   * 
  */
  function allowPrimaryContentAdTargeting(): Promise<boolean>


  /**
   * Setter: Whether the user allows ads to be targeted to the user while watching content in the primary experience
   * 
   */
  function allowPrimaryContentAdTargeting(value: boolean): Promise<void>



/**
   * Subscriber: Whether the user allows ads to be targeted to the user while watching content in the primary experience
   * 
   */
function allowPrimaryContentAdTargeting(subscriber: (allow: boolean) => void): Promise<number>


  /**
   * Getter: Whether the user allows their usage data can be used for analytics about the product
   * 
  */
  function allowProductAnalytics(): Promise<boolean>


  /**
   * Setter: Whether the user allows their usage data can be used for analytics about the product
   * 
   */
  function allowProductAnalytics(value: boolean): Promise<void>



/**
   * Subscriber: Whether the user allows their usage data can be used for analytics about the product
   * 
   */
function allowProductAnalytics(subscriber: (allow: boolean) => void): Promise<number>


  /**
   * Getter: Whether the user allows their personal data to be included in diagnostic telemetry. This also allows whether device logs can be remotely accessed from the client device
   * 
  */
  function allowRemoteDiagnostics(): Promise<boolean>


  /**
   * Setter: Whether the user allows their personal data to be included in diagnostic telemetry. This also allows whether device logs can be remotely accessed from the client device
   * 
   */
  function allowRemoteDiagnostics(value: boolean): Promise<void>



/**
   * Subscriber: Whether the user allows their personal data to be included in diagnostic telemetry. This also allows whether device logs can be remotely accessed from the client device
   * 
   */
function allowRemoteDiagnostics(subscriber: (allow: boolean) => void): Promise<number>


  /**
   * Getter: Whether the user allows resume points for content to show in the main experience
   * 
  */
  function allowResumePoints(): Promise<boolean>


  /**
   * Setter: Whether the user allows resume points for content to show in the main experience
   * 
   */
  function allowResumePoints(value: boolean): Promise<void>



/**
   * Subscriber: Whether the user allows resume points for content to show in the main experience
   * 
   */
function allowResumePoints(subscriber: (allow: boolean) => void): Promise<number>


  /**
   * Getter: Whether the user allows their usage data to be used for personalization and recommendations for unentitled content
   * 
  */
  function allowUnentitledPersonalization(): Promise<boolean>


  /**
   * Setter: Whether the user allows their usage data to be used for personalization and recommendations for unentitled content
   * 
   */
  function allowUnentitledPersonalization(value: boolean): Promise<void>



/**
   * Subscriber: Whether the user allows their usage data to be used for personalization and recommendations for unentitled content
   * 
   */
function allowUnentitledPersonalization(subscriber: (allow: boolean) => void): Promise<number>


  /**
   * Getter: Whether the user allows resume points for content from unentitled providers to show in the main experience
   * 
  */
  function allowUnentitledResumePoints(): Promise<boolean>


  /**
   * Setter: Whether the user allows resume points for content from unentitled providers to show in the main experience
   * 
   */
  function allowUnentitledResumePoints(value: boolean): Promise<void>



/**
   * Subscriber: Whether the user allows resume points for content from unentitled providers to show in the main experience
   * 
   */
function allowUnentitledResumePoints(subscriber: (allow: boolean) => void): Promise<number>


  /**
   * Getter: Whether the user allows their watch history from all sources to show in the main experience
   * 
  */
  function allowWatchHistory(): Promise<boolean>


  /**
   * Setter: Whether the user allows their watch history from all sources to show in the main experience
   * 
   */
  function allowWatchHistory(value: boolean): Promise<void>



/**
   * Subscriber: Whether the user allows their watch history from all sources to show in the main experience
   * 
   */
function allowWatchHistory(subscriber: (allow: boolean) => void): Promise<number>


  /**
   * Turn off all listeners previously registered from this module.
   */
  function clear(): boolean

  /**
   * Clear a specific listen by the listener ID.
   * 
   * @param {number} id The id of the listener to clear
   */
  function clear(id: number): boolean

  /**
   * Listen to all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function listen(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Whether the user allows their automatic content recognition data to be collected
   * 
   * @param {'allowACRCollectionChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'allowACRCollectionChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows their automatic content recognition data to be collected
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'allowACRCollectionChanged'} event
   * @param {Function} callback
  */
function once(event: 'allowACRCollectionChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows ads to be targeted to the user while watching content in apps
   * 
   * @param {'allowAppContentAdTargetingChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'allowAppContentAdTargetingChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows ads to be targeted to the user while watching content in apps
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'allowAppContentAdTargetingChanged'} event
   * @param {Function} callback
  */
function once(event: 'allowAppContentAdTargetingChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows data from their camera to be used for Product Analytics
   * 
   * @param {'allowCameraAnalyticsChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'allowCameraAnalyticsChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows data from their camera to be used for Product Analytics
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'allowCameraAnalyticsChanged'} event
   * @param {Function} callback
  */
function once(event: 'allowCameraAnalyticsChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows their usage data to be used for personalization and recommendations
   * 
   * @param {'allowPersonalizationChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'allowPersonalizationChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows their usage data to be used for personalization and recommendations
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'allowPersonalizationChanged'} event
   * @param {Function} callback
  */
function once(event: 'allowPersonalizationChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows ads to be targeted to the user while browsing in the primary experience
   * 
   * @param {'allowPrimaryBrowseAdTargetingChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'allowPrimaryBrowseAdTargetingChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows ads to be targeted to the user while browsing in the primary experience
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'allowPrimaryBrowseAdTargetingChanged'} event
   * @param {Function} callback
  */
function once(event: 'allowPrimaryBrowseAdTargetingChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows ads to be targeted to the user while watching content in the primary experience
   * 
   * @param {'allowPrimaryContentAdTargetingChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'allowPrimaryContentAdTargetingChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows ads to be targeted to the user while watching content in the primary experience
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'allowPrimaryContentAdTargetingChanged'} event
   * @param {Function} callback
  */
function once(event: 'allowPrimaryContentAdTargetingChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows their usage data can be used for analytics about the product
   * 
   * @param {'allowProductAnalyticsChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'allowProductAnalyticsChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows their usage data can be used for analytics about the product
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'allowProductAnalyticsChanged'} event
   * @param {Function} callback
  */
function once(event: 'allowProductAnalyticsChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows their personal data to be included in diagnostic telemetry. This also allows whether device logs can be remotely accessed from the client device
   * 
   * @param {'allowRemoteDiagnosticsChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'allowRemoteDiagnosticsChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows their personal data to be included in diagnostic telemetry. This also allows whether device logs can be remotely accessed from the client device
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'allowRemoteDiagnosticsChanged'} event
   * @param {Function} callback
  */
function once(event: 'allowRemoteDiagnosticsChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows resume points for content to show in the main experience
   * 
   * @param {'allowResumePointsChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'allowResumePointsChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows resume points for content to show in the main experience
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'allowResumePointsChanged'} event
   * @param {Function} callback
  */
function once(event: 'allowResumePointsChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows their usage data to be used for personalization and recommendations for unentitled content
   * 
   * @param {'allowUnentitledPersonalizationChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'allowUnentitledPersonalizationChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows their usage data to be used for personalization and recommendations for unentitled content
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'allowUnentitledPersonalizationChanged'} event
   * @param {Function} callback
  */
function once(event: 'allowUnentitledPersonalizationChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows resume points for content from unentitled providers to show in the main experience
   * 
   * @param {'allowUnentitledResumePointsChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'allowUnentitledResumePointsChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows resume points for content from unentitled providers to show in the main experience
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'allowUnentitledResumePointsChanged'} event
   * @param {Function} callback
  */
function once(event: 'allowUnentitledResumePointsChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows their watch history from all sources to show in the main experience
   * 
   * @param {'allowWatchHistoryChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'allowWatchHistoryChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Whether the user allows their watch history from all sources to show in the main experience
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'allowWatchHistoryChanged'} event
   * @param {Function} callback
  */
function once(event: 'allowWatchHistoryChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Listen for the first of any and all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function once(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Gets the allowed value for all privacy settings
   * 
  */
  function settings(): Promise<PrivacySettings>



}

export module Advertising {

    type Event = 'skipRestrictionChanged'

// Types

    /**
     * The advertisement skip restriction.

Applies to fast-forward/rewind (e.g. trick mode), seeking over an entire opportunity (e.g. jump), seeking out of what's currently playing, and "Skip this ad..." features. Seeking over multiple ad opportunities only requires playback of the _last_ opportunity, not all opportunities, preceding the seek destination.

| Value        | Description                                                                    |
|--------------|--------------------------------------------------------------------------------|
| none         |No fast-forward, jump, or skip restrictions                                    |
| adsUnwatched | Restrict fast-forward, jump, and skip for unwatched ad opportunities only.     |
| adsAll       | Restrict fast-forward, jump, and skip for all ad opportunities                 |
| all          | Restrict fast-forward, jump, and skip for all ad opportunities and all content |

Namespace: `xrn:advertising:policy:skipRestriction:`


     */
enum SkipRestriction {
    NONE = 'none',
    ADS_UNWATCHED = 'adsUnwatched',
    ADS_ALL = 'adsAll',
    ALL = 'all',
}



  /**
   * Turn off all listeners previously registered from this module.
   */
  function clear(): boolean

  /**
   * Clear a specific listen by the listener ID.
   * 
   * @param {number} id The id of the listener to clear
   */
  function clear(id: number): boolean

  /**
   * Listen to all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function listen(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Listen for the first of any and all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function once(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Set the value for AdPolicy.skipRestriction
   * 
   * @param {'skipRestrictionChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'skipRestrictionChanged', callback: (data: SkipRestriction) => void): Promise<number>

  /**
   * Set the value for AdPolicy.skipRestriction
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'skipRestrictionChanged'} event
   * @param {Function} callback
  */
function once(event: 'skipRestrictionChanged', callback: (data: SkipRestriction) => void): Promise<number>

  /**
   * Resets a user's identifier in the ad platform so that the advertising id that apps get will be a new value
   * 
  */
  function resetIdentifier(): Promise<void>

  /**
   * Getter: Set the value for AdPolicy.skipRestriction
   * 
  */
  function skipRestriction(): Promise<SkipRestriction>


  /**
   * Setter: Set the value for AdPolicy.skipRestriction
   * 
   */
  function skipRestriction(value: SkipRestriction): Promise<void>



/**
   * Subscriber: Set the value for AdPolicy.skipRestriction
   * 
   */
function skipRestriction(subscriber: (result: SkipRestriction) => void): Promise<number>




}

export module Account {


// Types

    /**
     * Encoded token provided by the Distributor for Device Authentication.
     */
type Token = string

    /**
     * Number of secs before the token expires
     */
type Expiry = number


  /**
   * Used by a distributor to push Session token to firebolt.
   * 
   * @param {Token} token 
   * @param {Expiry} expiresIn 
  */
  function session(token: Token, expiresIn: Expiry): Promise<void>



}

export module Keyboard {


// Types

    /**
     * 
     */
type KeyboardParameters = {
    message: string // The message to display to the user so the user knows what they are entering
}


    /**
     * 
     */
type KeyboardProviderRequest = {
    correlationId: string // An id to correlate the provider response with this request
    parameters: KeyboardParameters // The request to start a keyboard session
}




// Provider Interfaces

interface ProviderSession {
    correlationId(): string        // Returns the correlation id of the current provider session
}

interface FocusableProviderSession extends ProviderSession {
    focus(): Promise<void>         // Requests that the provider app be moved into focus to prevent a user experience
}

interface KeyboardInputProvider {
    standard(parameters: KeyboardParameters, session: FocusableProviderSession): Promise<string>
    password(parameters: KeyboardParameters, session: FocusableProviderSession): Promise<string>
    email(parameters: KeyboardParameters, session: FocusableProviderSession): Promise<string>

}


function provide(capability: 'xrn:firebolt:capability:input:keyboard', provider: KeyboardInputProvider | object): Promise<void>

}

export module AcknowledgeChallenge {


// Types

    /**
     * 
     */
type GrantResult = {
    granted: boolean
}


    /**
     * 
     */
type ChallengeRequestor = {
    id: string // The id of the app that requested the challenge
    name: string // The name of the app that requested the challenge
}


    /**
     * 
     */
type Challenge = {
    capability: string // The capability that is being requested by the user to approve
    requestor: ChallengeRequestor // The identity of which app is requesting access to this capability
}


    /**
     * 
     */
type ChallengeProviderRequest = {
    parameters: Challenge // The result of the provider response.
    correlationId: string // The id that was passed in to the event that triggered a provider method to be called
}




// Provider Interfaces

interface ProviderSession {
    correlationId(): string        // Returns the correlation id of the current provider session
}

interface FocusableProviderSession extends ProviderSession {
    focus(): Promise<void>         // Requests that the provider app be moved into focus to prevent a user experience
}

interface ChallengeProvider {
    challenge(parameters: Challenge, session: FocusableProviderSession): Promise<GrantResult>

}


function provide(capability: 'xrn:firebolt:capability:usergrant:acknowledgechallenge', provider: ChallengeProvider | object): Promise<void>

}

export module PinChallenge {


// Types

    /**
     * The reason for the result of challenging the user
     */
enum ResultReason {
    NO_PIN_REQUIRED = 'noPinRequired',
    NO_PIN_REQUIRED_WINDOW = 'noPinRequiredWindow',
    EXCEEDED_PIN_FAILURES = 'exceededPinFailures',
    CORRECT_PIN = 'correctPin',
    CANCELLED = 'cancelled',
}


    /**
     * 
     */
type PinChallengeResult = {
    granted: boolean
    reason: ResultReason // The reason for the result of challenging the user
}


    /**
     * 
     */
type ChallengeRequestor = {
    id: string // The id of the app that requested the challenge
    name: string // The name of the app that requested the challenge
}


    /**
     * 
     */
type PinChallenge = {
    pinSpace: 'purchase' | 'content' // The pin space that this challenge is for
    capability?: string // The capability that is gated by a pin challenge
    requestor: ChallengeRequestor // The identity of which app is requesting access to this capability
}


    /**
     * 
     */
type PinChallengeProviderRequest = {
    parameters: PinChallenge // The result of the provider response.
    correlationId: string // The id that was passed in to the event that triggered a provider method to be called
}




// Provider Interfaces

interface ProviderSession {
    correlationId(): string        // Returns the correlation id of the current provider session
}

interface FocusableProviderSession extends ProviderSession {
    focus(): Promise<void>         // Requests that the provider app be moved into focus to prevent a user experience
}

interface ChallengeProvider {
    challenge(parameters: PinChallenge, session: FocusableProviderSession): Promise<PinChallengeResult>

}


function provide(capability: 'xrn:firebolt:capability:usergrant:pinchallenge', provider: ChallengeProvider | object): Promise<void>

}

export module SecureStorage {


// Types

    /**
     * The scope of the data
     */
enum StorageScope {
    DEVICE = 'device',
    ACCOUNT = 'account',
}


    /**
     * 
     */
type StorageOptions = {
    ttl: number // Seconds from set time before the data expires and is removed
}



  /**
   * Clears all the secure data values for a specific app
   * 
   * @param {string} appId appId for which values are removed
   * @param {StorageScope} scope The scope of the key/value
  */
  function clearForApp(appId: string, scope: StorageScope): Promise<void>

  /**
   * Removes single data value for a specific app.
   * 
   * @param {string} appId appId for which values are removed
   * @param {StorageScope} scope The scope of the key/value
   * @param {string} key Key to remove
  */
  function removeForApp(appId: string, scope: StorageScope, key: string): Promise<void>

  /**
   * Set or update a secure data value for a specific app.
   * 
   * @param {string} appId appId for which value is being set
   * @param {StorageScope} scope The scope of the data key
   * @param {string} key Key to set
   * @param {string} value Value to set
   * @param {StorageOptions} options Optional parameters to set
  */
  function setForApp(appId: string, scope: StorageScope, key: string, value: string, options?: StorageOptions): Promise<void>



}

export module Discovery {

    type Event = 'signIn' | 'signOut'

// Types



  /**
   * Turn off all listeners previously registered from this module.
   */
  function clear(): boolean

  /**
   * Clear a specific listen by the listener ID.
   * 
   * @param {number} id The id of the listener to clear
   */
  function clear(id: number): boolean

  /**
   * Listen to all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function listen(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Listen for the first of any and all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function once(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Listen to events from all apps that call Discovery.signIn
   * 
   * @param {'signIn'} event
   * @param {Function} callback
  */
  function listen(event: 'signIn', callback: (data: object) => void): Promise<number>

  /**
   * Listen to events from all apps that call Discovery.signIn
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'signIn'} event
   * @param {Function} callback
  */
function once(event: 'signIn', callback: (data: object) => void): Promise<number>

  /**
   * Listen to events from all apps that call Discovery.signOut
   * 
   * @param {'signOut'} event
   * @param {Function} callback
  */
  function listen(event: 'signOut', callback: (data: object) => void): Promise<number>

  /**
   * Listen to events from all apps that call Discovery.signOut
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'signOut'} event
   * @param {Function} callback
  */
function once(event: 'signOut', callback: (data: object) => void): Promise<number>



}

export module HDMIInput {

    type Event = 'autoLowLatencyModeCapableChanged' | 'autoLowLatencyModeSignalChanged' | 'connectionChanged' | 'edidVersionChanged' | 'lowLatencyModeChanged' | 'signalChanged'

// Types

    /**
     * 
     */
enum EDIDVersion {
    V1_4 = '1.4',
    V2_0 = '2.0',
    UNKNOWN = 'unknown',
}


    /**
     * 
     */
enum HDMISignalStatus {
    NONE = 'none',
    STABLE = 'stable',
    UNSTABLE = 'unstable',
    UNSUPPORTED = 'unsupported',
    UNKNOWN = 'unknown',
}


    /**
     * 
     */
type HDMIPortId = string

    /**
     * 
     */
type SignalChangedInfo = {
    port: HDMIPortId
    signal: HDMISignalStatus
}


    /**
     * 
     */
type AutoLowLatencyModeSignalChangedInfo = {
    port?: HDMIPortId
    autoLowLatencyModeSignalled?: boolean
}


    /**
     * 
     */
type HDMIInputPort = {
    port: HDMIPortId
    connected: boolean
    signal: HDMISignalStatus
    arcCapable: boolean
    arcConnected: boolean
    edidVersion: EDIDVersion
    autoLowLatencyModeCapable: boolean
    autoLowLatencyModeSignalled: boolean
}


    /**
     * 
     */
type AutoLowLatencyModeCapableChangedInfo = {
    port: HDMIPortId
    enabled: boolean
}


    /**
     * 
     */
type ConnectionChangedInfo = {
    port?: HDMIPortId
    connected?: boolean
}



  /**
   * Getter: Property for each port auto low latency mode setting.
   * 
   * @param {HDMIPortId} port 
  */
  function autoLowLatencyModeCapable(port: HDMIPortId): Promise<boolean>


  /**
   * Setter: Property for each port auto low latency mode setting.
   * 
   */
  function autoLowLatencyModeCapable(port: HDMIPortId, value: boolean): Promise<void>



/**
   * Subscriber: Property for each port auto low latency mode setting.
   * 
   */
function autoLowLatencyModeCapable(subscriber: (data: AutoLowLatencyModeCapableChangedInfo) => void): Promise<number>


  /**
   * Turn off all listeners previously registered from this module.
   */
  function clear(): boolean

  /**
   * Clear a specific listen by the listener ID.
   * 
   * @param {number} id The id of the listener to clear
   */
  function clear(id: number): boolean

  /**
   * Closes the given HDMI Port if it is the current active source for HDMI Input. If there was no active source, then there would no action taken on the device.
   * 
  */
  function close(): Promise<void>

  /**
   * Getter: Property for each port's active EDID version.
   * 
   * @param {HDMIPortId} port 
  */
  function edidVersion(port: HDMIPortId): Promise<EDIDVersion>


  /**
   * Setter: Property for each port's active EDID version.
   * 
   */
  function edidVersion(port: HDMIPortId, value: EDIDVersion): Promise<void>



/**
   * Subscriber: Property for each port's active EDID version.
   * 
   */
function edidVersion(subscriber: (edidVersion: EDIDVersion) => void): Promise<number>


  /**
   * Listen to all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function listen(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Getter: Property for the low latency mode setting.
   * 
  */
  function lowLatencyMode(): Promise<boolean>


  /**
   * Setter: Property for the low latency mode setting.
   * 
   */
  function lowLatencyMode(value: boolean): Promise<void>



/**
   * Subscriber: Property for the low latency mode setting.
   * 
   */
function lowLatencyMode(subscriber: (enabled: boolean) => void): Promise<number>


  /**
   * Property for each port auto low latency mode setting.
   * 
   * @param {'autoLowLatencyModeCapableChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'autoLowLatencyModeCapableChanged', callback: (data: AutoLowLatencyModeCapableChangedInfo) => void): Promise<number>

  /**
   * Property for each port auto low latency mode setting.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'autoLowLatencyModeCapableChanged'} event
   * @param {Function} callback
  */
function once(event: 'autoLowLatencyModeCapableChanged', callback: (data: AutoLowLatencyModeCapableChangedInfo) => void): Promise<number>

  /**
   * Notification for changes to ALLM status of any input device.
   * 
   * @param {'autoLowLatencyModeSignalChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'autoLowLatencyModeSignalChanged', callback: (data: AutoLowLatencyModeSignalChangedInfo) => void): Promise<number>

  /**
   * Notification for changes to ALLM status of any input device.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'autoLowLatencyModeSignalChanged'} event
   * @param {Function} callback
  */
function once(event: 'autoLowLatencyModeSignalChanged', callback: (data: AutoLowLatencyModeSignalChangedInfo) => void): Promise<number>

  /**
   * Listen for the first of any and all events dispatched by this module.
   * 
   * @param {Function} callback
   */
  function once(callback: (event: string, data: object) => void): Promise<number>
  /**
   * Notification for when any HDMI port has a connection physically engaged or disengaged.
   * 
   * @param {'connectionChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'connectionChanged', callback: (data: ConnectionChangedInfo) => void): Promise<number>

  /**
   * Notification for when any HDMI port has a connection physically engaged or disengaged.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'connectionChanged'} event
   * @param {Function} callback
  */
function once(event: 'connectionChanged', callback: (data: ConnectionChangedInfo) => void): Promise<number>

  /**
   * Property for each port's active EDID version.
   * 
   * @param {'edidVersionChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'edidVersionChanged', port: HDMIPortId, callback: (data: EDIDVersion) => void): Promise<number>

  /**
   * Property for each port's active EDID version.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'edidVersionChanged'} event
   * @param {Function} callback
  */
function once(event: 'edidVersionChanged', port: HDMIPortId, callback: (data: EDIDVersion) => void): Promise<number>

  /**
   * Property for the low latency mode setting.
   * 
   * @param {'lowLatencyModeChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'lowLatencyModeChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Property for the low latency mode setting.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'lowLatencyModeChanged'} event
   * @param {Function} callback
  */
function once(event: 'lowLatencyModeChanged', callback: (data: boolean) => void): Promise<number>

  /**
   * Notification for when any HDMI port has it's signal status changed.
   * 
   * @param {'signalChanged'} event
   * @param {Function} callback
  */
  function listen(event: 'signalChanged', callback: (data: SignalChangedInfo) => void): Promise<number>

  /**
   * Notification for when any HDMI port has it's signal status changed.
   * When using `once` the callback method will only fire once, and then disconnect your listener
   * 
   * @param {'signalChanged'} event
   * @param {Function} callback
  */
function once(event: 'signalChanged', callback: (data: SignalChangedInfo) => void): Promise<number>

  /**
   * Opens the HDMI Port allowing it to be the active source device. Incase there is a different HDMI portId already set as the active source, this call would stop the older portId before opening the given portId.
   * 
   * @param {HDMIPortId} portId 
  */
  function open(portId: HDMIPortId): Promise<void>

  /**
   * Retrieve a specific HDMI input port.
   * 
   * @param {HDMIPortId} portId 
  */
  function port(portId: HDMIPortId): Promise<HDMIInputPort>

  /**
   * Retrieve a list of HDMI input ports.
   * 
  */
  function ports(): Promise<HDMIInputPort[]>



}
